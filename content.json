[{"title":"读书笔记-es6对象的扩展","date":"2017-05-06T02:17:56.000Z","path":"2017/05/06/读书笔记-es6对象的扩展/","text":"对象的扩展属性和方法的简洁表示法1234567891011121314151617181920212223242526var foo = 'bar';var baz = &#123;foo&#125;;baz // &#123;foo: \"bar\"&#125;// 等同于var baz = &#123;foo: foo&#125;;var o = &#123; method() &#123; return \"Hello!\"; &#125;&#125;;// 等同于var o = &#123; method: function() &#123; return \"Hello!\"; &#125;&#125;;//如果某个方法的值是一个Generator函数，前面需要加上星号。var obj = &#123; * m()&#123; yield 'hello world'; &#125;&#125;; 用于函数的返回值，将会非常方便 12345678function getPoint() &#123; var x = 1; var y = 10; return &#123;x, y&#125;;&#125;getPoint()// &#123;x:1, y:10&#125; CommonJS模块输出变量，就非常合适使用简洁写法。 123456789101112131415161718var ms = &#123;&#125;;function getItem (key) &#123; return key in ms ? ms[key] : null;&#125;function setItem (key, value) &#123; ms[key] = value;&#125;function clear () &#123; ms = &#123;&#125;;&#125;module.exports = &#123; getItem, setItem, clear &#125;;// 等同于module.exports = &#123; getItem: getItem, setItem: setItem, clear: clear&#125;; Object.is() Object.is它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。 Object.assign() Object.assign方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target） 12345678var target = &#123; a: 1 &#125;;var source1 = &#123; b: 2 &#125;;var source2 = &#123; c: 3 &#125;;Object.assign(target, source1, source2);target // &#123;a:1, b:2, c:3&#125;//如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。 Object.assign方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。 12345var obj1 = &#123;a: &#123;b: 1&#125;&#125;;var obj2 = Object.assign(&#123;&#125;, obj1);obj1.a.b = 2;obj2.a.b // 2 对于这种嵌套的对象，一旦遇到同名属性，Object.assign的处理方法是替换，而不是添加。 12345678910111213141516171819202122232425262728293031323334353637var target = &#123; a: &#123; b: 'c', d: 'e' &#125; &#125;var source = &#123; a: &#123; b: 'hello' &#125; &#125;Object.assign(target, source)// &#123; a: &#123; b: 'hello' &#125; &#125;``**Object.assign常见用途**&gt;1）为对象添加属性```javascriptclass Point &#123; constructor(x, y) &#123; Object.assign(this, &#123;x, y&#125;); &#125;&#125;``上面方法通过Object.assign方法，将x属性和y属性添加到Point类的对象实例。&gt;2）为对象添加方法```javascriptObject.assign(SomeClass.prototype, &#123; someMethod(arg1, arg2) &#123; ··· &#125;, anotherMethod() &#123; ··· &#125;&#125;);// 等同于下面的写法SomeClass.prototype.someMethod = function (arg1, arg2) &#123; ···&#125;;SomeClass.prototype.anotherMethod = function () &#123; ···&#125;; 3）克隆对象 123function clone(origin) &#123; return Object.assign(&#123;&#125;, origin);&#125; 上面代码将原始对象拷贝到一个空对象，就得到了原始对象的克隆。 不过，采用这种方法克隆，只能克隆原始对象自身的值，不能克隆它继承的值。如果想要保持继承链，可以采用下面的代码。1234function clone(origin) &#123; let originProto = Object.getPrototypeOf(origin); return Object.assign(Object.create(originProto), origin);&#125; 4）合并多个对象 12const merge = (target, ...sources) =&gt; Object.assign(target, ...sources); 如果希望合并后返回一个新对象，可以改写上面函数，对一个空对象合并。12const merge = (...sources) =&gt; Object.assign(&#123;&#125;, ...sources); 属性的遍历 1）for…in for…in循环遍历对象自身的和继承的可枚举属性（不含Symbol属性）。 2）Object.keys(obj) Object.keys返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含Symbol属性）。 3）Object.getOwnPropertyNames(obj) Object.getOwnPropertyNames返回一个数组，包含对象自身的所有属性（不含Symbol属性，但是包括不可枚举属性）。 4）Object.getOwnPropertySymbols(obj) Object.getOwnPropertySymbols返回一个数组，包含对象自身的所有Symbol属性。 5）Reflect.ownKeys(obj) Reflect.ownKeys返回一个数组，包含对象自身的所有属性，不管属性名是Symbol或字符串，也不管是否可枚举。12Reflect.ownKeys(&#123; [Symbol()]:0, b:0, 10:0, 2:0, a:0 &#125;)// ['2', '10', 'b', 'a', Symbol()] Object.keys()，Object.values()，Object.entries() Object.keys方法，返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键名。 Object.values方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值。Object.values只返回对象自身的可遍历属性。Object.values会过滤属性名为 Symbol 值的属性。如果Object.values方法的参数是一个字符串，会返回各个字符组成的一个数组。 Object.entries方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对数组。如果原对象的属性名是一个 Symbol 值，该属性会被忽略。Object.entries的基本用途是遍历对象的属性。另一个用处是，将对象转为真正的Map结构。 123456789101112131415161718192021222324252627282930var obj = &#123; foo: 'bar', baz: 42 &#125;;Object.keys(obj)// [\"foo\", \"baz\"]var obj = &#123; foo: 'bar', baz: 42 &#125;;Object.values(obj)// [\"bar\", 42]var obj = &#123; 100: 'a', 2: 'b', 7: 'c' &#125;;Object.values(obj)// [\"b\", \"c\", \"a\"]var obj = &#123; foo: 'bar', baz: 42 &#125;;Object.entries(obj)// [ [\"foo\", \"bar\"], [\"baz\", 42] ]let &#123;keys, values, entries&#125; = Object;let obj = &#123; a: 1, b: 2, c: 3 &#125;;for (let key of keys(obj)) &#123; console.log(key); // 'a', 'b', 'c'&#125;for (let value of values(obj)) &#123; console.log(value); // 1, 2, 3&#125;for (let [key, value] of entries(obj)) &#123; console.log([key, value]); // ['a', 1], ['b', 2], ['c', 3]&#125; 对象的扩展运算符 扩展运算符（…）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。 123456789101112let z = &#123; a: 3, b: 4 &#125;;let n = &#123; ...z &#125;;n // &#123; a: 3, b: 4 &#125;let aClone = &#123; ...a &#125;;// 等同于let aClone = Object.assign(&#123;&#125;, a);//合并两个对象let ab = &#123; ...a, ...b &#125;;// 等同于let ab = Object.assign(&#123;&#125;, a, b);","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"},{"name":"es6","slug":"es6","permalink":"http://yoursite.com/tags/es6/"}]},{"title":"读书笔记-es6函数的扩展","date":"2017-05-05T08:26:01.000Z","path":"2017/05/05/读书笔记-es6函数的扩展/","text":"函数的扩展一、函数参数的默认值 参数变量是默认声明的，所以不能用let或const再次声明 通常情况下，定义了默认值的参数，应该是函数的尾参数 1234567function log(x, y = 'World') &#123; console.log(x, y);&#125;log('Hello') // Hello Worldlog('Hello', 'China') // Hello Chinalog('Hello', '') // Hello 二、与解构赋值默认值结合使用12345678function foo(&#123;x, y = 5&#125;) &#123; console.log(x, y);&#125;foo(&#123;&#125;) // undefined, 5foo(&#123;x: 1&#125;) // 1, 5foo(&#123;x: 1, y: 2&#125;) // 1, 2foo() // TypeError: Cannot read property 'x' of undefined 三、rest参数 ES6 引入 rest 参数（形式为“…变量名”），用于获取函数的多余参数，这样就不需要使用arguments对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。 rest 参数之后不能再有其他参数（即只能是最后一个参数），否则会报错 12345678910111213141516171819function add(...values) &#123; let sum = 0; for (var val of values) &#123; sum += val; &#125; return sum;&#125;add(2, 5, 3) // 10function push(array, ...items) &#123; items.forEach(function(item) &#123; array.push(item); console.log(item); &#125;);&#125;var a = [];push(a, 1, 2, 3) 四、扩展运算符(…) 它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。扩展运算符内部调用的是数据结构的Iterator接口 123456789101112131415161718console.log(...[1, 2, 3])// 1 2 3console.log(1, ...[2, 3, 4], 5)// 1 2 3 4 5[...document.querySelectorAll('div')]// [&lt;div&gt;, &lt;div&gt;, &lt;div&gt;]function push(array, ...items) &#123; array.push(...items);&#125;function add(x, y) &#123; return x + y;&#125;let numbers = [4, 38];add(...numbers) // 42 栗子： 替代数组的apply方法 12345678// ES5的写法Math.max.apply(null, [14, 3, 77])// ES6的写法Math.max(...[14, 3, 77])// 等同于Math.max(14, 3, 77); 合并数组 12345678910111213141516// ES5[1, 2].concat(more)// ES6[1, 2, ...more]var arr1 = ['a', 'b'];var arr2 = ['c'];var arr3 = ['d', 'e'];// ES5的合并数组arr1.concat(arr2, arr3);// [ 'a', 'b', 'c', 'd', 'e' ]// ES6的合并数组[...arr1, ...arr2, ...arr3]// [ 'a', 'b', 'c', 'd', 'e' ] 与解构赋值结合 1234567891011const [first, ...rest] = [1, 2, 3, 4, 5];first // 1rest // [2, 3, 4, 5]const [first, ...rest] = [];first // undefinedrest // []:const [first, ...rest] = [\"foo\"];first // \"foo\"rest // [] 五、箭头函数 箭头函数可以让this指向固定化，这种特性很有利于封装回调函数 （1）函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。 （2）不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。 （3）不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用Rest参数代替。 （4）不可以使用yield命令，因此箭头函数不能用作Generator函数。123456789101112131415var f = () =&gt; 5;// 等同于var f = function () &#123; return 5 &#125;;var f = v =&gt; v;//等同于：var f = function(v) &#123; return v;&#125;;var sum = (num1, num2) =&gt; num1 + num2;// 等同于var sum = function(num1, num2) &#123; return num1 + num2;&#125;; 箭头函数简化回调函数 1234567// 正常函数写法[1,2,3].map(function (x) &#123; return x * x;&#125;);// 箭头函数写法[1,2,3].map(x =&gt; x * x); 箭头函数可以让setTimeout里面的this，绑定定义时所在的作用域，而不是指向运行时所在的作用域 1234567891011121314151617function Timer() &#123; this.s1 = 0; this.s2 = 0; // 箭头函数 setInterval(() =&gt; this.s1++, 1000); // 普通函数 setInterval(function () &#123; this.s2++; &#125;, 1000);&#125;var timer = new Timer();setTimeout(() =&gt; console.log('s1: ', timer.s1), 3100);setTimeout(() =&gt; console.log('s2: ', timer.s2), 3100);// s1: 3// s2: 0 因为所有的内层函数都是箭头函数，都没有自己的this，它们的this其实都是最外层foo函数的this 123456789101112131415function foo() &#123; return () =&gt; &#123; return () =&gt; &#123; return () =&gt; &#123; console.log('id:', this.id); &#125;; &#125;; &#125;;&#125;var f = foo.call(&#123;id: 1&#125;);var t1 = f.call(&#123;id: 2&#125;)()(); // id: 1var t2 = f().call(&#123;id: 3&#125;)(); // id: 1var t3 = f()().call(&#123;id: 4&#125;); // id: 1","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"},{"name":"es6","slug":"es6","permalink":"http://yoursite.com/tags/es6/"}]},{"title":"读书笔记-es6数组的扩展","date":"2017-05-04T15:22:23.000Z","path":"2017/05/04/读书笔记-es6数组的扩展/","text":"数组的扩展一、Array.from() 将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括ES6新增的数据结构Set和Map） 1234567891011121314151617181920212223//类似数组的对象let arrayLike = &#123; '0': 'a', '1': 'b', '2': 'c', length: 3&#125;;// ES5的写法var arr1 = [].slice.call(arrayLike); // ['a', 'b', 'c']// ES6的写法let arr2 = Array.from(arrayLike); // ['a', 'b', 'c']// NodeList对象let ps = document.querySelectorAll('p');Array.from(ps).forEach(function (p) &#123; console.log(p);&#125;);// arguments对象function foo() &#123; var args = Array.from(arguments); // ...&#125; 扩展运算符（…）也可以将某些数据结构转为数组 二、Array.of() 用于将一组值，转换为数组 123Array.of(3, 11, 8) // [3,11,8]Array.of(3) // [3]Array.of(3).length // 1 三、数组实例的copyWithin() 在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组 target（必需）：从该位置开始替换数据。 start（可选）：从该位置开始读取数据，默认为0。如果为负值，表示倒数。 end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。 123456789[1, 2, 3, 4, 5].copyWithin(0, 3)// [4, 5, 3, 4, 5][1, 2, 3, 4, 5].copyWithin(0, 3, 4)// [4, 2, 3, 4, 5]// -2相当于3号位，-1相当于4号位[1, 2, 3, 4, 5].copyWithin(0, -2, -1)// [4, 2, 3, 4, 5] 四、数组实例的find()和findIndex() find方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。 findIndex返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。 12345678910[1, 4, -5, 10].find((n) =&gt; n &lt; 0)// -5[1, 5, 10, 15].find(function(value, index, arr) &#123; return value &gt; 9;&#125;) // 10[1, 5, 10, 15].findIndex(function(value, index, arr) &#123; return value &gt; 9;&#125;) // 2 五、数组实例的fill() 使用给定值，填充一个数组 123456['a', 'b', 'c'].fill(7)// [7, 7, 7]//从1号位开始，向原数组填充7，到2号位之前结束['a', 'b', 'c'].fill(7, 1, 2)// ['a', 7, 'c'] 六、数组实例的entries()，keys()和values() keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历 1234567891011121314151617for (let index of ['a', 'b'].keys()) &#123; console.log(index);&#125;// 0// 1for (let elem of ['a', 'b'].values()) &#123; console.log(elem);&#125;// 'a'// 'b'for (let [index, elem] of ['a', 'b'].entries()) &#123; console.log(index, elem);&#125;// 0 \"a\"// 1 \"b\" 七、数组实例的includes() 返回一个布尔值，表示某个数组是否包含给定的值，与字符串的includes方法类似,方法的第二个参数表示搜索的起始位置，默认为0 123[1, 2, 3].includes(2); // true[1, 2, 3].includes(4); // false[1, 2, NaN].includes(NaN); // true 八、数组的空位 forEach(), filter(), every() 和some()都会跳过空位 map()会跳过空位，但会保留这个值 join()和toString()会将空位视为undefined，而undefined和null会被处理成空字符串 1234567891011121314151617181920// forEach方法[,'a'].forEach((x,i) =&gt; console.log(i)); // 1// filter方法['a',,'b'].filter(x =&gt; true) // ['a','b']// every方法[,'a'].every(x =&gt; x==='a') // true// some方法[,'a'].some(x =&gt; x !== 'a') // false// map方法[,'a'].map(x =&gt; 1) // [,1]// join方法[,'a',undefined,null].join('#') // \"#a##\"// toString方法[,'a',undefined,null].toString() // \",a,,\" ES6则是明确将空位转为undefined。尽量建议避免出现空位。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"},{"name":"es6","slug":"es6","permalink":"http://yoursite.com/tags/es6/"}]},{"title":"读书笔记-es6数值的扩展","date":"2017-05-03T15:03:20.000Z","path":"2017/05/03/读书笔记-es6数值的扩展/","text":"数值的扩展一、Number.isFinite(), Number.isNaN() Number.isFinite() 检查一个数值是否为有限的（finite） Number.isNaN() 检查一个值是否为NaN 123456789101112131415161718//Number.isFinite()Number.isFinite(15); // trueNumber.isFinite(0.8); // trueNumber.isFinite(NaN); // falseNumber.isFinite(Infinity); // falseNumber.isFinite(-Infinity); // falseNumber.isFinite('foo'); // falseNumber.isFinite('15'); // falseNumber.isFinite(true); // false//Number.isNaN()Number.isNaN(NaN) // trueNumber.isNaN(15) // falseNumber.isNaN('15') // falseNumber.isNaN(true) // falseNumber.isNaN(9/NaN) // trueNumber.isNaN('true'/0) // trueNumber.isNaN('true'/'true') // true 二、Number.parseInt(), Number.parseFloat() 全局方法parseInt()和parseFloat()，移植到Number对象上面，行为完全保持不变。 12Number.parseInt === parseInt // trueNumber.parseFloat === parseFloat // true 三、Number.isInteger() 判断一个值是否为整数 12345Number.isInteger(25) // trueNumber.isInteger(25.0) // trueNumber.isInteger(25.1) // falseNumber.isInteger(\"15\") // falseNumber.isInteger(true) // false 四、安全整数和Number.isSafeInteger() JavaScript能够准确表示的整数范围在-2^53到2^53之间（不含两个端点），超过这个范围，无法精确表示这个值。Number.isSafeInteger() 用来判断一个整数是否落在这个范围之内 五、Math.trunc() 去除一个数的小数部分，返回整数部分 六、Math.sign() 判断一个数到底是正数、负数、还是零 参数为正数，返回+1； 参数为负数，返回-1； 参数为0，返回0； 参数为-0，返回-0; 其他值，返回NaN。 七、Math.signbit() 判断一个数的符号位是否设置了 如果参数是NaN，返回false 如果参数是-0，返回true 如果参数是负值，返回true 其他情况返回false 1234Math.signbit(2) //falseMath.signbit(-2) //trueMath.signbit(0) //falseMath.signbit(-0) //true 八、指数运算符( ** )122 ** 2 // 42 ** 3 // 8","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"},{"name":"es6","slug":"es6","permalink":"http://yoursite.com/tags/es6/"}]},{"title":"DIY一个自己的音乐播放器","date":"2017-04-27T06:47:55.000Z","path":"2017/04/27/’DIY一个自己的音乐播放器/","text":"前言：在最近的一个外包项目中包联盟(PC端)中使用到了video，遇到了好多坑。突发奇想来踩一踩audio的坑😀，果然一入深似海，👇下面将分享我的DIY之路-Vue音乐播放器。注：本项目为开源项目，不能用于商业应用，仅供学习。有问题或建议发我邮箱：hjingren@aliyun.com [温馨提示：pc浏览f12手机模式最佳,手机建议wifi下访问]demo地址： http://hjingren.cn/magic-music项目地址： https://github.com/hzzly/MagicMusic欢迎大家的star啦😄~ 先来个预览： 更多预览：更多 👉老铁们，准备发车(技能点)： vue文档 vue-router文档 vuex文档 不想看文档的可以看看我这篇博客vuex学习实践笔记 axios文档 或者这篇博客 Vuex2 与 Axios 开发(我也是参考这篇，感谢作者😁) es6(阮一峰的es6入门) 可以参考我的es6之路(还在继续,轻喷) webpack2(中文网站) Promise (浅谈Promise) flex (Web的flex弹性盒模型) 移动端屏幕适配的解决 (flexible+rem) 本地存储(sessionStorage、localStorage) 图片懒加载 👉坐好，出发 实现的功能1、首页 [x] 轮播 [x] 个性推荐[流行、古典、轻音乐、流行] [x] 歌曲操作 [x] 加入播放列表 [ ] 喜欢 [ ] 分享 2、底部播放控件 [x] 播放 [x] 暂停 [x] 下一曲 [x] 播放进度条 3、播放页面 [x] 上一曲 [x] 播放 [x] 暂停 [x] 下一曲 [x] 播放进度条[弧形进度条] [x] 歌词滚动 [x] 播放的歌词高亮 [ ] 播放模式[单曲循环、列表循环、随机播放] 4、播放列表 [x] 播放歌曲高亮 [x] 切歌(单击切歌) [x] 删歌(点击右侧小X) [ ] 清空播放列表 [ ] 本地缓存播放列表 5、排行榜 [x] 热门排行榜 [x] 排行榜里的歌曲(单击播放) 6、音乐搜索输入搜索关键词，点击放大镜图标 [x] 单曲(单击或点击歌曲操作(…)添加至音乐播放列表，部分音乐会存在版权问题无法播放) [x] 歌手 [x] 专辑 [x] 歌单 [x] 用户 [x] 本地缓存搜索列表 7、侧边栏 [x] 头像 [x] 菜单 [x] 个人中心 API感谢作者把api整理的这么好(点个赞👍) 网易云音乐 NodeJS 版 API 目录结构123456789101112131415161718192021222324252627282930313233343536|——MagicMusic/| |——build/| |——confg/| |——node_modules/| |——src/| | |——assets/ //静态文件| | |——components/ //公共组件| | |——api/| | | |——index.js //axios封装与api| | |——pages/ //存放项目页面| | | |——classical.vue //古典歌曲页面| | | |——collection.vue //排行榜| | | |——home.vue //首页| | | |——light.vue //轻音乐歌曲页面| | | |——login.vue //登录页面| | | |——popular.vue //流行歌曲页面| | | |——radio.vue //电台歌曲页面| | | |——rank.vue //排行榜列表| | | |——search.vue //搜索页| | | |——user.vue //用户| | |——router/ | | | |——index.js //页面路由| | |——util //公用方法| | |——vuex / //存放vuex代码| | | |——modules / //数据模块| | | |——store.js //vuex主入口| | | |——types.js //vuex的types文件| | |——App.vue //父组件| | |——main.js //入口文件| |——static/| |——.babelrc| |——.editorconfig| |——.gitgnore| |——index.html| |——package.json| |——README.md 开发心得与总结1、轮播图首先感谢作者ShanaMaid/vue-image-scroll开源的代码，我把代码copy下来自己进行了一点修改(没有手指滑动效果)，因为这是移动端，少不了的手指滑动切换，所以添加了vue-touch(偷偷告诉你，vue-touch的next分支还是支持vue2.0的😜)。代码传送门123456789101112131415161718&lt;li v-for=\"(item,index) in image\" :class=\"[move[index]]\"&gt; &lt;v-touch class=\"vuetouch\" v-on:swipeleft=\"nextPic\" v-on:swiperight=\"prePic\"&gt; ... &lt;/v-touch&gt;&lt;/li&gt;methods: &#123; nextPic(event) &#123; let temp = this.move.pop() this.move.unshift(temp) &#125;, prePic(event) &#123; let temp = this.move.shift() this.move.push(temp) &#125;,&#125; 2、歌曲操作(喜欢，分享，加入播放列表)动画、播放列表展开与删除歌曲动画 Vue提供了transition的封装组件，在下列情形中，可以给任何元素和组件添加 entering/leaving 过渡 条件渲染 （使用 v-if） 条件展示 （使用 v-show） 动态组件 组件根节点 1234567891011&lt;transition name=\"move\"&gt; &lt;div class=\"menu\" v-show=\"item.menuShow\"&gt; ... &lt;/div&gt;&lt;/transition&gt;&lt;transition-group name=\"slide\" tag=\"div\" class=\"list-wrapper\"&gt; &lt;div class=\"item\" v-for=\"(item, index) in listenLists\" :key=\"item\"&gt; ... &lt;/div&gt;&lt;/transition-group&gt; transition-group一组过度动画，这里有个小坑的，之前看官网列表过渡的栗子，给每一项设置唯一的key值，一般都会用index。所以在做的时候就把index传给key，结果过渡老是不对，后来换成对应的item就正常了(生无可恋脸)。 3、直线进度条、弧形进度条 西班牙建筑大师曾说过：“直线属于人类，曲线则归于上帝”。在这里我大胆的使用了弧形来作为进度条，(几大热门音乐APP貌似还没有弧形进度条😄)。 这里我用到了Vue的绑定内联样式12345678910111213//直线进度条&lt;div class=\"progress-bar\"&gt; &lt;div class=\"play\" :style=\"&#123;width: (now / duration).toFixed(3)*100 + '%'&#125;\"&gt;&lt;/div&gt;&lt;/div&gt;//弧形进度条//因为用到了弧形，所以我这里用到了`border-radius`来使它变成一个大圆，然后平移`translateX`居中，其它不要的部分`overflow: hidden`。//这里用两个div来表示进度条，一条固定的进度条，一条慢慢增加。&lt;div class=\"process\" @click=\"showToast\"&gt; &lt;div class=\"line\"&gt;&lt;/div&gt; &lt;div class=\"pro\" :style=\"&#123;transform: `translateX($&#123;translateX&#125;) rotate($&#123;deg*1 + 56.5*((now / size).toFixed(3))&#125;deg)`&#125;\"&gt;&lt;/div&gt;&lt;/div&gt; 4、本地存储 将一些数据缓存到localStorage，可以减少Http请求，从而优化页面加载时间。 在这个项目中首页歌曲列表以及搜索历史用到了本地缓存，拿搜索历史来举栗：12345678910111213141516created() &#123; if (!localStorage.searchHistory) &#123; let searchHistory = ['前端', '童话镇', '刚好遇见你'] localStorage.searchHistory = JSON.stringify(searchHistory) &#125; &#125;,methods: &#123; _search(keywords) &#123; //判断搜索列表中是否已存在 let searchHistory = JSON.parse(localStorage.searchHistory) let find = searchHistory.findIndex((val) =&gt; &#123; return val === keywords &#125;) find === -1 ? localStorage.searchHistory = JSON.stringify([keywords, ...searchHistory]) : '' &#125;&#125; 5、图片懒加载使用了vue-lazyload插件用法👉：1$ npm install vue-lazyload 123456789//main.jsimport VueLazyLoad from 'vue-lazyload'import def_lazy_img from '../static/img/loading.gif' //懒加载的默认图片Vue.use(VueLazyLoad,&#123; loading: def_lazy_img&#125;) //使用懒加载组件//在使用img标签的地方使用&lt;img v-lazy=\"item.al.picUrl\" alt=\"\"&gt; 6、歌词滚动与高亮因为api提供的歌词包括时间，如：[03:57.280]原谅我这一生不羁放纵爱自由所以首先要进行字符串切割：12345678910111213141516171819202122232425&lt;div class=\"lyric\"&gt; &lt;div class=\"roll-lyric\" v-html=\"lyrics\" ref=\"lyric\"&gt;&lt;/div&gt;&lt;/div&gt;computed: &#123; lyrics() &#123; let lyrics = '' this.lyricArr = [] if (this.lyric) &#123; let arr = this.lyric.split('\\n') for (let item of arr) &#123; if (item) &#123; let arr2 = item.split(']') this.lyricArr.push(arr2[0].substring(1,3)*60+arr2[0].substring(4)*1) if (arr2) &#123; lyrics += `&lt;p class='lyrichook' style='margin: 10px 0'&gt;$&#123;arr2[1]&#125;&lt;/p&gt;` &#125; &#125; &#125; &#125; else &#123; lyrics = '暂无歌词~' &#125; return lyrics &#125;&#125; 然后在播放的监听事件中与播放的当前做对比：123456789101112131415this.$refs.myAudio.addEventListener('play', () =&gt; &#123; this.pDOM = [...document.querySelectorAll('.lyrichook')] timer = setInterval(() =&gt; &#123; this.now = audioDOM.currentTime this.lyricArr.forEach((item, index) =&gt; &#123; if (parseInt(item) == parseInt(this.now)) &#123; this.pDOM.forEach((p) =&gt; &#123; p.style.color = 'rgba(255,255,255,.8)' //其它歌词清除高亮 &#125;); this.pDOM[index].style.color = '#f12c61' //歌词高亮 this.$refs.lyric.style.transform = `translateY(-$&#123;(index-2)*25&#125;px)` //歌词滚动 &#125; &#125;); &#125;, 1000)&#125;) 到这就ok了😜 7、vuex状态管理推荐官方调试工具 devtools extension 想进一步理解vuex，可以看这篇博客vuex学习实践笔记 之前看到好多人写的vuex，把整个项目的数据放到了一个state里，导致应用的所有状态集中到一个很大的对象。但是，当应用变得很大时，store 对象会变得臃肿不堪。 所以我建议(个人见解，轻喷)：将 store 分割到模块（module）。每个模块拥有自己的 state、mutation、action、getters。这样方便管理与后期的维护。 车已到站✌️。 不知不觉写了这么多，老铁们凑合这看吧😁，觉得还行的可以点个star，你的star是我继续开源创作的动力，谢谢！！！ 项目地址： https://github.com/hzzly/MagicMusic欢迎大家的star啦~","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"},{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"本地存储sessionStorage与localStorage","date":"2017-04-26T15:44:04.000Z","path":"2017/04/26/本地存储sessionStorage与localStorage/","text":"sessionStorage 数据的存储仅特定于某个会话中，也就是说数据只保持到浏览器关闭，当浏览器关闭后重新打开这个页面时， 之前的存储已经被清除。 localStorage 是一个持久化的存储，它并不局限于会话。除非主动删除数据，否则数据是永远不会过期的。 一、localStorage和sessionStorage操作 localStorage和sessionStorage都具有相同的操作方法，例如setItem、getItem和removeItem等 1.setItem存储valuesessionStorage.setItem(“name”, “hzzly”);localStorage.setItem(“blog”, “hzzly.github.io”); 2.getItem获取valuelet name = sessionStorage.getItem(“name”);let blog = localStorage.getItem(“blog”); 3.removeItem删除keysessionStorage.removeItem(“name”);localStorage.removeItem(“blog”); 4.clear清除所有的key/valuesessionStorage.clear();localStorage.clear(); 5.其他操作方法：点操作和[] web Storage不但可以用自身的setItem,getItem等方便存取，也可以像普通对象一样用点(.)操作符，及[]的方式进行数据存储及读取，像如下的代码： 1234567891011localStorage.name = \"hzzly\"; localStorage[\"age\"] = \"21\"; sessionStorage.name = \"hzzly\"; sessionStorage[\"age\"] = \"21\";let name1 = localStorage.namelet age1 = localStorage[\"age\"]let name2 = sessionStorage.namelet age2 = sessionStorage[\"age\"] 6.localStorage和sessionStorage的key和length属性实现遍历 sessionStorage和localStorage提供的key()和length可以方便的实现存储的数据遍历，例如下面的代码： 123456var storage = window.localStorage; for (var i=0, len = storage.length; i &lt; len; i++)&#123; let key = storage.key(i); let value = storage.getItem(key); console.log(key + \"=\" + value); &#125; 二、实例 storage只能存储字符串的数据，对于JS中常用的数组或对象却不能直接存储，可以用下面两个方法进行转换： JSON.stringify() 用于从一个对象解析出字符串 JSON.parse() 用于从一个字符串中解析出json对象 1.localStorage/sessionStorage存取数组1234567//存let language = ['HTML/HTML5', 'CSS/CSS3', 'JavaScript', 'Vue', 'React']localStorage.language = JSON.stringify(language)sessionStorag.language = JSON.stringify(language)//取let storageLanguage = JSON.parse(localStorage.language) 2.localStorage存取对象123456789101112//存let myInfo = &#123; 'name': 'hzzly', 'age': 21, 'school': 'ECUT', 'city': 'NanChang'&#125;localStorage.myInfo = JSON.stringify(myInfo)sessionStorag.myInfo = JSON.stringify(myInfo)//取let storageLanguage = JSON.parse(localStorage.myInfo)","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"读书笔记-es6字符串的扩展","date":"2017-04-22T15:07:23.000Z","path":"2017/04/22/读书笔记-es6字符串的扩展/","text":"字符串的扩展一、字符串的遍历器接口123456for (let codePoint of 'foo') &#123; console.log(codePoint)&#125;// \"f\"// \"o\"// \"o\" 二、at返回字符串给定位置的字符12345//es5'abc'.charAt(0) // \"a\"//es6'abc'.at(0) // \"a\" 三、indexOf(), includes(), startsWith(), endsWith() indexOf() 确定一个字符串是否包含在另一个字符串中(es5) includes() 返回布尔值，表示是否找到了参数字符串。 startsWith() 返回布尔值，表示参数字符串是否在源字符串的头部。 endsWith()返回布尔值，表示参数字符串是否在源字符串的尾部。 12345var s = 'Hello world!';s.startsWith('Hello') // trues.endsWith('!') // trues.includes('o') // true 支持第二个参数，表示开始搜索的位置12345var s = 'Hello world!';s.startsWith('Hello') // trues.endsWith('!') // trues.includes('o') // true 12345var s = 'Hello world!';s.startsWith('world', 6) // trues.endsWith('Hello', 5) // trues.includes('Hello', 6) // false endsWith的行为与其他两个方法有所不同。它针对前n个字符，而其他两个方法针对从第n个位置直到字符串结束。 四、repeat() 返回一个新字符串，表示将原字符串重复n次。 12'x'.repeat(3) // \"xxx\"'hello'.repeat(2) // \"hellohello\" 五、padStart()，padEnd() 字符串补全长度 padStart() 头部补全 padEnd() 尾部补全第一个参数用来指定字符串的最小长度，第二个参数是用来补全的字符串。如果省略第二个参数，默认使用空格补全长度 12345'x'.padStart(5, 'ab') // 'ababx''x'.padStart(4, 'ab') // 'abax''x'.padEnd(5, 'ab') // 'xabab''x'.padEnd(4, 'ab') // 'xaba' 六、模板字符串123// 字符串中嵌入变量let name = \"hzzly\", time = \"today\";`Hello $&#123;name&#125;, how are you $&#123;time&#125;?`","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"},{"name":"es6","slug":"es6","permalink":"http://yoursite.com/tags/es6/"}]},{"title":"读书笔记-es6变量的解构赋值","date":"2017-04-21T14:59:09.000Z","path":"2017/04/21/读书笔记-es6变量的解构赋值/","text":"变量的解构赋值 这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。 一、数组的解构赋值数组的元素是按次序排列的，变量的取值由它的位置决定 12345678let [a, b, c] = [1, 2, 3]a // 1b // 2c // 3let [head, ...tail] = [1, 2, 3, 4]head // 1tail // [2, 3, 4] 默认值 12let [foo = true] = [];foo // true 栗子：12345// 返回一个数组function example() &#123; return [1, 2, 3];&#125;let [a, b, c] = example(); 二、对象的解构赋值对象的属性没有次序，变量必须与属性同名，才能取到正确的值 123let &#123; foo, bar &#125; = &#123; foo: \"aaa\", bar: \"bbb\" &#125;;foo // \"aaa\"bar // \"bbb\" 默认值 123456var &#123;x = 3&#125; = &#123;&#125;;x // 3var &#123;x, y = 5&#125; = &#123;x: 1&#125;;x // 1y // 5 栗子： 将现有对象的方法，赋值到某个变量。 1234567891011//将Math对象的对数、正弦、余弦三个方法，赋值到对应的变量上let &#123; log, sin, cos &#125; = Math // 返回一个对象function example() &#123; return &#123; foo: 1, bar: 2 &#125;;&#125;let &#123; foo, bar &#125; = example(); 提取json数据 12345678910let jsonData = &#123; id: 42, status: \"OK\", data: [867, 5309]&#125;;let &#123; id, status, data: number &#125; = jsonData;console.log(id, status, number);// 42, \"OK\", [867, 5309] 三、字符串的解构赋值123456const [a, b, c, d, e] = 'hzzly'a // \"h\"b // \"z\"c // \"z\"d // \"l\"e // \"y\" 123//length属性let &#123;length : len&#125; = 'hello';len // 5 四、函数参数的解构赋值12345function add([x, y])&#123; return x + y;&#125;add([1, 2]); // 3","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"},{"name":"es6","slug":"es6","permalink":"http://yoursite.com/tags/es6/"}]},{"title":"读书笔记-es6let与const","date":"2017-04-09T14:16:56.000Z","path":"2017/04/09/读书笔记-es6let与const/","text":"let和const 两种新的声明变量的方法 一、let用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。 1.块级作用域 2.不存在变量提升 1234567// var 的情况console.log(foo); // 输出undefinedvar foo = 2;// let 的情况console.log(bar); // 报错ReferenceErrorlet bar = 2; 3.暂时性死区 123456var tmp = 123;if (true) &#123; tmp = 'abc'; // ReferenceError let tmp;&#125; 上面代码中，存在全局变量tmp，但是块级作用域内let又声明了一个局部变量tmp，导致后者绑定这个块级作用域，所以在let声明变量前，对tmp赋值会报错。 4.不允许重复声明 1234567891011// 报错function () &#123; let a = 10; var a = 1;&#125;// 报错function () &#123; let a = 10; let a = 1;&#125; 二、constconst声明一个只读的常量。一旦声明，常量的值就不能改变。const一旦声明变量，就必须立即初始化，不能留到以后赋值。只在声明所在的块级作用域内有效。 const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针，const只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。 12345678const foo = &#123;&#125;;// 为 foo 添加一个属性，可以成功foo.prop = 123;foo.prop // 123// 将 foo 指向另一个对象，就会报错foo = &#123;&#125;; // TypeError: \"foo\" is read-only 上面代码中，常量foo储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把foo指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。 Github地址： https://github.com/hzzly/learn-es6 文章来源hzzly博客技术分享","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"},{"name":"es6","slug":"es6","permalink":"http://yoursite.com/tags/es6/"}]},{"title":"vuex学习实践笔记","date":"2017-04-04T12:11:26.000Z","path":"2017/04/04/vuex学习实践笔记/","text":"Vuex是什么？ Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。 栗如(travel store)：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import * as types from '../types'//数据const state = &#123; travelsList: [], searchKey: &#123; page: 0, limit: 20 &#125;, scroll: true&#125;//用户行为(可以处理异步),触发 mutations 来改变 stateconst actions = &#123; /** * 获取约跑步列表 */ getTravelsList(&#123; commit &#125;) &#123; if(state.scroll) &#123; commit(types.GET_TRAVELS_PAGE_NUM) commit(types.COM_LOADING_STATUS, true), commit(types.GET_TRAVELS_SCORLL_STATUS, false) api.TravelsList() .then(res =&gt; &#123; console.log(res) commit(types.COM_LOADING_STATUS, false), commit(types.GET_TRAVELS_SCORLL_STATUS, true) commit(types.GET_TRAVELS_LIST, res) &#125;) &#125; &#125;, /** * 参加 */ joinTravel(&#123; commit &#125;, id) &#123; ... &#125;&#125;//可以过滤 state 中的数据const getters = &#123; travelsList: state =&gt; state.travelsList, travelListIndex: state =&gt; state.travelsList.slice(0,4)&#125;//唯一能改变 state 的方法(纯函数)const mutations = &#123; [types.GET_TRAVELS_LIST](state, res) &#123; if(state.searchKey.page &lt;= 1) &#123; state.travelsList = res.data &#125; else &#123; state.travelsList = state.travelsList.concat(res.data) &#125; &#125;, [types.GET_TRAVELS_SEARCH_KEY](state, params) &#123; state.searchKey = params &#125;, [types.GET_TRAVELS_PAGE_NUM](state) &#123; state.searchKey['page'] += 1 &#125;, [types.GET_TRAVELS_SCORLL_STATUS](state, status) &#123; state.scroll = status &#125;&#125;//导出一个 travel store 模块export default &#123; state, actions, getters, mutations&#125; 每一个 Vuex 应用的核心就是 store（仓库）。”store” 基本上就是一个容器，它包含着你的应用中大部分的状态(state)数据。 Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。 你不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交(commit) mutations。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。 用一张图来理解一下 客户端(Client) -&gt; action -&gt; mutations -&gt; state -&gt; 客户端 可以看出在vuex中数据是单一流向的：视图(view)触发action，action提交(commit)到mutations，mutations改变state(数据)，state的改变，相应的组件也会相应的更新。 1.State 单一状态树，唯一数据源，能够直接清晰的读懂数据的结构。 1.1在 Vue 组件中获得数据12345678910111213141516//storeconst state = &#123; travelsList: [], searchKey: &#123; page: 0, limit: 20 &#125;, scroll: true&#125;//在view中直接获取data () &#123; return &#123; scroll: this.$store.state.scroll &#125;&#125;, 1.2mapState 辅助函数1234567891011computed: mapState([ // 映射 this.scroll 为 this.$store.state.scroll 'scroll'])//或对象展开运算符computed: &#123; ...mapState(&#123; 'scroll' &#125;)&#125; 2.Getters 对state数据进行过滤或直接返回 2.1在 Vue 组件中获得Getters数据123456789101112//storeconst getters = &#123; travelsList: state =&gt; state.travelsList, travelListIndex: state =&gt; state.travelsList.slice(0,4)&#125;//在view中直接获取data () &#123; return &#123; travelListIndex: this.$store.getters.travelListIndex &#125;&#125;, 2.2mapGetters 辅助函数1234567891011computed: mapGetters([ // 映射 this.travelListIndex 为 this.$store.state.travelListIndex 'travelListIndex'])//或对象展开运算符computed: &#123; ...mapGetters(&#123; 'travelListIndex' &#125;)&#125; 3.Mutations 要更改 Vuex 的 store 中的数据，唯一方法是提交 mutation。每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。这个回调函数就是我们实际进行数据更改的地方。 1234567891011const mutations = &#123; //使用常量替代 Mutation 事件类型 [types.GET_TRAVELS_LIST](state, res) &#123; if(state.searchKey.page &lt;= 1) &#123; state.travelsList = res.data &#125; else &#123; state.travelsList = state.travelsList.concat(res.data) &#125; &#125;, ...&#125; 当我们在这改变数据时，其它引用此state数据的 Vue 组件也会自动得到更新。 4.Actions 用户的一些行为，来提交到mutations改变数据。可在这进行异步操作。 1234567891011121314151617181920const actions = &#123; //es6的参数解构 getTravelsList(&#123; commit &#125;) &#123; if(state.scroll) &#123; commit(types.GET_TRAVELS_PAGE_NUM) commit(types.COM_LOADING_STATUS, true), commit(types.GET_TRAVELS_SCORLL_STATUS, false) api.TravelsList() .then(res =&gt; &#123; console.log(res) commit(types.COM_LOADING_STATUS, false), commit(types.GET_TRAVELS_SCORLL_STATUS, true) commit(types.GET_TRAVELS_LIST, res) &#125;) &#125; &#125;, joinTravel(&#123; commit &#125;, id) &#123; ... &#125;&#125; 4.1分发 Action12345created() &#123; if (this.travelListIndex.length == 0) &#123; this.$store.dispatch('getTravelsList') &#125;&#125;, 4.2mapActions 辅助函数12345methods: &#123; ...mapActions([ 'getTravelsList' // 映射 this.getTravelsList() 为 this.$store.dispatch('getTravelsList') ]),&#125; 5.Modules 当应用变得很大时，store 对象会变得臃肿不堪。为了解决这个问题，Vuex 允许我们将 store 分割到模块（module）。每个模块拥有自己的 state、mutation、action、getters 12345678910111213141516171819202122const moduleA = &#123; state: &#123; ... &#125;, mutations: &#123; ... &#125;, actions: &#123; ... &#125;, getters: &#123; ... &#125;&#125;const moduleB = &#123; state: &#123; ... &#125;, mutations: &#123; ... &#125;, actions: &#123; ... &#125;&#125;const store = new Vuex.Store(&#123; modules: &#123; a: moduleA, b: moduleB &#125;&#125;)store.state.a // -&gt; moduleA 的状态store.state.b // -&gt; moduleB 的状态 6.项目实践进阶vue全家桶","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"},{"name":"vuex","slug":"vuex","permalink":"http://yoursite.com/tags/vuex/"}]},{"title":"读书笔记-es5Array对象","date":"2017-03-30T04:24:01.000Z","path":"2017/03/30/读书笔记-es5Array对象/","text":"1.创建 Array 对象的语法：123new Array();new Array(size);new Array(element0, element1, ..., elementn) 2.属性 属性 描述 constructor 返回对创建此对象的数组函数的引用 length 设置或返回数组中元素的数目 prototype 允许向对象添加属性和方法 3.常用方法 方法 描述 concat() 连接两个或更多的数组，并返回结果 join() 把数组的所有元素放入一个字符串。元素通过指定的分隔符进行分隔 pop() 删除并返回数组的最后一个元素 push() 向数组的末尾添加一个或更多元素，并返回新的长度 reverse() 颠倒数组中元素的顺序 shift() 删除并返回数组的第一个元素 unshift() 向数组的开头添加一个或更多元素，并返回新的长度 slice() 从某个已有的数组返回选定的元素 sort() 对数组的元素进行排序 splice() 删除元素，并向数组添加新元素 valueOf() 返回某个字符串对象的原始值 4.栗子12345678910111213141516171819202122//concat()let a = [1,2,3]a.concat(4,5) //[1,2,3,4,5]//join()let a = [1,2,3]a.join() //1,2,3//slice()let a = [1,2,3]a.slice(1) //[2,3]let a = [1,2,3]a.slice(1,2) //[2]//splice()let a = [1,2,3,4,5]a.splice(1,1) //[2]let a = [1,2,3,4,5]a.splice(1,1,'hzzly') //[2]a //[1, \"hzzly\", 3, 4, 5]","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"},{"name":"es5","slug":"es5","permalink":"http://yoursite.com/tags/es5/"}]},{"title":"读书笔记-es5String对象","date":"2017-03-29T05:48:14.000Z","path":"2017/03/29/读书笔记-es5String对象/","text":"1.创建 String 对象的语法：12new String(s);String(s); 2.属性 属性 描述 constructor 对创建该对象的函数的引用 length 字符串的长度 prototype 允许向对象添加属性和方法 3.常用方法 方法 描述 charAt() 返回在指定位置的字符 concat() 连接字符串 indexOf() 检索字符串 lastIndexOf() 从后向前搜索字符串 match() 找到一个或多个正则表达式的匹配 slice() 提取字符串的片断，并在新的字符串中返回被提取的部分 split() 把字符串分割为字符串数组 toLowerCase() 把字符串转换为小写 toUpperCase() 把字符串转换为大写 toString() 返回字符串 valueOf() 返回某个字符串对象的原始值 4.栗子123456789101112131415161718192021222324//charAt()let str=\"Hello world!\"str.charAt(1) //e//concat()let str1=\"Hello \"let str2=\"world!\"str1.concat(str2) //Hello world!//indexOf()let str=\"Hello world!\"str.indexOf(\"Hello\") //0str.indexOf(\"World\") //-1 (没有就返回-1)str.indexOf(\"world\") //6//slice()let str=\"Hello happy world!\"str.slice(6) //happy world!//split()let str=\"How are you doing today?\"str.split(\" \") //[\"How\", \"are\", \"you\", \"doing\", \"today?\"]str.split(\"\") //[\"H\", \"o\", \"w\", \" \", \"a\", \"r\", \"e\", \" \", \"y\", \"o\", \"u\", \" \", \"d\", \"o\", \"i\", \"n\", \"g\", \" \", \"t\", \"o\", \"d\", \"a\", \"y\", \"?\"]str.split(\" \",3) //[\"How\", \"are\", \"you\"]","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"},{"name":"es5","slug":"es5","permalink":"http://yoursite.com/tags/es5/"}]},{"title":"Express与MongoDB的缠绵","date":"2017-03-25T11:00:36.000Z","path":"2017/03/25/Express与MongoDB的缠绵/","text":"前奏Express 是什么？ Express 是一个基于 Node.js 平台的极简、灵活的 web 应用开发框架，它提供一系列强大的特性，帮助你创建各种 Web 和移动设备应用。 全局安装express脚手架1$ npm install express-generator -g 创建express项目1234$ express myapp$ cd myapp$ npm install$ DEBUG=myapp npm start MongoDB与Mongoose？ MongoDB是一个对象数据库，是用来存储数据的；存储的数据格式为JSON。 Mongoose是封装了MongoDB操作(增删改查等)的一个对象模型库,是用来操作这些数据的。 安装MongoDB：https://www.mongodb.com/download-center?jmp=nav 安装Mongoose：1$ npm install mongoose --save 一、连接MongoDB 在项目根目录下新建/lib/mongo.js 12345var mongoose = require(\"mongoose\");var db = mongoose.connect('mongodb://localhost:27017/myblog');module.exports = db 要连接的数据库为myblog 二、Schema 一种以文件形式存储的数据库模型骨架，无法直接通往数据库端，不具备对数据库的操作能力，仅仅只是数据库模型在程序片段中的一种表现，可以说是数据属性模型(传统意义的表结构)，又或着是“集合”的模型骨架 新建一个用户Schema 在项目根目录下新建/models/users.js 12345678910111213141516var mongoose = require(\"mongoose\");var db = require('../lib/mongo');//一个用户模型var UserSchema = new mongoose.Schema(&#123; username : &#123; type:String &#125;, password : &#123;type: String&#125;, avatar : &#123;type: String&#125;, age : &#123; type:Number, default:0 &#125;, description : &#123; type: String&#125;, email : &#123; type: String &#125;, github : &#123; type: String &#125;, time : &#123; type:Date, default:Date.now &#125;&#125;);//创建Modelvar UserModel = db.model(\"user\", UserSchema );module.exports = UserModel user：数据库中的集合名称,当我们对其添加数据时如果user已经存在，则会保存到其目录下，如果不存在，则会创建user集合，然后在保存数据。 拥有了Model，我们也就拥有了操作数据库的金钥匙，就可以使用Model来进行增删改查的具体操作。 Entity Entity–由Model创建的实体，使用save方法保存数据，Model和Entity都有能影响数据库的操作，但Model比Entity更具操作性。所以此项目主要用的Model。 12345678910111213var UserEntity = new UserModel(&#123; name : \"hzzly\", age : 21, email: \"hjingren@aliyun.com\", github: 'https://github.com/hzzly'&#125;);UserEntity.save(function(error,doc)&#123; if(error)&#123; console.log(\"error :\" + error); &#125;else&#123; console.log(doc); &#125;&#125;); 三、封装数据库的CURD 在lib文件下新建api.js 采用Promise封装对数据库的操作，避免回调地狱，使得代码能够更好的被读懂和维护。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980var UserModel = require('../models/users');module.exports = &#123; /** * 添加数据 * @param &#123;[type]&#125; data 需要保存的数据对象 */ save(data) &#123; return new Promise((resolve, reject) =&gt; &#123; //model.create(保存的对象,callback) UserModel.create(data, (error, doc) =&gt; &#123; if(error)&#123; reject(error) &#125;else&#123; resolve(doc) &#125; &#125;) &#125;) &#125;, find(data=&#123;&#125;, fields=null, options=&#123;&#125;) &#123; return new Promise((resolve, reject) =&gt; &#123; //model.find(需要查找的对象(如果为空，则查找到所有数据), 属性过滤对象[可选参数], options[可选参数], callback) UserModel.find(data, fields, options, (error, doc) =&gt; &#123; if(error)&#123; reject(error) &#125;else&#123; resolve(doc) &#125; &#125;) &#125;) &#125;, findOne(data) &#123; return new Promise((resolve, reject) =&gt; &#123; //model.findOne(需要查找的对象,callback) UserModel.findOne(data, (error, doc) =&gt; &#123; if(error)&#123; reject(error) &#125;else&#123; resolve(doc) &#125; &#125;) &#125;) &#125;, findById(data) &#123; return new Promise((resolve, reject) =&gt; &#123; //model.findById(需要查找的id对象 ,callback) UserModel.findById(data, (error, doc) =&gt; &#123; if(error)&#123; reject(error) &#125;else&#123; resolve(doc) &#125; &#125;) &#125;) &#125;, update(conditions, update) &#123; return new Promise((resolve, reject) =&gt; &#123; //model.update(查询条件,更新对象,callback) UserModel.update(conditions, update, (error, doc) =&gt; &#123; if(error)&#123; reject(error) &#125;else&#123; resolve(doc) &#125; &#125;) &#125;) &#125;, remove(conditions) &#123; return new Promise((resolve, reject) =&gt; &#123; //model.update(查询条件,callback) UserModel.remove(conditions, (error, doc) =&gt; &#123; if(error)&#123; reject(error) &#125;else&#123; resolve(doc) &#125; &#125;) &#125;) &#125;&#125; 四、使用 在/routers/index.js中使用 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950var api = require('../lib/api');router.post('/login', function(req, res, next) &#123; var user = &#123; username : req.body.username, password: req.body.password &#125;; api.findOne(user) .then(result =&gt; &#123; console.log(result) &#125;)&#125;)router.post('/sign_up', function(req, res, next) &#123; var user = &#123; username : req.body.username, password: req.body.password, email: req.body.email &#125;; api.save(user) .then(result =&gt; &#123; console.log(result) &#125;)&#125;)router.get('/user_list', function(req, res, next) &#123; //返回所有用户 api.find(&#123;&#125;) .then(result =&gt; &#123; console.log(result) &#125;) //返回只包含一个键值name、age的所有记录 api.find(&#123;&#125;,&#123;name:1, age:1, _id:0&#125;) .then(result =&gt; &#123; console.log(result) &#125;) //返回所有age大于18的数据 api.find(&#123;\"age\":&#123;\"$gt\":18&#125;&#125;) .then(result =&gt; &#123; console.log(result) &#125;) //返回20条数据 api.find(&#123;&#125;,null,&#123;limit:20&#125;) .then(result =&gt; &#123; console.log(result) &#125;) //查询所有数据，并按照age降序顺序返回数据 api.find(&#123;&#125;,null,&#123;sort:&#123;age:-1&#125;&#125;) //1是升序，-1是降序 .then(result =&gt; &#123; console.log(result) &#125;)&#125;) 项目Github地址： https://github.com/hzzly/express-mongodb如果对你有帮助，欢迎star 文章来源hzzly博客技术分享","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"浅谈Promise","date":"2017-03-25T07:29:12.000Z","path":"2017/03/25/浅谈Promise/","text":"接触过promise的的都知道它的应用场景和用途，Promise可以用来避免异步操作函数里的嵌套回调（callback hell）问题，因为解决异步最直接的方法是回调嵌套，将后一个的操作放在前一个操作的异步回调里，但如果操作多了，就会有很多层的嵌套(回调地狱)。 12345678910$.ajax(url1, function(data1)&#123; // do something... $.ajax(url2, function(data2)&#123; // do something... $.ajax(url3, function(data3)&#123; // do something... done(data3); // 返回数据 &#125;) &#125;);&#125;); Promise学术点的描述： promise代表一个异步操作的执行返回状态，这个执行返回状态在promise对象创建时未必已知。它允许你为异步操作的成功或失败指定处理方法。 这使得异步方法可以像同步方法那样返回值：异步方法会返回一个包含了原返回状态的 promise 对象来替代原返回状态。 Promise的表现如果使用回调方法处理多个操作的异步场景，判断某个操作成功或失败的控制在于声明的匿名函数里面，使用Promise对象则可以重新定义异步执行的状态和控制逻辑。 promises的最重要的特点就是它把我们处理任何函数调用的成功或者失败的方式规范成了可预测的形式，特别是如果这个调用实际上的异步的。 Promise中有几个状态： pending: 初始状态。 非 fulfilled 或 rejected。 resolved: 成功的操作。也有的成为fulfilled 。 rejected: 失败的操作。 状态转换关系为： pending-&gt;resolved(fulfilled)，pending-&gt;rejected。 用法说了这么多，直接上代码。 123456789101112131415var promise = new Promise((resolve, reject) =&gt; &#123; // do somthing, maybe async if (success)&#123; return resolve(res); &#125; else &#123; return reject(err); &#125;&#125;); promise.then(res =&gt; &#123; // do something... e.g console.log(res);&#125;, err =&gt; &#123; // deal the err.&#125;) 或封装成方法1234567891011121314151617function fetch(data) &#123; return new Promise((resolve, reject) =&gt; &#123; // do somthing, maybe async if (success)&#123; resolve(res); &#125; else &#123; reject(err); &#125; &#125;)&#125;fetch(data) .then(res =&gt; &#123; console.log(res) &#125;, err =&gt; &#123; // deal the err. &#125;) 异步嵌套回调123456789101112131415161718192021222324252627function loadAsync1()&#123; return new Promise((resolve, reject) =&gt; &#123; //异步操作 setTimeout(() =&gt; &#123; console.log('异步任务1'); resolve('异步任务1传过来的值'); &#125;, 2000); &#125;); &#125;function loadAsync2(data1)&#123; return new Promise((resolve, reject) =&gt; &#123; //异步操作 setTimeout(() =&gt; &#123; console.log('异步任务2'); resolve('异步任务2传过来的值'); &#125;, 2000); &#125;); &#125;function loadAsync3(data2)&#123; return new Promise((resolve, reject) =&gt; &#123; //异步操作 setTimeout(() =&gt; &#123; console.log('异步任务3'); resolve('异步任务3传过来的值'); &#125;, 2000); &#125;); &#125; 有返回值12345678loadAsync1() .then(data1 =&gt; &#123; return loadAsync2(data1) &#125;) .then(data2 =&gt; &#123; return loadAsync3(data2) &#125;) .then(okFn, failFn) 没有返回值12345678loadAsync1() .then(data1 =&gt; &#123; loadAsync2(data1) &#125;) .then(data2 =&gt;&#123; loadAsync3(data2) &#125;) .then(res =&gt; console.log(res)) 输出的值为： 异步任务1异步任务1传过来的值异步任务2异步任务2传过来的值异步任务3异步任务3传过来的值 promise.all方法 Promise.all 可以接收一个元素为 Promise 对象的数组作为参数，当这个数组里面所有的 Promise 对象都变为 resolve 时，该方法才会返回。 12345678910111213141516var p1 = new Promise((resolve) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(\"第一个promise\"); &#125;, 3000);&#125;);var p2 = new Promise((resolve) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(\"第二个promise\"); &#125;, 1000);&#125;);Promise.all([p1, p2]) .then((result) =&gt; &#123; console.log(result); // [\"第一个promise\", \"第二个promise\"] &#125;); 上面的代码中，all接收一个数组作为参数，p1,p2是并行执行的，等两个都执行完了，才会进入到then，all会把所有的结果放到一个数组中返回，所以我们打印出我们的结果为一个数组。 值得注意的是，虽然p2的执行顺序比p1快，但是all会按照参数里面的数组顺序来返回结果。all的使用场景类似于，玩游戏的时候，需要提前将游戏需要的资源提前准备好，才进行页面的初始化。 之后会有express操作mongondb的基于Promise的封装，敬请期待！","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"移动端touch事件","date":"2017-03-22T14:08:21.000Z","path":"2017/03/22/移动端touch事件/","text":"4个touch事件touchstart 事件：当手指触摸屏幕时候触发，即使已经有一个手指放在屏幕上也会触发。touchmove 事件：当手指在屏幕上滑动的时候连续地触发。调用preventDefault()事件可以阻止滚动。touchend 事件：当手指从屏幕上离开的时候触发。touchcancel 事件：触摸结束的时候触发 触摸事件：touches：当前位于屏幕上的所有手指的列表。targetTouches：位于当前DOM元素上手指的列表。changedTouches：涉及当前事件手指的列表。 Touch对象属性每个Touch对象包含的属性如下： clientX：触摸目标在视口中的x坐标。clientY：触摸目标在视口中的y坐标。identifier：标识触摸的唯一ID。pageX：触摸目标在页面中的x坐标。pageY：触摸目标在页面中的y坐标。screenX：触摸目标在屏幕中的x坐标。screenY：触摸目标在屏幕中的y坐标。target：触摸的DOM节点目标。 12345678910111213141516171819document.addEventListener('touchstart',touch,false);document.addEventListener('touchmove',touch,false);document.addEventListener('touchend',touch,false); function touch (event)&#123; var event = event || window.event; var oInp = document.getElementById(\"inp\"); switch(event.type)&#123; case \"touchstart\": oInp.innerHTML =`Touch started ( $&#123;event.touches[0].clientX&#125; , $&#123;event.touches[0].clientY&#125; )`; break; case \"touchend\": oInp.innerHTML =`&lt;br&gt;Touch end ( $&#123;event.changedTouches[0].clientX&#125; , $&#123;event.changedTouches[0].clientY&#125; )`; break; case \"touchmove\": event.preventDefault(); oInp.innerHTML =`&lt;br&gt;Touch moved ( $&#123;event.touches[0].clientX&#125; , $&#123;event.touches[0].clientY&#125; )`; break; &#125;&#125; 事件(包括鼠标事件)发生的顺序如下：(1) touchstart(2) mouseover(3) mousemove(一次)(4) mousedown(5) mouseup(6) click(7) touchend","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"一个Vue+Canvas的酷炫后台管理","date":"2017-03-21T09:10:38.000Z","path":"2017/03/21/一个Vue-Canvas的酷炫后台管理/","text":"又一个Vue+Cnavas酷炫的后台管理，依然前后端分离（用PC打开，还没适配移动端）。 项目地址： https://github.com/hzzly/canvas-vuedemo地址： http://hjingren.cn/curriculum-design/账号：hzzly 密码：123456欢迎大家的star啦~ 技术栈前台: &gt; 1. vue-cli &gt; 2. vue &gt; 3. vue-router &gt; 4. webpak &gt; 5. canvas &gt; 6. ajax 后台: &gt; 1. wamp &gt; 2. PHP(ThinkPHP) &gt; 3. mysql 功能说明 登录 用户登录 管理员登录 注册 用户注册 Canvas 流星滑过 星星闪闪 后台折线 折线跟着鼠标滑动 Vue 弹出框组件 路由切换动画 通过Ajax调用后台接口 留言板(时间轴) 添加房屋信息 出租 求租 出售 求购 个人信息修改 密码修改 …… 1.登录注册模块 2.后台管理页面 3.留言板(时间轴特效) 目录结构12345678910111213141516171819202122232425|——canvas-vue/| |——build/| |——confg/| |——node_modules/| |——src/| | |——assets/ //静态文件| | |——components/ //页面组件| | | |——Menu.vue //登录注册加载页面| | | |——Home.vue //后台首页| | | |——Login.vue //登录页面| | | |——Regist.vue //注册页面| | | |——Navbar.vue //我的发布| | | |——Messageboard.vue //留言板页面| | | |——... //等等| | |——router/ | | | |——index.js //页面路由| | |——App.vue //父组件| | |——main.js //入口文件| |——static/ | |——.babelrc| |——.editorconfig| |——.gitgnore| |——index.html| |——package.json| |——README.md 技术点 登录注册切换动画–vue的transition转换动画 123456789101112131415&lt;template&gt; &lt;transition name=&quot;fade-out&quot;&gt; ... &lt;/transition&gt;&lt;/template&gt;&lt;style&gt;.fade-out-enter-active, .fade-out-leave-active &#123; transition: all .5s&#125;.fade-out-enter, .fade-out-leave-active &#123; opacity: 0; transform: translateX(-400px);&#125;&lt;/style&gt; 登录注册星星与流星–canvas 123456789101112131415161718192021222324252627282930313233343536373839404142let canvas = document.getElementById('canvas'), ctx = canvas.getContext('2d'), width = window.innerWidth, height = window.innerHeight, //实例化月亮和星星。流星是随机时间生成，所以只初始化数组 moon = new Moon(ctx, width, height), stars = new Stars(ctx, width, height, 200), meteors = [], count = 0 canvas.width = width; canvas.height = height;const meteorGenerator = ()=&gt; &#123; //x位置偏移，以免经过月亮 let x = Math.random() * width + 800 meteors.push(new Meteor(ctx, x, height)) //每隔随机时间，生成新流星 setTimeout(()=&gt; &#123; meteorGenerator() &#125;, Math.random() * 2000)&#125;const frame = ()=&gt;&#123; count++ count % 10 == 0 &amp;&amp; stars.blink() moon.draw() stars.draw() meteors.forEach((meteor, index, arr)=&gt; &#123; //如果流星离开视野之内，销毁流星实例，回收内存 if (meteor.flow()) &#123; meteor.draw() &#125; else &#123; arr.splice(index, 1) &#125; &#125;) requestAnimationFrame(frame)&#125;meteorGenerator()frame() 总结这个项目还没有完成，后期将不定期更新，敬请期待。。 如果觉得还行，欢迎star项目地址： https://github.com/hzzly/canvas-vue项目后台(PHP)地址： https://github.com/hzzly/canvas-vue-backstage 好了，溜了溜了。。。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"移动端屏幕适配的解决","date":"2017-03-15T14:01:18.000Z","path":"2017/03/15/移动端屏幕适配的解决/","text":"随着手机硬件配置的飞速增长、屏幕尺寸的越来越大和网络带宽的逐渐提升，越来越多的PC业务和服务在向移动端转移。然而在这移动端的时代，为了处理各终端屏幕的适配，是否乱了手脚呢？ 虽然移动端的页面与PC的页面相比简单了不少，但让我们头痛的事情还是要想尽办法让页面能适配众多不同的终端设备。在前几个外包项目中，我做的主要都是移动微信端的。期间也遇到了不同屏幕大小的适配问题，所以今天特来分享一下我的解决方法。 项目地址： https://github.com/hzzly/xyy-vuedemo地址： http://hjingren.cn/xyy-vue/欢迎大家的star啦~ 一、meta标签 meta之viewport，其主要用来告诉浏览器如何规范的渲染Web页面，而你则需要告诉它视窗有多大。在开发移动端页面，我们需要在html中设置meta标签如下： 1&lt;meta name=\"viewport\" content=\"width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0\"&gt; 二、手淘的flexible flexible是一个制作H5适配的开源库，需要在html中引入，可以直接使用阿里CDN： 1&lt;script src=\"http://g.tbcdn.cn/mtb/lib-flexible/0.3.4/??flexible_css.js,flexible.js\"&gt;&lt;/script&gt; 执行这个JS后，会在元素上增加一个data-dpr属性，以及一个font-size样式。JS会根据不同的设备添加不同的data-dpr值，比如说1、2或者3，同时会给html加上对应的font-size的值，比如说37.5px。 三、放弃px拥抱rem 用px写的是绝对单位，这种方法肯定不行。让我们来拥抱rem吧！！！ 我们知道 em 的计算是基于父级元素的，在实际使用中给我们的计算带来了很大的不便。所以 rem 的出现解救了我这样不会算术的人，再也不用担心父级元素的 font-size 了，因为它始终是基于根元素（html） 的。比如默认的 html font-size=16px，那么我想设置12px 的文字就是：12÷16=0.75（rem） 如果对rem还有不懂的可以先看看这个CSS3的REM设置字体大小 刚刚我们引入了手淘的flexible，并给html加了font-size，如此一来，页面中的元素，都可以通过rem单位来设置。他们会根据html元素的font-size值做相应的计算，从而实现屏幕的适配效果。 四、CSS处理器(SASS) 使用Sass的同学，可以使用Sass的函数、混合宏这些功能来实现： 123@function px2rem($px, $base-font-size: 75px) &#123; @return ($px / $base-font-size) * 1rem;&#125; 这里的这个参数$base-font-size: 75px，可以通过(psd文件的宽度/10)来计算。假如psd宽750，则$base-font-size为75px。 使用： psd中量多少就写多少 12345//比如量取box宽为190，高为190，则代码：.box &#123; width: px2rem(190px); height: px2rem(190px);&#125; 没用过的可以用sublime的cssrem的插件实现。 五、图示 六、图示代码 因为这是商业代码，所以就只贴了一部分代码，忘见谅，谢谢最下面有我开源项目的代码，可以参考，如果对你有帮助的话，给个star。 123456789101112131415161718192021222324252627//index.html&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0\"&gt; &lt;title&gt;Demo&lt;/title&gt; &lt;script src=\"http://g.tbcdn.cn/mtb/lib-flexible/0.3.4/??flexible_css.js,flexible.js\"&gt;&lt;/script&gt; &lt;link rel=\"stylesheet\" href=\"index.css\"&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"home\"&gt; &lt;div class=\"home-list\"&gt; &lt;div class=\"list-item\"&gt; &lt;a href=\"/\"&gt; &lt;div class=\"item-l\"&gt; &lt;img src=\"../assets/images/check.png\" alt=\"\"&gt; &lt;span&gt;待审核&lt;/span&gt; &lt;/div&gt; &lt;div class=\"item-r isnew\"&gt;6&lt;/div&gt; &lt;/a&gt; &lt;/div&gt; ... &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041//index.scss@function px2rem($px, $base-font-size: 75px) &#123; @return ($px / $base-font-size) * 1rem;&#125;.home-list &#123; padding-bottom: px2rem(45px); .list-item &#123; box-sizing: border-box; width: px2rem(690px); height: px2rem(190px); line-height: px2rem(190px); margin: px2rem(45px) auto 0; padding: 0 px2rem(50px) 0 px2rem(30px); background: #fff; border-radius: px2rem(20px); a &#123; display: flex; justify-content: space-between; font-size: px2rem(40px); img &#123; width: px2rem(90px); height: px2rem(65px); vertical-align: middle; margin-right: px2rem(30px); &#125; span &#123; color: #000; vertical-align: middle; &#125; .item-r &#123; color: #666666; &amp;.isnew &#123; color: #ff5500; &#125; &#125; &amp;:link,&amp;:visited,&amp;:hover,&amp;:active &#123; text-decoration: none; &#125; &#125; &#125;&#125; 七、开源示例如果觉得还行，欢迎star项目地址： https://github.com/hzzly/xyy-vue 好了，溜了溜了。。。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"移动端1px的解决方法","date":"2017-03-13T13:22:43.000Z","path":"2017/03/13/移动端1px的解决方法/","text":"在上个项目中，移动端1px问题被困扰了好久，设置1px边框，实际显示2px。以下是我在项目中的解决方法，才疏学浅，轻喷。 关于什么是移动端1像素边框问题，先上两张图，大家就明白了。 假的1px: 真的1px: 原来Retine屏的分辨率始终是普通屏幕的2倍，1px的边框在devicePixelRatio=2的retina屏下会显示成2px。 解决方案 transform: scaleY() 12345678910111213141516171819202122232425262728293031323334&lt;div class=&quot;border-1px&quot;&gt;&lt;/div&gt;&lt;style type=&quot;text/scss&quot;&gt;.border-1px &#123; position: relative; &amp;:after&#123; display: block; position: absolute; left: 0; bottom: 0; width: 100%; border-top: 1px solid #000; content: &apos;&apos;; &#125;&#125;@media (-webkit-min-device-pixel-ratio: 1.5),(min-device-pixel-ratio: 1.5) &#123; .border-1px&#123; &amp;::after&#123; -webkit-transform: scaleY(0.7); transform: scaleY(0.7); &#125; &#125;&#125;@media (-webkit-min-device-pixel-ratio: 2),(min-device-pixel-ratio: 2) &#123; .border-1px&#123; &amp;::after&#123; -webkit-transform: scaleY(0.5); transform: scaleY(0.5); &#125; &#125;&#125;&lt;/style&gt; 到这已经成功解决了1px问题。 好了，吃饭去喽，溜了溜了。。。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"axios在vue中的简单配置与使用","date":"2017-03-12T13:34:08.000Z","path":"2017/03/12/axios在vue中的简单配置与使用/","text":"尤雨溪之前在微博发布消息，不再继续维护vue-resource，并推荐大家开始使用 axios 。 一、axios 简介axios 是一个基于Promise 用于浏览器和 nodejs 的 HTTP 客户端，它本身具有以下特征： 从浏览器中创建 XMLHttpRequest 从 node.js 发出 http 请求 支持 Promise API 拦截请求和响应 转换请求和响应数据 取消请求 自动转换JSON数据 客户端支持防止 CSRF/XSRF 二、引入方式：npm:123$ npm install axios//淘宝源$ cnpm install axios bower:1$ bower install axios cdn:1&lt;script src=\"https://unpkg.com/axios/dist/axios.min.js\"&gt;&lt;/script&gt; 三、vue中axios的配置 之前那个开源项目一开始就打算用axios，在网上找了好多文章与攻略，发现好多都不太详细，所以打算自己动手配置一个，(不要怂，撸起袖子就是干)。 我的配置：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import axios from 'axios'import qs from 'qs'import * as _ from '../util/tool'axios.defaults.timeout = 5000; //响应时间axios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded;charset=UTF-8'; //配置请求头axios.defaults.baseURL = '你的接口地址'; //配置接口地址//POST传参序列化(添加请求拦截器)axios.interceptors.request.use((config) =&gt; &#123; //在发送请求之前做某件事 if(config.method === 'post')&#123; config.data = qs.stringify(config.data); &#125; return config;&#125;,(error) =&gt;&#123; _.toast(\"错误的传参\", 'fail'); return Promise.reject(error);&#125;);//返回状态判断(添加响应拦截器)axios.interceptors.response.use((res) =&gt;&#123; //对响应数据做些事 if(!res.data.success)&#123; // _.toast(res.data.msg); return Promise.reject(res); &#125; return res;&#125;, (error) =&gt; &#123; _.toast(\"网络异常\", 'fail'); return Promise.reject(error);&#125;);//返回一个Promise(发送post请求)export function fetch(url, params) &#123; return new Promise((resolve, reject) =&gt; &#123; axios.post(url, params) .then(response =&gt; &#123; resolve(response.data); &#125;, err =&gt; &#123; reject(err); &#125;) .catch((error) =&gt; &#123; reject(error) &#125;) &#125;)&#125; 四、vue中使用配置好的axios123456789101112131415161718192021export default &#123; /** * 用户登录 */ Login(params) &#123; return fetch('/users/api/userLogin', params) &#125;, /** * 用户注册 */ Regist(params) &#123; return fetch('/users/api/userRegist', params) &#125;, /** * 发送注册验证码 */ RegistVerifiCode(tellphone) &#123; return fetch('/users/api/registVerifiCode', &#123;tellphone: tellphone&#125;) &#125;, ......&#125; 如果觉得还行，欢迎star项目地址： https://github.com/hzzly/xyy-vuedemo地址： http://hjingren.cn/xyy-vue/ 好了，溜了溜了。。。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"开源的收获","date":"2017-03-09T15:57:05.000Z","path":"2017/03/09/开源的收获/","text":"第一次在github上发布了开源《Qu约》后，不到两天，被人star了137次，fork了25次，这个成绩大大出乎了我自己的意料！ Github地址： https://github.com/hzzly/xyy-vuedemo地址： http://hjingren.cn/xyy-vue/欢迎大家的star啦~ 同时也让我收获到了许多： github首次破百 掘金的阅读量与喜欢量同时给他人带来了不一样的价值 segmentfault的阅读量、收藏量与声望值，把其中的价值传给他人 收获了一个offer 给我以后就业增加了一份保证 结交了好多同行开发者 分享与开源，让技术生生不息。借用一本书de名字，Just for fun。开源是一种情怀，happy hacking！ 革命尚未成功，我们还需努力。。。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"进阶vue全家桶","date":"2017-03-08T01:47:54.000Z","path":"2017/03/08/进阶vue全家桶/","text":"有人说只会vue不会vuex还只是个切图仔，所以本项目将带领你进阶vue全家桶。前端结合Vue2.0全家桶(vue+vue-router+vuex+axios+es6+sass)以及后端Node,一个前后端分离的练手项目。本项目可以作为一个前端vue进阶项目，从前端flex布局到前端vue以及组件分离的使用，再到后端Node以及Leancloud的结合，是一个打通前后端流程的一个项目。欢迎大家前来star。如果有任何问题，可以给我留言，我们互相学习讨论，一起进步。注：本项目为开源项目，非本人同意不能用于商业应用。 项目地址： https://github.com/hzzly/xyy-vuedemo地址： http://hjingren.cn/xyy-vue/欢迎大家的star啦~ 功能说明 首页轮播图 首页热门活动 约跑步活动列表 约出行活动列表 个人中心 查看个人活动 学生认证(待开发) 学生信息修改 消息通知(后台接口待开发) 选择高校(待开发) 登录 注册 活动详情 活动报名 活动发布 时间选择组件 地址选择组件 文件上传 axios的封装 …… 公共组件 弹出文字组件 弹出框组件 loading组件 toast组件 时间选择器组件 地址选择器组件 …… 目录结构 123456789101112131415161718192021222324252627282930313233343536373839|——xyy-vue/| |——build/| |——confg/| |——node_modules/| |——src/| | |——assets/ //静态文件| | |——components/ //公共组件| | |——fetch/| | | |——api.js //axios封装与api| | |——pages/ //存放项目页面| | | |——Detail.vue //活动详情页面| | | |——Home.vue //首页| | | |——Login.vue //登录页面| | | |——Navbar.vue //我的发布| | | |——NotFound.vue //出错页面| | | |——Post.vue //发布活动页面| | | |——Regist.vue //注册页面| | | |——Set.vue //设置页面| | | |——Sport.vue //约跑步活动列表页面| | | |——Travel.vue //约出行活动列表页面| | | |——User.vue //个人中心页面| | | |——UserInfo.vue //个人详情页面| | | |——UserMsg.vue //消息列表页面| | |——router/ | | | |——index.js //页面路由| | |——util //公用方法| | |——vuex / //存放vuex代码| | | |——modules / //数据模块| | | |——store.js //vuex主入口| | | |——types.js //vuex的types文件| | |——App.vue //父组件| | |——main.js //入口文件| |——static/| |——.babelrc| |——.editorconfig| |——.gitgnore| |——index.html| |——package.json| |——README.md 主要难点1.各个组件数据的共享 传参的方法对于多层嵌套的组件将会非常繁琐，并且对于兄弟组件间的状态传递无能为力。而且也会导致代码难以维护 解决方法：采用vuex进行状态管理，把所有事件和状态存储在store对象中，在组件中通过计算属性获得事件，因此就有了实时性。 Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。 每一个 Vuex 应用的核心就是 store（仓库）。”store” 基本上就是一个容器，它包含着应用中大部分的状态(state)。 Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。 你不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交(commit) mutations。这样使得我们可以方便地跟踪每一个状态的变化。 代码如下(以一个user module为例)：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566//vuex/modules/user.jsimport api from '../../fetch/api'import * as types from '../types'const state = &#123; // 用户登录状态 loginStatus: JSON.parse(localStorage.getItem('loginStatus')) || false,&#125;const actions = &#123; /** * 用户登录 */ setUserInfo(&#123; commit &#125;, res) &#123; localStorage.setItem('loginStatus', true) commit(types.SET_LOGIN_STATUS, true) &#125;, /** * 退出登录 */ setSignOut(&#123; commit &#125;) &#123; localStorage.removeItem('loginStatus') commit(types.SET_LOGIN_STATUS, false) &#125;,&#125;const getters = &#123; loginStatus: state =&gt; state.loginStatus&#125;const mutations = &#123; [types.SET_LOGIN_STATUS](state, status) &#123; state.loginStatus = status &#125; &#125;export default &#123; state, actions, getters, mutations&#125;//User.vue&lt;template&gt; &lt;div class=\"user\"&gt; &lt;div v-if=\"!loginStatus\"&gt; ... &lt;/div&gt; &lt;div v-else&gt; ... &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; mapGetters &#125; from 'vuex'export default &#123; computed: &#123; ...mapGetters([ 'loginStatus' ]) &#125;&#125;&lt;/script&gt; 2.时间选择组件(要可选择时间段) 规则： 默认值为：开始日期在后天，结束日期在第六天 今天以前不可选择 点击某个日子，则将最近的节点移动过 如果离两个节点一样，则将开始日期移动过去 两个节点也可选到1天里；显示为各一半 一开始打算在github上搜索一个然后直接拿来用，发现都是不符合我的设计，所以打算自己撸一个，(不要怂，撸起袖子就是干)。终于经过几个晚上的奋战写出来了(期间遇到了各种坑)。代码就不贴出来了 代码传送门 总结虽然只是做了个小小的个人开源项目，但是我感觉收获还是很大的，很多知识点掌握得更加的牢固，对 vue全家桶 的理解又更深了一些。这个项目还没有完成，后期将不定期更新，敬请期待。。 如果觉得还行，欢迎star项目地址： https://github.com/hzzly/xyy-vue 好了，溜了溜了。。。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"webpack工程化","date":"2017-03-07T12:01:48.000Z","path":"2017/03/07/webpack工程化/","text":"一、webpack是什么 webpack is a module bundler. webpack takes modules with dependencies and generates static assets representing those modules webpack 是一个模块打包工具，输入为包含依赖关系的模块集，输出为打包合并的前端静态资源。在上一节的前端工程化中，已经介绍过，webpack 是同时支持 AMD 和 CommonJs 的模块定义方式，不仅如此，webpack 可以将任何前端资源视为模块，如 css，图片，文本。 二、为什么要使用它在 webpack 出现之前，已经有了一些打包工具，如 Browserify、grunt、gulp… 这些打包工具工具功能单一，只能完成特定的任务，然而 web 前端工程是复杂的，一个 webapp 对于业务代码的要求可能有： 代码可以分块，实现按需加载 首屏加载时间要尽量减少 需要集成一些第三方库 webpack 的出现正式为了解决这些问题，在 webpack 中，提供了一下这些功能： 1.代码分块： webpack 有两种类型的模块依赖，一种是同步的，一种是异步的。在打包的过程中可以将代码输出为代码块（chunk），代码块可以实现按需加载。 异步加载的代码块通过分割点（spliting point）来确定。2.Loaders： Webpack 本身只会处理 Javascript，为了实现将其他资源也定义为模块，并转化为 Javascript， Webpack 定义 loaders , 不同的 loader 可以将对应的资源转化为 Javascript 模块。3.智能的模块解析： webpack 可以很容易将第三方库转化为模块集成到项目代码中，模块的依赖可以用表达式的方式（这在其他打包工具中是没有支持的），这种模块依赖叫做动态模块依赖。4.插件系统： webpack 的可定制化在于其插件系统，其本身的很多功能也是通过插件的方式实现，插件系统形成了 webpack 的生态，是的可以使用很多开源的第三方插件。 三、webpack 核心思想1.万物皆模块： 在 webpack 的世界中，除了 Javascript，其他任何资源都可以当做模块的方式引用。2.按需加载： webapp 的优化关键在于代码体积，当应用体积增大，实现代码的按需加载是毕需，这也是 webpack 出现的根本原因。3.可定制化： 任何一个工具都不可能解决所有问题，提供解决方案才是最可行的，webpack 基于可定制化的理念构建，通过插件系统，配置文件，可以实现大型项目的定制需求。 四、安装配置在此之前你应该已经安装了 node.js. 全局安装webapck或webpack-dev-server(开启一个本地服务)12$ npm install webpack -g$ npm install webpack-dev-server -g 在项目中安装webpack和webpack-dev-server12$ npm install webpack --save-dev$ npm install webpack-dev-server --save-dev webpack使用1234567//name.jslet name = 'hzzly'export default name//index.jsimport name from './name'document.getElementById('app').textContent = `hello~$&#123;name&#125;` 1.命令行的使用1$ webpack src/index.js dist/bundle.js 语法：webpack 要打包的文件 打包输出的文件 2.配置文件的使用在项目目录下创建 webpack.config.js如下(简单的配置)：12345678910111213141516171819202122232425262728var webpack = require('webpack')module.exports = &#123; entry: './src/index.js', //入口 output: &#123; path: './dist/', //输出路径 filename: 'bundle.js' //输出文件名 &#125;, module: &#123; loaders: [ &#123; test: /\\.js[x]?$/, exclude: /node_modules/, loader: 'babel-loader', //处理.js或.jsx文件loader query: &#123; presets: ['env'] &#125; &#125;, &#123; test: /\\.css$/, loader: \"style-loader!css-loader\" //处理.css文件loader &#125;, &#123; test: /\\.(png|jpg)$/, loader: 'url-loader?limit=8192' //处理图片loader &#125; ] &#125;&#125; 执行：123$ webpack//或开启本地服务器并实时监听文件变化$ webpack-dev-server --inline --colors --hot Github地址： https://github.com/hzzly/webpack欢迎大家的star啦~ 好了，装了一大波，溜了溜了。。。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"前后端分离的尝试","date":"2017-03-06T02:21:49.000Z","path":"2017/03/06/前后端分离的尝试/","text":"首次尝试前后端分离是在一个外包项目中: 点匠科技 o2o的家装类 移动项目微信平台前端开发主要工作内容是将原有的android、ios 应用 配合后端工程师开发一套 微信产品,个人角色为 前端开发工程师 负责界面 html css vue 前后端数据联调等工作 项目地址(测试账号:15103585135 测试密码:123456) 这次的项目技术栈 vue vue-router vuex weui sass es6 ajax 通过这次项目，让我体会到了这种前后端分离的快感，所以特来分享一波。 如果你没有尝试过前后端分离的工作流程，那么可以先试想一下这样的流程改变： 把流程从 PM：“我要这个功能” 后端：“这个先找前端做个模板” 前端：“模板做完了” 后端：“我来对接一下，这里样式不对” 前端：“我改完了” 后端：“功能交付” PM：“春节要加这个活动” 后端：“这个先找前端改个模板” 前端：“模板做完了” 后端：“我来对接一下，这里样式不对” 前端：“我改完了” 后端：“功能交付” 变成 PM：“我要这个功能” 前端：“我要接口” 后端：“接口完成了” 前端：“我来对接一下，功能交付” PM：“春节要加这个活动” 前端：“需要增加接口” 后端：“接口完成了” 前端：“我来对接一下，功能交付” 由此可见，前后端分离的主要概念就是：后台只需提供API接口，前端调用AJAX实现数据呈现。 前后端分离的实现对技术人员尤其是前端人员的要求会上升一个层次，前端的工作不只是切页面写模板或是处理一些简单的js逻辑，前端需要处理服务器返回的各种数据格式，还需要掌握一系列的数据处理逻辑、MVVM思想和各种主流前端框架(React, Vue..)。 意义对于前后端分离的意义我们也可以看做是前端渲染的意义，我主要总结了下面四点： 1. 彻底解放前端 前端不再需要向后台提供模板或是后台在前端html中嵌入后台代码，前后端解耦，增加可读性。 2. 提高工作效率，分工更加明确 前后端分离的工作流程可以使前端只关注前端的事，后台只关心后台的活，两者开发可以同时进行，在后台还没有时间提供接口的时候，前端可以先将数据写死或者调用本地的json文件即可，页面的增加和路由的修改也不必再去麻烦后台，开发更加灵活。 3. 局部性能提升 通过前端路由的配置，我们可以实现页面的按需加载，无需一开始加载首页便加载网站的所有的资源，服务器也不再需要解析前端页面，在页面交互及用户体验上有所提升。 4. 降低维护成本 通过目前主流的前端MVVM框架，我们可以非常快速的定位及发现问题的所在，客户端的问题不再需要后台人员参与及调试，代码重构及可维护性增强。 面对快速发展的前端，我们应该去适应其带来的工作方式和流程的改变，目前的前后端分离的工作方式必然是今后的趋势所在，作为一个前端开发人员，我们应当承担这个普及前端新知识和改变现状的职责。 我的Github 好了，装了一大波，溜了溜了。。。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"前端入坑笔记–JavaScript类型检测","date":"2017-03-05T12:29:59.000Z","path":"2017/03/05/前端入坑笔记–JavaScript类型检测/","text":"JavaScript变量可以用来保存两种类型的值：基本类型值和引用类型值 5种基本数据类型：String Number Boolean Undefined Null 引用类型：Object Array Data RegExp Function Error Map … ES6引入了一种新的原始数据类型Symbol，表示独一无二的值 一、typeof typeof 用来判断各种数据类型,有两种写法：typeof xxx, typeof(xxx) 123456789101112131415161718var a = 'hzzly';var b = true;var c = 22;var d;var e = null;var o = new Object();var f = function () &#123;&#125;console.log( typeof a ); //stringconsole.log( typeof b ); //booleanconsole.log( typeof c ); //numberconsole.log( typeof d ); //undefinedconsole.log( typeof e ); //objectconsole.log( typeof o ); //objectconsole.log( typeof f ); //functionconsole.log( typeof &#123;&#125; ); //objectconsole.log( typeof [] ); //object 这里面包含了js里面的五种数据类型 number string boolean undefined object和函数类型 function 看到这里你肯定会问了：我怎么去区分对象，数组和null呢? 接下来我们就用到另外两个利器：Object.prototype.toString.call instanceof/constructor 二、Object.prototype.toString.call1234567891011121314151617var gettype=Object.prototype.toStringgettype.call('hzzly') 输出 [object String]gettype.call(22) 输出 [object Number]gettype.call(true) 输出 [object Boolean]gettype.call(undefined) 输出 [object Undefined]gettype.call(null) 输出 [object Null]gettype.call(&#123;&#125;) 输出 [object Object]gettype.call([]) 输出 [object Array]gettype.call(function()&#123;&#125;) 输出 [object Function] 三、instanceof/constructor根据规定，所有引用类型的值都是Object的实例。因此，在检测一个引用类型值和Object 构造函数时，instanceof 操作符始终会返回true。当然，如果使用instanceof 操作符检测基本类型的值，则该操作符始终会返回false，因为基本类型不是对象。 123456789console.log([] instanceof Array); //trueconsole.log(/^$/ instanceof RegExp); //trueconsole.log([] instanceof Object); //trueconsole.log([].constructor === Array); //trueconsole.log([].constructor === Object); //false 我们的constructor可以避免instanceof检测的时候,用Object也是true的问题console.log(&#123;&#125;.constructor === Object); //trueconsole.log(1 instanceof Number); //false 看到这里，刚才的问题我们解决了 检测数组，ECMAScript5新增了Array.isArray() 方法。这个方法的目的是最终确定某个值到底是不是数组，而不管它是在哪个全局执行环境中创建。这个方法的用法如下： 123if( Array.isArray(value) )&#123; //对数组执行某些操作&#125; 四、题外话基本类型值与引用类型值具有如下特点： 基本类型值在内存中占据固定大小的空间，因此被保存在栈内存中 从一个变量向另一个变量复制基本类型的值，会创建这个值得一个副本 引用类型的值是对象，保存在堆内存中 包含引用类型值得变量实际上包含的并不是对象本身，而是一个指向该对象的指针 从一个变量向另一个变量复制引用类型的值，复制的其实是指针，因此两个变量最终都指向同一个对象 好了，遛了遛了。。。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"手把手用Node的socket.io撸一个简单聊天室","date":"2017-03-04T14:51:43.000Z","path":"2017/03/04/手把手用Node的socket.io撸一个简单聊天室/","text":"点击查看效果 Socket.IO用于浏览器与Node.js之间实现实时通信。 Socket.IO设计的目标是支持任何的浏览器，任何Mobile设备。 支持主流的PC浏览器 (IE,Safari,Chrome,Firefox,Opera等)， Mobile浏览器(iphone Safari/ipad Safari/Android WebKit/WebOS WebKit等)。 Socket.IO解决了实时的通信问题，并统一了服务端与客户端的编程方式。 启动了socket以后，就像建立了一条客户端与服务端的管道，两边可以互通有无。 一、初始化一个Express项目通过应用生成器工具 express 可以快速创建一个应用的骨架。 123456789101112// 全局安装express 脚手架$ npm install express-generator -g//在当前工作目录创建一个命名为 chat-node 的应用$ express -e chat-node//安装所有依赖$ cd chat-node $ npm install//启动这个应用（MacOS 或 Linux 平台）：$ npm start 然后在浏览器中打开 http://localhost:3000/ 网址就可以看到这个应用了 二、安装Socket.IO这里使用 npm 安装到项目依赖中 1$ npm install socket.io --save 三、整合Socket.IO到项目中找到服务开启的www文件 根目录 &gt; bin &gt; www 1234567891011121314151617181920212223//在创建服务器(var server = http.createServer(app))之后添加如下代码var io = require('socket.io')(server);// 在线用户var onlineUser = &#123;&#125;;// 在线人数var onlineCount = 0;io.on('connection', (socket) =&gt; &#123; // 监听新用户加入 console.log('a user connected'); socket.on('disconnect', () =&gt; &#123; console.log('user disconnected'); &#125;); //监听post数据加入 socket.on('post', function(say) &#123; io.emit('post', say) //通过io的emit把数据发送到前台 &#125;);&#125;); 通过传递server(HTTP服务器)来初始化socket.io的一个新实例，然后监听连接sockets的connection事件，并将其记录到控制台。 三、修改前台代码在 views 目录下新建一个index.html 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0\"&gt; &lt;title&gt;聊天室&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"chat\" id=\"chatApp\" v-cloak&gt; &lt;ul class=\"room-list\"&gt; &lt;li v-for=\"item in msgList\"&gt; &lt;div class=\"msg-detail\"&gt;&#123;&#123;item&#125;&#125;&lt;/div&gt; &lt;/li&gt; &lt;/ul&gt; &lt;div class=\"send-box\"&gt; &lt;input type=\"text\" placeholder=\"写点什么喃...\" v-model=\"sendMsg\"&gt; &lt;button type=\"button\" @click=\"doSendMsg\"&gt;发送&lt;/button&gt; &lt;/div&gt;&lt;/div&gt;&lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/socket.io/1.7.3/socket.io.min.js\"&gt;&lt;/script&gt;&lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.1.3/vue.js\"&gt;&lt;/script&gt;&lt;script src=\"/javascripts/index.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 我在里面引入了socket.io以及vue(更好的渲染数据) 四、编写业务代码 在 public &gt; javascripts 下新建一个index.js 12345678910111213141516171819202122const socket = io(); //加载socket.io-client会暴露一个全局io并连接。const vue = new Vue(&#123; //实例化一个Vue实例 el: \"#chatApp\", data() &#123; return &#123; //数据驱动 sendMsg: '', msgList: [] &#125; &#125;, mounted() &#123; socket.on('post', (say) =&gt; &#123; //接收服务端的 post 命令 this.msgList.push(say) //添加到msgList中给前台渲染出来 &#125;) &#125;, methods: &#123; doSendMsg() &#123; //监听按钮发送的事件 socket.emit('post', this.sendMsg) //把要发送的数据emit到服务端 this.sendMsg = '' &#125; &#125;&#125;) 五、在对应路由中打开index.html 在 routes &gt; index.js 修改如下代码 1234/* GET home page. */router.get('/', function(req, res, next) &#123; res.sendFile(path.join(__dirname, '../views', 'index.html'));&#125;); 然后在浏览器中打开 http://localhost:3000/ 网址就可以看到这个应用de效果了 Github Demo欢迎star 好了，遛了遛了。。。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"Web的Flex弹性盒模型","date":"2017-03-03T01:24:26.000Z","path":"2017/03/03/Web的Flex弹性盒模型/","text":"一、Flex布局是什么？Flex是Flexible Box的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。任何一个容器都可以指定为Flex布局。 123.box&#123; display: flex;&#125; 行内元素也可以使用Flex布局。 123.box&#123; display: inline-flex;&#125; 二、容器的属性 [ flex-direction ] [ flex-wrap ] [ flex-flow ] [ justify-content ] [ align-self ] [ align-items ] [ align-content ] [ order ] 点击查看实例 下方为简略图 好了，遛了遛了。。。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"博客正式上线","date":"2017-03-02T00:49:45.000Z","path":"2017/03/02/博客正式上线/","text":"折腾了一个晚上，终于把Github Page上的博客搭起来了，有点小激动。哈哈哈，蛋定蛋定。之前一直想弄一个博客来着，偶然间发现了这个基于Node的Hexo博客，还可以放到Github上，很方便。你也可以试一试 (:好了，不扯这么多了，此博客将记录我学习的笔记、知识，并将其中承载的价值传给他人。 整理知识，学习笔记 发布日报，杂文，所见所想 撰写发布技术博客（代码支持） 撰写发布学术论文 1234567891011class Refuel &#123; constructor (refuel) &#123; this.refuel = refuel &#125; refuel () &#123; alert(this.refuel) &#125;&#125;new Refuel('加油！！！'); 好了，遛了遛了。。。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]}]