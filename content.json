[{"title":"Express与MongoDB的缠绵","date":"2017-03-25T11:00:36.000Z","path":"2017/03/25/Express与MongoDB的缠绵/","text":"前奏Express 是什么？ Express 是一个基于 Node.js 平台的极简、灵活的 web 应用开发框架，它提供一系列强大的特性，帮助你创建各种 Web 和移动设备应用。 全局安装express脚手架1$ npm install express-generator -g 创建express项目1234$ express myapp$ cd myapp$ npm install$ DEBUG=myapp npm start MongoDB与Mongoose？ MongoDB是一个对象数据库，是用来存储数据的；存储的数据格式为JSON。 Mongoose是封装了MongoDB操作(增删改查等)的一个对象模型库,是用来操作这些数据的。 安装MongoDB：https://www.mongodb.com/download-center?jmp=nav 安装Mongoose：1$ npm install mongoose --save 一、连接MongoDB 在项目根目录下新建/lib/mongo.js 12345var mongoose = require(\"mongoose\");var db = mongoose.connect('mongodb://localhost:27017/myblog');module.exports = db 要连接的数据库为myblog 二、Schema 一种以文件形式存储的数据库模型骨架，无法直接通往数据库端，不具备对数据库的操作能力，仅仅只是数据库模型在程序片段中的一种表现，可以说是数据属性模型(传统意义的表结构)，又或着是“集合”的模型骨架 新建一个用户Schema 在项目根目录下新建/models/users.js 12345678910111213141516var mongoose = require(\"mongoose\");var db = require('../lib/mongo');//一个用户模型var UserSchema = new mongoose.Schema(&#123; username : &#123; type:String &#125;, password : &#123;type: String&#125;, avatar : &#123;type: String&#125;, age : &#123; type:Number, default:0 &#125;, description : &#123; type: String&#125;, email : &#123; type: String &#125;, github : &#123; type: String &#125;, time : &#123; type:Date, default:Date.now &#125;&#125;);//创建Modelvar UserModel = db.model(\"user\", UserSchema );module.exports = UserModel user：数据库中的集合名称,当我们对其添加数据时如果user已经存在，则会保存到其目录下，如果不存在，则会创建user集合，然后在保存数据。 拥有了Model，我们也就拥有了操作数据库的金钥匙，就可以使用Model来进行增删改查的具体操作。 Entity Entity–由Model创建的实体，使用save方法保存数据，Model和Entity都有能影响数据库的操作，但Model比Entity更具操作性。所以此项目主要用的Model。 12345678910111213var UserEntity = new UserModel(&#123; name : \"hzzly\", age : 21, email: \"hjingren@aliyun.com\", github: 'https://github.com/hzzly'&#125;);UserEntity.save(function(error,doc)&#123; if(error)&#123; console.log(\"error :\" + error); &#125;else&#123; console.log(doc); &#125;&#125;); 三、封装数据库的CURD 在lib文件下新建api.js 采用Promise封装对数据库的操作，避免回调地狱，使得代码能够更好的被读懂和维护。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980var UserModel = require('../models/users');module.exports = &#123; /** * 添加数据 * @param &#123;[type]&#125; data 需要保存的数据对象 */ save(data) &#123; return new Promise((resolve, reject) =&gt; &#123; //model.create(保存的对象,callback) UserModel.create(data, (error, doc) =&gt; &#123; if(error)&#123; reject(error) &#125;else&#123; resolve(doc) &#125; &#125;) &#125;) &#125;, find(data=&#123;&#125;, fields=null, options=&#123;&#125;) &#123; return new Promise((resolve, reject) =&gt; &#123; //model.find(需要查找的对象(如果为空，则查找到所有数据), 属性过滤对象[可选参数], options[可选参数], callback) UserModel.find(data, fields, options, (error, doc) =&gt; &#123; if(error)&#123; reject(error) &#125;else&#123; resolve(doc) &#125; &#125;) &#125;) &#125;, findOne(data) &#123; return new Promise((resolve, reject) =&gt; &#123; //model.findOne(需要查找的对象,callback) UserModel.findOne(data, (error, doc) =&gt; &#123; if(error)&#123; reject(error) &#125;else&#123; resolve(doc) &#125; &#125;) &#125;) &#125;, findById(data) &#123; return new Promise((resolve, reject) =&gt; &#123; //model.findById(需要查找的id对象 ,callback) UserModel.findById(data, (error, doc) =&gt; &#123; if(error)&#123; reject(error) &#125;else&#123; resolve(doc) &#125; &#125;) &#125;) &#125;, update(conditions, update) &#123; return new Promise((resolve, reject) =&gt; &#123; //model.update(查询条件,更新对象,callback) UserModel.update(conditions, update, (error, doc) =&gt; &#123; if(error)&#123; reject(error) &#125;else&#123; resolve(doc) &#125; &#125;) &#125;) &#125;, remove(conditions) &#123; return new Promise((resolve, reject) =&gt; &#123; //model.update(查询条件,callback) UserModel.remove(conditions, (error, doc) =&gt; &#123; if(error)&#123; reject(error) &#125;else&#123; resolve(doc) &#125; &#125;) &#125;) &#125;&#125; 四、使用 在/routers/index.js中使用 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950var api = require('../lib/api');router.post('/login', function(req, res, next) &#123; var user = &#123; username : req.body.username, password: req.body.password &#125;; api.findOne(user) .then(result =&gt; &#123; console.log(result) &#125;)&#125;)router.post('/sign_up', function(req, res, next) &#123; var user = &#123; username : req.body.username, password: req.body.password, email: req.body.email &#125;; api.save(user) .then(result =&gt; &#123; console.log(result) &#125;)&#125;)router.get('/user_list', function(req, res, next) &#123; //返回所有用户 api.find(&#123;&#125;) .then(result =&gt; &#123; console.log(result) &#125;) //返回只包含一个键值name、age的所有记录 api.find(&#123;&#125;,&#123;name:1, age:1, _id:0&#125;) .then(result =&gt; &#123; console.log(result) &#125;) //返回所有age大于18的数据 api.find(&#123;\"age\":&#123;\"$gt\":18&#125;&#125;) .then(result =&gt; &#123; console.log(result) &#125;) //返回20条数据 api.find(&#123;&#125;,null,&#123;limit:20&#125;) .then(result =&gt; &#123; console.log(result) &#125;) //查询所有数据，并按照age降序顺序返回数据 api.find(&#123;&#125;,null,&#123;sort:&#123;age:-1&#125;&#125;) //1是升序，-1是降序 .then(result =&gt; &#123; console.log(result) &#125;)&#125;) 项目Github地址： https://github.com/hzzly/express-mongodb如果对你有帮助，欢迎star 文章来源hzzly博客技术分享","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"浅谈Promise","date":"2017-03-25T07:29:12.000Z","path":"2017/03/25/浅谈Promise/","text":"接触过promise的的都知道它的应用场景和用途，Promise可以用来避免异步操作函数里的嵌套回调（callback hell）问题，因为解决异步最直接的方法是回调嵌套，将后一个的操作放在前一个操作的异步回调里，但如果操作多了，就会有很多层的嵌套(回调地狱)。 12345678910$.ajax(url1, function(data1)&#123; // do something... $.ajax(url2, function(data2)&#123; // do something... $.ajax(url3, function(data3)&#123; // do something... done(data3); // 返回数据 &#125;) &#125;);&#125;); Promise学术点的描述： promise代表一个异步操作的执行返回状态，这个执行返回状态在promise对象创建时未必已知。它允许你为异步操作的成功或失败指定处理方法。 这使得异步方法可以像同步方法那样返回值：异步方法会返回一个包含了原返回状态的 promise 对象来替代原返回状态。 Promise的表现如果使用回调方法处理多个操作的异步场景，判断某个操作成功或失败的控制在于声明的匿名函数里面，使用Promise对象则可以重新定义异步执行的状态和控制逻辑。 promises的最重要的特点就是它把我们处理任何函数调用的成功或者失败的方式规范成了可预测的形式，特别是如果这个调用实际上的异步的。 Promise中有几个状态： pending: 初始状态。 非 fulfilled 或 rejected。 resolved: 成功的操作。也有的成为fulfilled 。 rejected: 失败的操作。 状态转换关系为： pending-&gt;resolved(fulfilled)，pending-&gt;rejected。 用法说了这么多，直接上代码。 123456789101112131415var promise = new Promise((resolve, reject) =&gt; &#123; // do somthing, maybe async if (success)&#123; return resolve(res); &#125; else &#123; return reject(err); &#125;&#125;); promise.then(res =&gt; &#123; // do something... e.g console.log(res);&#125;, err =&gt; &#123; // deal the err.&#125;) 或封装成方法1234567891011121314151617function fetch(data) &#123; return new Promise((resolve, reject) =&gt; &#123; // do somthing, maybe async if (success)&#123; resolve(res); &#125; else &#123; reject(err); &#125; &#125;)&#125;fetch(data) .then(res =&gt; &#123; console.log(res) &#125;, err =&gt; &#123; // deal the err. &#125;) 异步嵌套回调123456789101112131415161718192021222324252627function loadAsync1()&#123; return new Promise((resolve, reject) =&gt; &#123; //异步操作 setTimeout(() =&gt; &#123; console.log('异步任务1'); resolve('异步任务1传过来的值'); &#125;, 2000); &#125;); &#125;function loadAsync2(data1)&#123; return new Promise((resolve, reject) =&gt; &#123; //异步操作 setTimeout(() =&gt; &#123; console.log('异步任务2'); resolve('异步任务2传过来的值'); &#125;, 2000); &#125;); &#125;function loadAsync3(data2)&#123; return new Promise((resolve, reject) =&gt; &#123; //异步操作 setTimeout(() =&gt; &#123; console.log('异步任务3'); resolve('异步任务3传过来的值'); &#125;, 2000); &#125;); &#125; 有返回值12345678loadAsync1() .then(data1 =&gt; &#123; return loadAsync2(data1) &#125;) .then(data2 =&gt; &#123; return loadAsync3(data2) &#125;) .then(okFn, failFn) 没有返回值12345678loadAsync1() .then(data1 =&gt; &#123; loadAsync2(data1) &#125;) .then(data2 =&gt;&#123; loadAsync3(data2) &#125;) .then(res =&gt; console.log(res)) 输出的值为： 异步任务1异步任务1传过来的值异步任务2异步任务2传过来的值异步任务3异步任务3传过来的值 promise.all方法 Promise.all 可以接收一个元素为 Promise 对象的数组作为参数，当这个数组里面所有的 Promise 对象都变为 resolve 时，该方法才会返回。 12345678910111213141516var p1 = new Promise((resolve) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(\"第一个promise\"); &#125;, 3000);&#125;);var p2 = new Promise((resolve) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(\"第二个promise\"); &#125;, 1000);&#125;);Promise.all([p1, p2]) .then((result) =&gt; &#123; console.log(result); // [\"第一个promise\", \"第二个promise\"] &#125;); 上面的代码中，all接收一个数组作为参数，p1,p2是并行执行的，等两个都执行完了，才会进入到then，all会把所有的结果放到一个数组中返回，所以我们打印出我们的结果为一个数组。 值得注意的是，虽然p2的执行顺序比p1快，但是all会按照参数里面的数组顺序来返回结果。all的使用场景类似于，玩游戏的时候，需要提前将游戏需要的资源提前准备好，才进行页面的初始化。 之后会有express操作mongondb的基于Promise的封装，敬请期待！","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"移动端touch事件","date":"2017-03-22T14:08:21.000Z","path":"2017/03/22/移动端touch事件/","text":"4个touch事件touchstart 事件：当手指触摸屏幕时候触发，即使已经有一个手指放在屏幕上也会触发。touchmove 事件：当手指在屏幕上滑动的时候连续地触发。调用preventDefault()事件可以阻止滚动。touchend 事件：当手指从屏幕上离开的时候触发。touchcancel 事件：触摸结束的时候触发 触摸事件：touches：当前位于屏幕上的所有手指的列表。targetTouches：位于当前DOM元素上手指的列表。changedTouches：涉及当前事件手指的列表。 Touch对象属性每个Touch对象包含的属性如下： clientX：触摸目标在视口中的x坐标。clientY：触摸目标在视口中的y坐标。identifier：标识触摸的唯一ID。pageX：触摸目标在页面中的x坐标。pageY：触摸目标在页面中的y坐标。screenX：触摸目标在屏幕中的x坐标。screenY：触摸目标在屏幕中的y坐标。target：触摸的DOM节点目标。 12345678910111213141516171819document.addEventListener('touchstart',touch,false);document.addEventListener('touchmove',touch,false);document.addEventListener('touchend',touch,false); function touch (event)&#123; var event = event || window.event; var oInp = document.getElementById(\"inp\"); switch(event.type)&#123; case \"touchstart\": oInp.innerHTML =`Touch started ( $&#123;event.touches[0].clientX&#125; , $&#123;event.touches[0].clientY&#125; )`; break; case \"touchend\": oInp.innerHTML =`&lt;br&gt;Touch end ( $&#123;event.changedTouches[0].clientX&#125; , $&#123;event.changedTouches[0].clientY&#125; )`; break; case \"touchmove\": event.preventDefault(); oInp.innerHTML =`&lt;br&gt;Touch moved ( $&#123;event.touches[0].clientX&#125; , $&#123;event.touches[0].clientY&#125; )`; break; &#125;&#125; 事件(包括鼠标事件)发生的顺序如下：(1) touchstart(2) mouseover(3) mousemove(一次)(4) mousedown(5) mouseup(6) click(7) touchend","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"一个Vue+Canvas的酷炫后台管理","date":"2017-03-21T09:10:38.000Z","path":"2017/03/21/一个Vue-Canvas的酷炫后台管理/","text":"又一个Vue+Cnavas酷炫的后台管理，依然前后端分离（用PC打开，还没适配移动端）。 项目地址： https://github.com/hzzly/canvas-vuedemo地址： http://hjingren.cn/curriculum-design/账号：hzzly 密码：123456欢迎大家的star啦~ 技术栈前台: &gt; 1. vue-cli &gt; 2. vue &gt; 3. vue-router &gt; 4. webpak &gt; 5. canvas &gt; 6. ajax 后台: &gt; 1. wamp &gt; 2. PHP(ThinkPHP) &gt; 3. mysql 功能说明 登录 用户登录 管理员登录 注册 用户注册 Canvas 流星滑过 星星闪闪 后台折线 折线跟着鼠标滑动 Vue 弹出框组件 路由切换动画 通过Ajax调用后台接口 留言板(时间轴) 添加房屋信息 出租 求租 出售 求购 个人信息修改 密码修改 …… 1.登录注册模块，流星与星星为canvas，登录注册切换动画为vue transition 2.后台管理页面，背景为canvas(会动的折线+跟着鼠标滑动) 功能模块切换为vue transition 3.留言板(时间轴特效) 目录结构12345678910111213141516171819202122232425|——canvas-vue/| |——build/| |——confg/| |——node_modules/| |——src/| | |——assets/ //静态文件| | |——components/ //页面组件| | | |——Menu.vue //登录注册加载页面| | | |——Home.vue //后台首页| | | |——Login.vue //登录页面| | | |——Regist.vue //注册页面| | | |——Navbar.vue //我的发布| | | |——Messageboard.vue //留言板页面| | | |——... //等等| | |——router/ | | | |——index.js //页面路由| | |——App.vue //父组件| | |——main.js //入口文件| |——static/ | |——.babelrc| |——.editorconfig| |——.gitgnore| |——index.html| |——package.json| |——README.md 总结这个项目还没有完成，后期将不定期更新，敬请期待。。 如果觉得还行，欢迎star项目地址： https://github.com/hzzly/canvas-vue项目后台(PHP)地址： https://github.com/hzzly/canvas-vue-backstage 好了，溜了溜了。。。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"移动端屏幕适配的解决","date":"2017-03-15T14:01:18.000Z","path":"2017/03/15/移动端屏幕适配的解决/","text":"随着手机硬件配置的飞速增长、屏幕尺寸的越来越大和网络带宽的逐渐提升，越来越多的PC业务和服务在向移动端转移。然而在这移动端的时代，为了处理各终端屏幕的适配，是否乱了手脚呢？ 虽然移动端的页面与PC的页面相比简单了不少，但让我们头痛的事情还是要想尽办法让页面能适配众多不同的终端设备。在前几个外包项目中，我做的主要都是移动微信端的。期间也遇到了不同屏幕大小的适配问题，所以今天特来分享一下我的解决方法。 项目地址： https://github.com/hzzly/xyy-vuedemo地址： http://hjingren.cn/xyy-vue/欢迎大家的star啦~ 一、meta标签 meta之viewport，其主要用来告诉浏览器如何规范的渲染Web页面，而你则需要告诉它视窗有多大。在开发移动端页面，我们需要在html中设置meta标签如下： 1&lt;meta name=\"viewport\" content=\"width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0\"&gt; 二、手淘的flexible flexible是一个制作H5适配的开源库，需要在html中引入，可以直接使用阿里CDN： 1&lt;script src=\"http://g.tbcdn.cn/mtb/lib-flexible/0.3.4/??flexible_css.js,flexible.js\"&gt;&lt;/script&gt; 执行这个JS后，会在元素上增加一个data-dpr属性，以及一个font-size样式。JS会根据不同的设备添加不同的data-dpr值，比如说1、2或者3，同时会给html加上对应的font-size的值，比如说37.5px。 三、放弃px拥抱rem 用px写的是绝对单位，这种方法肯定不行。让我们来拥抱rem吧！！！ 我们知道 em 的计算是基于父级元素的，在实际使用中给我们的计算带来了很大的不便。所以 rem 的出现解救了我这样不会算术的人，再也不用担心父级元素的 font-size 了，因为它始终是基于根元素（html） 的。比如默认的 html font-size=16px，那么我想设置12px 的文字就是：12÷16=0.75（rem） 如果对rem还有不懂的可以先看看这个CSS3的REM设置字体大小 刚刚我们引入了手淘的flexible，并给html加了font-size，如此一来，页面中的元素，都可以通过rem单位来设置。他们会根据html元素的font-size值做相应的计算，从而实现屏幕的适配效果。 四、CSS处理器(SASS) 使用Sass的同学，可以使用Sass的函数、混合宏这些功能来实现： 123@function px2rem($px, $base-font-size: 75px) &#123; @return ($px / $base-font-size) * 1rem;&#125; 这里的这个参数$base-font-size: 75px，可以通过(psd文件的宽度/10)来计算。假如psd宽750，则$base-font-size为75px。 使用： psd中量多少就写多少 12345//比如量取box宽为190，高为190，则代码：.box &#123; width: px2rem(190px); height: px2rem(190px);&#125; 没用过的可以用sublime的cssrem的插件实现。 五、图示 六、图示代码 因为这是商业代码，所以就只贴了一部分代码，忘见谅，谢谢最下面有我开源项目的代码，可以参考，如果对你有帮助的话，给个star。 123456789101112131415161718192021222324252627//index.html&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0\"&gt; &lt;title&gt;Demo&lt;/title&gt; &lt;script src=\"http://g.tbcdn.cn/mtb/lib-flexible/0.3.4/??flexible_css.js,flexible.js\"&gt;&lt;/script&gt; &lt;link rel=\"stylesheet\" href=\"index.css\"&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"home\"&gt; &lt;div class=\"home-list\"&gt; &lt;div class=\"list-item\"&gt; &lt;a href=\"/\"&gt; &lt;div class=\"item-l\"&gt; &lt;img src=\"../assets/images/check.png\" alt=\"\"&gt; &lt;span&gt;待审核&lt;/span&gt; &lt;/div&gt; &lt;div class=\"item-r isnew\"&gt;6&lt;/div&gt; &lt;/a&gt; &lt;/div&gt; ... &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041//index.scss@function px2rem($px, $base-font-size: 75px) &#123; @return ($px / $base-font-size) * 1rem;&#125;.home-list &#123; padding-bottom: px2rem(45px); .list-item &#123; box-sizing: border-box; width: px2rem(690px); height: px2rem(190px); line-height: px2rem(190px); margin: px2rem(45px) auto 0; padding: 0 px2rem(50px) 0 px2rem(30px); background: #fff; border-radius: px2rem(20px); a &#123; display: flex; justify-content: space-between; font-size: px2rem(40px); img &#123; width: px2rem(90px); height: px2rem(65px); vertical-align: middle; margin-right: px2rem(30px); &#125; span &#123; color: #000; vertical-align: middle; &#125; .item-r &#123; color: #666666; &amp;.isnew &#123; color: #ff5500; &#125; &#125; &amp;:link,&amp;:visited,&amp;:hover,&amp;:active &#123; text-decoration: none; &#125; &#125; &#125;&#125; 七、开源示例如果觉得还行，欢迎star项目地址： https://github.com/hzzly/xyy-vue 好了，溜了溜了。。。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"移动端1px的解决方法","date":"2017-03-13T13:22:43.000Z","path":"2017/03/13/移动端1px的解决方法/","text":"在上个项目中，移动端1px问题被困扰了好久，设置1px边框，实际显示2px。以下是我在项目中的解决方法，才疏学浅，轻喷。 关于什么是移动端1像素边框问题，先上两张图，大家就明白了。 假的1px: 真的1px: 原来Retine屏的分辨率始终是普通屏幕的2倍，1px的边框在devicePixelRatio=2的retina屏下会显示成2px。 解决方案 transform: scaleY() 12345678910111213141516171819202122232425262728293031323334&lt;div class=&quot;border-1px&quot;&gt;&lt;/div&gt;&lt;style type=&quot;text/scss&quot;&gt;.border-1px &#123; position: relative; &amp;:after&#123; display: block; position: absolute; left: 0; bottom: 0; width: 100%; border-top: 1px solid #000; content: &apos;&apos;; &#125;&#125;@media (-webkit-min-device-pixel-ratio: 1.5),(min-device-pixel-ratio: 1.5) &#123; .border-1px&#123; &amp;::after&#123; -webkit-transform: scaleY(0.7); transform: scaleY(0.7); &#125; &#125;&#125;@media (-webkit-min-device-pixel-ratio: 2),(min-device-pixel-ratio: 2) &#123; .border-1px&#123; &amp;::after&#123; -webkit-transform: scaleY(0.5); transform: scaleY(0.5); &#125; &#125;&#125;&lt;/style&gt; 到这已经成功解决了1px问题。 好了，吃饭去喽，溜了溜了。。。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"axios在vue中的简单配置与使用","date":"2017-03-12T13:34:08.000Z","path":"2017/03/12/axios在vue中的简单配置与使用/","text":"尤雨溪之前在微博发布消息，不再继续维护vue-resource，并推荐大家开始使用 axios 。 一、axios 简介axios 是一个基于Promise 用于浏览器和 nodejs 的 HTTP 客户端，它本身具有以下特征： 从浏览器中创建 XMLHttpRequest 从 node.js 发出 http 请求 支持 Promise API 拦截请求和响应 转换请求和响应数据 取消请求 自动转换JSON数据 客户端支持防止 CSRF/XSRF 二、引入方式：npm:123$ npm install axios//淘宝源$ cnpm install axios bower:1$ bower install axios cdn:1&lt;script src=\"https://unpkg.com/axios/dist/axios.min.js\"&gt;&lt;/script&gt; 三、vue中axios的配置 之前那个开源项目一开始就打算用axios，在网上找了好多文章与攻略，发现好多都不太详细，所以打算自己动手配置一个，(不要怂，撸起袖子就是干)。 我的配置：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import axios from 'axios'import qs from 'qs'import * as _ from '../util/tool'axios.defaults.timeout = 5000; //响应时间axios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded;charset=UTF-8'; //配置请求头axios.defaults.baseURL = '你的接口地址'; //配置接口地址//POST传参序列化(添加请求拦截器)axios.interceptors.request.use((config) =&gt; &#123; //在发送请求之前做某件事 if(config.method === 'post')&#123; config.data = qs.stringify(config.data); &#125; return config;&#125;,(error) =&gt;&#123; _.toast(\"错误的传参\", 'fail'); return Promise.reject(error);&#125;);//返回状态判断(添加响应拦截器)axios.interceptors.response.use((res) =&gt;&#123; //对响应数据做些事 if(!res.data.success)&#123; // _.toast(res.data.msg); return Promise.reject(res); &#125; return res;&#125;, (error) =&gt; &#123; _.toast(\"网络异常\", 'fail'); return Promise.reject(error);&#125;);//返回一个Promise(发送post请求)export function fetch(url, params) &#123; return new Promise((resolve, reject) =&gt; &#123; axios.post(url, params) .then(response =&gt; &#123; resolve(response.data); &#125;, err =&gt; &#123; reject(err); &#125;) .catch((error) =&gt; &#123; reject(error) &#125;) &#125;)&#125; 四、vue中使用配置好的axios123456789101112131415161718192021export default &#123; /** * 用户登录 */ Login(params) &#123; return fetch('/users/api/userLogin', params) &#125;, /** * 用户注册 */ Regist(params) &#123; return fetch('/users/api/userRegist', params) &#125;, /** * 发送注册验证码 */ RegistVerifiCode(tellphone) &#123; return fetch('/users/api/registVerifiCode', &#123;tellphone: tellphone&#125;) &#125;, ......&#125; 如果觉得还行，欢迎star项目地址： https://github.com/hzzly/xyy-vuedemo地址： http://hjingren.cn/xyy-vue/ 好了，溜了溜了。。。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"开源的收获","date":"2017-03-09T15:57:05.000Z","path":"2017/03/09/开源的收获/","text":"第一次在github上发布了开源《Qu约》后，不到两天，被人star了137次，fork了25次，这个成绩大大出乎了我自己的意料！ Github地址： https://github.com/hzzly/xyy-vuedemo地址： http://hjingren.cn/xyy-vue/欢迎大家的star啦~ 同时也让我收获到了许多： github首次破百 掘金的阅读量与喜欢量同时给他人带来了不一样的价值 segmentfault的阅读量、收藏量与声望值，把其中的价值传给他人 收获了一个offer 给我以后就业增加了一份保证 结交了好多同行开发者 分享与开源，让技术生生不息。借用一本书de名字，Just for fun。开源是一种情怀，happy hacking！ 革命尚未成功，我们还需努力。。。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"进阶vue全家桶","date":"2017-03-08T01:47:54.000Z","path":"2017/03/08/进阶vue全家桶/","text":"有人说只会vue不会vuex还只是个切图仔，所以本项目将带领你进阶vue全家桶。前端结合Vue2.0全家桶(vue+vue-router+vuex+axios+es6+sass)以及后端Node,一个前后端分离的练手项目。本项目可以作为一个前端vue进阶项目，从前端flex布局到前端vue以及组件分离的使用，再到后端Node以及Leancloud的结合，是一个打通前后端流程的一个项目。欢迎大家前来star。如果有任何问题，可以给我留言，我们互相学习讨论，一起进步。注：本项目为开源项目，非本人同意不能用于商业应用。 项目地址： https://github.com/hzzly/xyy-vuedemo地址： http://hjingren.cn/xyy-vue/欢迎大家的star啦~ 功能说明 首页轮播图 首页热门活动 约跑步活动列表 约出行活动列表 个人中心 查看个人活动 学生认证(待开发) 学生信息修改 消息通知(后台接口待开发) 选择高校(待开发) 登录 注册 活动详情 活动报名 活动发布 时间选择组件 地址选择组件 文件上传 axios的封装 …… 公共组件 弹出文字组件 弹出框组件 loading组件 toast组件 时间选择器组件 地址选择器组件 …… 目录结构 123456789101112131415161718192021222324252627282930313233343536373839|——xyy-vue/| |——build/| |——confg/| |——node_modules/| |——src/| | |——assets/ //静态文件| | |——components/ //公共组件| | |——fetch/| | | |——api.js //axios封装与api| | |——pages/ //存放项目页面| | | |——Detail.vue //活动详情页面| | | |——Home.vue //首页| | | |——Login.vue //登录页面| | | |——Navbar.vue //我的发布| | | |——NotFound.vue //出错页面| | | |——Post.vue //发布活动页面| | | |——Regist.vue //注册页面| | | |——Set.vue //设置页面| | | |——Sport.vue //约跑步活动列表页面| | | |——Travel.vue //约出行活动列表页面| | | |——User.vue //个人中心页面| | | |——UserInfo.vue //个人详情页面| | | |——UserMsg.vue //消息列表页面| | |——router/ | | | |——index.js //页面路由| | |——util //公用方法| | |——vuex / //存放vuex代码| | | |——modules / //数据模块| | | |——store.js //vuex主入口| | | |——types.js //vuex的types文件| | |——App.vue //父组件| | |——main.js //入口文件| |——static/| |——.babelrc| |——.editorconfig| |——.gitgnore| |——index.html| |——package.json| |——README.md 主要难点1.各个组件数据的共享 传参的方法对于多层嵌套的组件将会非常繁琐，并且对于兄弟组件间的状态传递无能为力。而且也会导致代码难以维护 解决方法：采用vuex进行状态管理，把所有事件和状态存储在store对象中，在组件中通过计算属性获得事件，因此就有了实时性。 Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。 每一个 Vuex 应用的核心就是 store（仓库）。”store” 基本上就是一个容器，它包含着应用中大部分的状态(state)。 Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。 你不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交(commit) mutations。这样使得我们可以方便地跟踪每一个状态的变化。 代码如下(以一个user module为例)：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566//vuex/modules/user.jsimport api from '../../fetch/api'import * as types from '../types'const state = &#123; // 用户登录状态 loginStatus: JSON.parse(localStorage.getItem('loginStatus')) || false,&#125;const actions = &#123; /** * 用户登录 */ setUserInfo(&#123; commit &#125;, res) &#123; localStorage.setItem('loginStatus', true) commit(types.SET_LOGIN_STATUS, true) &#125;, /** * 退出登录 */ setSignOut(&#123; commit &#125;) &#123; localStorage.removeItem('loginStatus') commit(types.SET_LOGIN_STATUS, false) &#125;,&#125;const getters = &#123; loginStatus: state =&gt; state.loginStatus&#125;const mutations = &#123; [types.SET_LOGIN_STATUS](state, status) &#123; state.loginStatus = status &#125; &#125;export default &#123; state, actions, getters, mutations&#125;//User.vue&lt;template&gt; &lt;div class=\"user\"&gt; &lt;div v-if=\"!loginStatus\"&gt; ... &lt;/div&gt; &lt;div v-else&gt; ... &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; mapGetters &#125; from 'vuex'export default &#123; computed: &#123; ...mapGetters([ 'loginStatus' ]) &#125;&#125;&lt;/script&gt; 2.时间选择组件(要可选择时间段) 规则： 默认值为：开始日期在后天，结束日期在第六天 今天以前不可选择 点击某个日子，则将最近的节点移动过 如果离两个节点一样，则将开始日期移动过去 两个节点也可选到1天里；显示为各一半 一开始打算在github上搜索一个然后直接拿来用，发现都是不符合我的设计，所以打算自己撸一个，(不要怂，撸起袖子就是干)。终于经过几个晚上的奋战写出来了(期间遇到了各种坑)。代码就不贴出来了 代码传送门 总结虽然只是做了个小小的个人开源项目，但是我感觉收获还是很大的，很多知识点掌握得更加的牢固，对 vue全家桶 的理解又更深了一些。这个项目还没有完成，后期将不定期更新，敬请期待。。 如果觉得还行，欢迎star项目地址： https://github.com/hzzly/xyy-vue 好了，溜了溜了。。。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"webpack工程化","date":"2017-03-07T12:01:48.000Z","path":"2017/03/07/webpack工程化/","text":"一、webpack是什么 webpack is a module bundler. webpack takes modules with dependencies and generates static assets representing those modules webpack 是一个模块打包工具，输入为包含依赖关系的模块集，输出为打包合并的前端静态资源。在上一节的前端工程化中，已经介绍过，webpack 是同时支持 AMD 和 CommonJs 的模块定义方式，不仅如此，webpack 可以将任何前端资源视为模块，如 css，图片，文本。 二、为什么要使用它在 webpack 出现之前，已经有了一些打包工具，如 Browserify、grunt、gulp… 这些打包工具工具功能单一，只能完成特定的任务，然而 web 前端工程是复杂的，一个 webapp 对于业务代码的要求可能有： 代码可以分块，实现按需加载 首屏加载时间要尽量减少 需要集成一些第三方库 webpack 的出现正式为了解决这些问题，在 webpack 中，提供了一下这些功能： 1.代码分块： webpack 有两种类型的模块依赖，一种是同步的，一种是异步的。在打包的过程中可以将代码输出为代码块（chunk），代码块可以实现按需加载。 异步加载的代码块通过分割点（spliting point）来确定。2.Loaders： Webpack 本身只会处理 Javascript，为了实现将其他资源也定义为模块，并转化为 Javascript， Webpack 定义 loaders , 不同的 loader 可以将对应的资源转化为 Javascript 模块。3.智能的模块解析： webpack 可以很容易将第三方库转化为模块集成到项目代码中，模块的依赖可以用表达式的方式（这在其他打包工具中是没有支持的），这种模块依赖叫做动态模块依赖。4.插件系统： webpack 的可定制化在于其插件系统，其本身的很多功能也是通过插件的方式实现，插件系统形成了 webpack 的生态，是的可以使用很多开源的第三方插件。 三、webpack 核心思想1.万物皆模块： 在 webpack 的世界中，除了 Javascript，其他任何资源都可以当做模块的方式引用。2.按需加载： webapp 的优化关键在于代码体积，当应用体积增大，实现代码的按需加载是毕需，这也是 webpack 出现的根本原因。3.可定制化： 任何一个工具都不可能解决所有问题，提供解决方案才是最可行的，webpack 基于可定制化的理念构建，通过插件系统，配置文件，可以实现大型项目的定制需求。 四、安装配置在此之前你应该已经安装了 node.js. 全局安装webapck或webpack-dev-server(开启一个本地服务)12$ npm install webpack -g$ npm install webpack-dev-server -g 在项目中安装webpack和webpack-dev-server12$ npm install webpack --save-dev$ npm install webpack-dev-server --save-dev webpack使用1234567//name.jslet name = 'hzzly'export default name//index.jsimport name from './name'document.getElementById('app').textContent = `hello~$&#123;name&#125;` 1.命令行的使用1$ webpack src/index.js dist/bundle.js 语法：webpack 要打包的文件 打包输出的文件 2.配置文件的使用在项目目录下创建 webpack.config.js如下(简单的配置)：12345678910111213141516171819202122232425262728var webpack = require('webpack')module.exports = &#123; entry: './src/index.js', //入口 output: &#123; path: './dist/', //输出路径 filename: 'bundle.js' //输出文件名 &#125;, module: &#123; loaders: [ &#123; test: /\\.js[x]?$/, exclude: /node_modules/, loader: 'babel-loader', //处理.js或.jsx文件loader query: &#123; presets: ['env'] &#125; &#125;, &#123; test: /\\.css$/, loader: \"style-loader!css-loader\" //处理.css文件loader &#125;, &#123; test: /\\.(png|jpg)$/, loader: 'url-loader?limit=8192' //处理图片loader &#125; ] &#125;&#125; 执行：123$ webpack//或开启本地服务器并实时监听文件变化$ webpack-dev-server --inline --colors --hot Github地址： https://github.com/hzzly/webpack欢迎大家的star啦~ 好了，装了一大波，溜了溜了。。。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"前后端分离的尝试","date":"2017-03-06T02:21:49.000Z","path":"2017/03/06/前后端分离的尝试/","text":"首次尝试前后端分离是在一个外包项目中: 点匠科技 o2o的家装类 移动项目微信平台前端开发主要工作内容是将原有的android、ios 应用 配合后端工程师开发一套 微信产品,个人角色为 前端开发工程师 负责界面 html css vue 前后端数据联调等工作 项目地址(测试账号:15103585135 测试密码:123456) 这次的项目技术栈 vue vue-router vuex weui sass es6 ajax 通过这次项目，让我体会到了这种前后端分离的快感，所以特来分享一波。 如果你没有尝试过前后端分离的工作流程，那么可以先试想一下这样的流程改变： 把流程从 PM：“我要这个功能” 后端：“这个先找前端做个模板” 前端：“模板做完了” 后端：“我来对接一下，这里样式不对” 前端：“我改完了” 后端：“功能交付” PM：“春节要加这个活动” 后端：“这个先找前端改个模板” 前端：“模板做完了” 后端：“我来对接一下，这里样式不对” 前端：“我改完了” 后端：“功能交付” 变成 PM：“我要这个功能” 前端：“我要接口” 后端：“接口完成了” 前端：“我来对接一下，功能交付” PM：“春节要加这个活动” 前端：“需要增加接口” 后端：“接口完成了” 前端：“我来对接一下，功能交付” 由此可见，前后端分离的主要概念就是：后台只需提供API接口，前端调用AJAX实现数据呈现。 前后端分离的实现对技术人员尤其是前端人员的要求会上升一个层次，前端的工作不只是切页面写模板或是处理一些简单的js逻辑，前端需要处理服务器返回的各种数据格式，还需要掌握一系列的数据处理逻辑、MVVM思想和各种主流前端框架(React, Vue..)。 意义对于前后端分离的意义我们也可以看做是前端渲染的意义，我主要总结了下面四点： 1. 彻底解放前端 前端不再需要向后台提供模板或是后台在前端html中嵌入后台代码，前后端解耦，增加可读性。 2. 提高工作效率，分工更加明确 前后端分离的工作流程可以使前端只关注前端的事，后台只关心后台的活，两者开发可以同时进行，在后台还没有时间提供接口的时候，前端可以先将数据写死或者调用本地的json文件即可，页面的增加和路由的修改也不必再去麻烦后台，开发更加灵活。 3. 局部性能提升 通过前端路由的配置，我们可以实现页面的按需加载，无需一开始加载首页便加载网站的所有的资源，服务器也不再需要解析前端页面，在页面交互及用户体验上有所提升。 4. 降低维护成本 通过目前主流的前端MVVM框架，我们可以非常快速的定位及发现问题的所在，客户端的问题不再需要后台人员参与及调试，代码重构及可维护性增强。 面对快速发展的前端，我们应该去适应其带来的工作方式和流程的改变，目前的前后端分离的工作方式必然是今后的趋势所在，作为一个前端开发人员，我们应当承担这个普及前端新知识和改变现状的职责。 我的Github 好了，装了一大波，溜了溜了。。。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"前端入坑笔记–JavaScript类型检测","date":"2017-03-05T12:29:59.000Z","path":"2017/03/05/前端入坑笔记–JavaScript类型检测/","text":"JavaScript变量可以用来保存两种类型的值：基本类型值和引用类型值 5种基本数据类型：String Number Boolean Undefined Null 引用类型：Object Array Data RegExp Function Error Map … ES6引入了一种新的原始数据类型Symbol，表示独一无二的值 一、typeof typeof 用来判断各种数据类型,有两种写法：typeof xxx, typeof(xxx) 123456789101112131415161718var a = 'hzzly';var b = true;var c = 22;var d;var e = null;var o = new Object();var f = function () &#123;&#125;console.log( typeof a ); //stringconsole.log( typeof b ); //booleanconsole.log( typeof c ); //numberconsole.log( typeof d ); //undefinedconsole.log( typeof e ); //objectconsole.log( typeof o ); //objectconsole.log( typeof f ); //functionconsole.log( typeof &#123;&#125; ); //objectconsole.log( typeof [] ); //object 这里面包含了js里面的五种数据类型 number string boolean undefined object和函数类型 function 看到这里你肯定会问了：我怎么去区分对象，数组和null呢? 接下来我们就用到另外两个利器：Object.prototype.toString.call instanceof/constructor 二、Object.prototype.toString.call1234567891011121314151617var gettype=Object.prototype.toStringgettype.call('hzzly') 输出 [object String]gettype.call(22) 输出 [object Number]gettype.call(true) 输出 [object Boolean]gettype.call(undefined) 输出 [object Undefined]gettype.call(null) 输出 [object Null]gettype.call(&#123;&#125;) 输出 [object Object]gettype.call([]) 输出 [object Array]gettype.call(function()&#123;&#125;) 输出 [object Function] 三、instanceof/constructor根据规定，所有引用类型的值都是Object的实例。因此，在检测一个引用类型值和Object 构造函数时，instanceof 操作符始终会返回true。当然，如果使用instanceof 操作符检测基本类型的值，则该操作符始终会返回false，因为基本类型不是对象。 123456789console.log([] instanceof Array); //trueconsole.log(/^$/ instanceof RegExp); //trueconsole.log([] instanceof Object); //trueconsole.log([].constructor === Array); //trueconsole.log([].constructor === Object); //false 我们的constructor可以避免instanceof检测的时候,用Object也是true的问题console.log(&#123;&#125;.constructor === Object); //trueconsole.log(1 instanceof Number); //false 看到这里，刚才的问题我们解决了 检测数组，ECMAScript5新增了Array.isArray() 方法。这个方法的目的是最终确定某个值到底是不是数组，而不管它是在哪个全局执行环境中创建。这个方法的用法如下： 123if( Array.isArray(value) )&#123; //对数组执行某些操作&#125; 四、题外话基本类型值与引用类型值具有如下特点： 基本类型值在内存中占据固定大小的空间，因此被保存在栈内存中 从一个变量向另一个变量复制基本类型的值，会创建这个值得一个副本 引用类型的值是对象，保存在堆内存中 包含引用类型值得变量实际上包含的并不是对象本身，而是一个指向该对象的指针 从一个变量向另一个变量复制引用类型的值，复制的其实是指针，因此两个变量最终都指向同一个对象 好了，遛了遛了。。。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"手把手用Node的socket.io撸一个简单聊天室","date":"2017-03-04T14:51:43.000Z","path":"2017/03/04/手把手用Node的socket.io撸一个简单聊天室/","text":"点击查看效果 Socket.IO用于浏览器与Node.js之间实现实时通信。 Socket.IO设计的目标是支持任何的浏览器，任何Mobile设备。 支持主流的PC浏览器 (IE,Safari,Chrome,Firefox,Opera等)， Mobile浏览器(iphone Safari/ipad Safari/Android WebKit/WebOS WebKit等)。 Socket.IO解决了实时的通信问题，并统一了服务端与客户端的编程方式。 启动了socket以后，就像建立了一条客户端与服务端的管道，两边可以互通有无。 一、初始化一个Express项目通过应用生成器工具 express 可以快速创建一个应用的骨架。 123456789101112// 全局安装express 脚手架$ npm install express-generator -g//在当前工作目录创建一个命名为 chat-node 的应用$ express -e chat-node//安装所有依赖$ cd chat-node $ npm install//启动这个应用（MacOS 或 Linux 平台）：$ npm start 然后在浏览器中打开 http://localhost:3000/ 网址就可以看到这个应用了 二、安装Socket.IO这里使用 npm 安装到项目依赖中 1$ npm install socket.io --save 三、整合Socket.IO到项目中找到服务开启的www文件 根目录 &gt; bin &gt; www 1234567891011121314151617181920212223//在创建服务器(var server = http.createServer(app))之后添加如下代码var io = require('socket.io')(server);// 在线用户var onlineUser = &#123;&#125;;// 在线人数var onlineCount = 0;io.on('connection', (socket) =&gt; &#123; // 监听新用户加入 console.log('a user connected'); socket.on('disconnect', () =&gt; &#123; console.log('user disconnected'); &#125;); //监听post数据加入 socket.on('post', function(say) &#123; io.emit('post', say) //通过io的emit把数据发送到前台 &#125;);&#125;); 通过传递server(HTTP服务器)来初始化socket.io的一个新实例，然后监听连接sockets的connection事件，并将其记录到控制台。 三、修改前台代码在 views 目录下新建一个index.html 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0\"&gt; &lt;title&gt;聊天室&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"chat\" id=\"chatApp\" v-cloak&gt; &lt;ul class=\"room-list\"&gt; &lt;li v-for=\"item in msgList\"&gt; &lt;div class=\"msg-detail\"&gt;&#123;&#123;item&#125;&#125;&lt;/div&gt; &lt;/li&gt; &lt;/ul&gt; &lt;div class=\"send-box\"&gt; &lt;input type=\"text\" placeholder=\"写点什么喃...\" v-model=\"sendMsg\"&gt; &lt;button type=\"button\" @click=\"doSendMsg\"&gt;发送&lt;/button&gt; &lt;/div&gt;&lt;/div&gt;&lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/socket.io/1.7.3/socket.io.min.js\"&gt;&lt;/script&gt;&lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.1.3/vue.js\"&gt;&lt;/script&gt;&lt;script src=\"/javascripts/index.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 我在里面引入了socket.io以及vue(更好的渲染数据) 四、编写业务代码 在 public &gt; javascripts 下新建一个index.js 12345678910111213141516171819202122const socket = io(); //加载socket.io-client会暴露一个全局io并连接。const vue = new Vue(&#123; //实例化一个Vue实例 el: \"#chatApp\", data() &#123; return &#123; //数据驱动 sendMsg: '', msgList: [] &#125; &#125;, mounted() &#123; socket.on('post', (say) =&gt; &#123; //接收服务端的 post 命令 this.msgList.push(say) //添加到msgList中给前台渲染出来 &#125;) &#125;, methods: &#123; doSendMsg() &#123; //监听按钮发送的事件 socket.emit('post', this.sendMsg) //把要发送的数据emit到服务端 this.sendMsg = '' &#125; &#125;&#125;) 五、在对应路由中打开index.html 在 routes &gt; index.js 修改如下代码 1234/* GET home page. */router.get('/', function(req, res, next) &#123; res.sendFile(path.join(__dirname, '../views', 'index.html'));&#125;); 然后在浏览器中打开 http://localhost:3000/ 网址就可以看到这个应用de效果了 Github Demo欢迎star 好了，遛了遛了。。。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"Web的Flex弹性盒模型","date":"2017-03-03T01:24:26.000Z","path":"2017/03/03/Web的Flex弹性盒模型/","text":"一、Flex布局是什么？Flex是Flexible Box的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。任何一个容器都可以指定为Flex布局。 123.box&#123; display: flex;&#125; 行内元素也可以使用Flex布局。 123.box&#123; display: inline-flex;&#125; 二、容器的属性 [ flex-direction ] [ flex-wrap ] [ flex-flow ] [ justify-content ] [ align-self ] [ align-items ] [ align-content ] [ order ] 点击查看实例 下方为简略图 好了，遛了遛了。。。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"博客正式上线","date":"2017-03-02T00:49:45.000Z","path":"2017/03/02/博客正式上线/","text":"折腾了一个晚上，终于把Github Page上的博客搭起来了，有点小激动。哈哈哈，蛋定蛋定。之前一直想弄一个博客来着，偶然间发现了这个基于Node的Hexo博客，还可以放到Github上，很方便。你也可以试一试 (:好了，不扯这么多了，此博客将记录我学习的笔记、知识，并将其中承载的价值传给他人。 整理知识，学习笔记 发布日报，杂文，所见所想 撰写发布技术博客（代码支持） 撰写发布学术论文 1234567891011class Refuel &#123; constructor (refuel) &#123; this.refuel = refuel &#125; refuel () &#123; alert(this.refuel) &#125;&#125;new Refuel('加油！！！'); 好了，遛了遛了。。。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"Hello Hexo","date":"2017-03-01T09:33:06.116Z","path":"2017/03/01/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]