[{"title":"移动端1px的解决方法","date":"2017-03-13T13:22:43.000Z","path":"2017/03/13/移动端1px的解决方法/","text":"在上个项目中，移动端1px问题被困扰了好久，设置1px边框，实际显示2px。以下是我在项目中的解决方法，才疏学浅，轻喷。 关于什么是移动端1像素边框问题，先上两张图，大家就明白了。 假的1px: 真的1px: 原来Retine屏的分辨率始终是普通屏幕的2倍，1px的边框在devicePixelRatio=2的retina屏下会显示成2px。 解决方案 transform: scaleY() 12345678910111213141516171819202122232425262728293031323334&lt;div class=&quot;border-1px&quot;&gt;&lt;/div&gt;&lt;style type=&quot;text/scss&quot;&gt;.border-1px &#123; position: relative; &amp;:after&#123; display: block; position: absolute; left: 0; bottom: 0; width: 100%; border-top: 1px solid #000; content: &apos;&apos;; &#125;&#125;@media (-webkit-min-device-pixel-ratio: 1.5),(min-device-pixel-ratio: 1.5) &#123; .border-1px&#123; &amp;::after&#123; -webkit-transform: scaleY(0.7); transform: scaleY(0.7); &#125; &#125;&#125;@media (-webkit-min-device-pixel-ratio: 2),(min-device-pixel-ratio: 2) &#123; .border-1px&#123; &amp;::after&#123; -webkit-transform: scaleY(0.5); transform: scaleY(0.5); &#125; &#125;&#125;&lt;/style&gt; 到这已经成功解决了1px问题。 好了，吃饭去喽，溜了溜了。。。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"axios在vue中的简单配置与使用","date":"2017-03-12T13:34:08.000Z","path":"2017/03/12/axios在vue中的简单配置与使用/","text":"尤雨溪之前在微博发布消息，不再继续维护vue-resource，并推荐大家使用 axios 开始。 一、axios 简介axios 是一个基于Promise 用于浏览器和 nodejs 的 HTTP 客户端，它本身具有以下特征： 从浏览器中创建 XMLHttpRequest 从 node.js 发出 http 请求 支持 Promise API 拦截请求和响应 转换请求和响应数据 取消请求 自动转换JSON数据 客户端支持防止 CSRF/XSRF 二、引入方式：npm:123$ npm install axios//淘宝源$ cnpm install axios bower:1$ bower install axios cdn:1&lt;script src=\"https://unpkg.com/axios/dist/axios.min.js\"&gt;&lt;/script&gt; 三、vue中axios的配置 之前那个开源项目一开始就打算用axios，在网上找了好多文章与攻略，发现好多都不太详细，所以打算自己动手配置一个，(不要怂，撸起袖子就是干)。 我的配置：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import axios from 'axios'import qs from 'qs'import * as _ from '../util/tool'axios.defaults.timeout = 5000; //响应时间axios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded;charset=UTF-8'; //配置请求头axios.defaults.baseURL = '你的接口地址'; //配置接口地址//POST传参序列化(添加请求拦截器)axios.interceptors.request.use((config) =&gt; &#123; //在发送请求之前做某件事 if(config.method === 'post')&#123; config.data = qs.stringify(config.data); &#125; return config;&#125;,(error) =&gt;&#123; _.toast(\"错误的传参\", 'fail'); return Promise.reject(error);&#125;);//返回状态判断(添加响应拦截器)axios.interceptors.response.use((res) =&gt;&#123; //对响应数据做些事 if(!res.data.success)&#123; // _.toast(res.data.msg); return Promise.reject(res); &#125; return res;&#125;, (error) =&gt; &#123; _.toast(\"网络异常\", 'fail'); return Promise.reject(error);&#125;);//返回一个Promise(发送post请求)export function fetch(url, params) &#123; return new Promise((resolve, reject) =&gt; &#123; axios.post(url, params) .then(response =&gt; &#123; resolve(response.data); &#125;, err =&gt; &#123; reject(err); &#125;) .catch((error) =&gt; &#123; reject(error) &#125;) &#125;)&#125; 四、vue中使用配置好的axios123456789101112131415161718192021export default &#123; /** * 用户登录 */ Login(params) &#123; return fetch('/users/api/userLogin', params) &#125;, /** * 用户注册 */ Regist(params) &#123; return fetch('/users/api/userRegist', params) &#125;, /** * 发送注册验证码 */ RegistVerifiCode(tellphone) &#123; return fetch('/users/api/registVerifiCode', &#123;tellphone: tellphone&#125;) &#125;, ......&#125; 如果觉得还行，欢迎star项目地址： https://github.com/hzzly/xyy-vuedemo地址： http://hjingren.cn/xyy-vue/ 好了，溜了溜了。。。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"开源的收获","date":"2017-03-09T15:57:05.000Z","path":"2017/03/09/开源的收获/","text":"第一次在github上发布了开源《Qu约》后，不到两天，被人star了137次，fork了25次，这个成绩大大出乎了我自己的意料！ Github地址： https://github.com/hzzly/xyy-vuedemo地址： http://hjingren.cn/xyy-vue/欢迎大家的star啦~ 同时也让我收获到了许多： github首次破百 掘金的阅读量与喜欢量同时给他人带来了不一样的价值 segmentfault的阅读量、收藏量与声望值，把其中的价值传给他人 收获了一个offer 给我以后就业增加了一份保证 结交了好多同行开发者 分享与开源，让技术生生不息。借用一本书de名字，Just for fun。开源是一种情怀，happy hacking！ 革命尚未成功，我们还需努力。。。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"进阶vue全家桶","date":"2017-03-08T01:47:54.000Z","path":"2017/03/08/进阶vue全家桶/","text":"有人说只会vue不会vuex还只是个切图仔，所以本项目结合前端Vue2.0全家桶(vue+vue-router+vuex+axios+es6+sass)以及后端Node,一个前后端分离的练手项目。本项目可以作为一个前端vue进阶项目，从前端flex布局到前端vue以及组件分离的使用，再到后端Node以及Leancloud的结合，是一个打通前后端流程的一个项目。欢迎大家前来star。如果有任何问题，可以给我留言，我们互相学习讨论，一起进步。 项目地址： https://github.com/hzzly/xyy-vuedemo地址： http://hjingren.cn/xyy-vue/欢迎大家的star啦~ 功能说明 首页轮播图 首页热门活动 约跑步活动列表 约出行活动列表 个人中心 查看个人活动 学生认证(待开发) 学生信息修改 消息通知(后台接口待开发) 选择高校(待开发) 登录 注册 活动详情 活动报名 活动发布 时间选择组件 地址选择组件 文件上传 axios的封装 …… 公共组件 弹出文字组件 弹出框组件 loading组件 toast组件 时间选择器组件 地址选择器组件 …… 目录结构 123456789101112131415161718192021222324252627282930313233343536373839|——xyy-vue/| |——build/| |——confg/| |——node_modules/| |——src/| | |——assets/ //静态文件| | |——components/ //公共组件| | |——fetch/| | | |——api.js //axios封装与api| | |——pages/ //存放项目页面| | | |——Detail.vue //活动详情页面| | | |——Home.vue //首页| | | |——Login.vue //登录页面| | | |——Navbar.vue //我的发布| | | |——NotFound.vue //出错页面| | | |——Post.vue //发布活动页面| | | |——Regist.vue //注册页面| | | |——Set.vue //设置页面| | | |——Sport.vue //约跑步活动列表页面| | | |——Travel.vue //约出行活动列表页面| | | |——User.vue //个人中心页面| | | |——UserInfo.vue //个人详情页面| | | |——UserMsg.vue //消息列表页面| | |——router/ | | | |——index.js //页面路由| | |——util //公用方法| | |——vuex / //存放vuex代码| | | |——modules / //数据模块| | | |——store.js //vuex主入口| | | |——types.js //vuex的types文件| | |——App.vue //父组件| | |——main.js //入口文件| |——static/| |——.babelrc| |——.editorconfig| |——.gitgnore| |——index.html| |——package.json| |——README.md 主要难点1.各个组件数据的共享 传参的方法对于多层嵌套的组件将会非常繁琐，并且对于兄弟组件间的状态传递无能为力。而且也会导致代码难以维护 解决方法：采用vuex进行状态管理，把所有事件和状态存储在store对象中，在组件中通过计算属性获得事件，因此就有了实时性。 Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。 每一个 Vuex 应用的核心就是 store（仓库）。”store” 基本上就是一个容器，它包含着应用中大部分的状态(state)。 Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。 你不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交(commit) mutations。这样使得我们可以方便地跟踪每一个状态的变化。 代码如下(以一个user module为例)：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566//vuex/modules/user.jsimport api from '../../fetch/api'import * as types from '../types'const state = &#123; // 用户登录状态 loginStatus: JSON.parse(localStorage.getItem('loginStatus')) || false,&#125;const actions = &#123; /** * 用户登录 */ setUserInfo(&#123; commit &#125;, res) &#123; localStorage.setItem('loginStatus', true) commit(types.SET_LOGIN_STATUS, true) &#125;, /** * 退出登录 */ setSignOut(&#123; commit &#125;) &#123; localStorage.removeItem('loginStatus') commit(types.SET_LOGIN_STATUS, false) &#125;,&#125;const getters = &#123; loginStatus: state =&gt; state.loginStatus&#125;const mutations = &#123; [types.SET_LOGIN_STATUS](state, status) &#123; state.loginStatus = status &#125; &#125;export default &#123; state, actions, getters, mutations&#125;//User.vue&lt;template&gt; &lt;div class=\"user\"&gt; &lt;div v-if=\"!loginStatus\"&gt; ... &lt;/div&gt; &lt;div v-else&gt; ... &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; mapGetters &#125; from 'vuex'export default &#123; computed: &#123; ...mapGetters([ 'loginStatus' ]) &#125;&#125;&lt;/script&gt; 2.时间选择组件(要可选择时间段) 规则： 默认值为：开始日期在后天，结束日期在第六天 今天以前不可选择 点击某个日子，则将最近的节点移动过 如果离两个节点一样，则将开始日期移动过去 两个节点也可选到1天里；显示为各一半 一开始打算在github上搜索一个然后直接拿来用，发现都是不符合我的设计，所以打算自己撸一个，(不要怂，撸起袖子就是干)。终于经过几个晚上的奋战写出来了(期间遇到了各种坑)。代码就不贴出来了 代码传送门 总结虽然只是做了个小小的个人项目，但是我感觉收获还是很大的，很多知识点掌握得更加的牢固，对 vue全家桶 的理解又更深了一些。这个项目还没有完成，后期将不定期更新，敬请期待。。 如果觉得还行，欢迎star项目地址： https://github.com/hzzly/xyy-vue 好了，溜了溜了。。。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"webpack工程化","date":"2017-03-07T12:01:48.000Z","path":"2017/03/07/webpack工程化/","text":"一、webpack是什么 webpack is a module bundler. webpack takes modules with dependencies and generates static assets representing those modules webpack 是一个模块打包工具，输入为包含依赖关系的模块集，输出为打包合并的前端静态资源。在上一节的前端工程化中，已经介绍过，webpack 是同时支持 AMD 和 CommonJs 的模块定义方式，不仅如此，webpack 可以将任何前端资源视为模块，如 css，图片，文本。 二、为什么要使用它在 webpack 出现之前，已经有了一些打包工具，如 Browserify、grunt、gulp… 这些打包工具工具功能单一，只能完成特定的任务，然而 web 前端工程是复杂的，一个 webapp 对于业务代码的要求可能有： 代码可以分块，实现按需加载 首屏加载时间要尽量减少 需要集成一些第三方库 webpack 的出现正式为了解决这些问题，在 webpack 中，提供了一下这些功能： 1.代码分块： webpack 有两种类型的模块依赖，一种是同步的，一种是异步的。在打包的过程中可以将代码输出为代码块（chunk），代码块可以实现按需加载。 异步加载的代码块通过分割点（spliting point）来确定。2.Loaders： Webpack 本身只会处理 Javascript，为了实现将其他资源也定义为模块，并转化为 Javascript， Webpack 定义 loaders , 不同的 loader 可以将对应的资源转化为 Javascript 模块。3.智能的模块解析： webpack 可以很容易将第三方库转化为模块集成到项目代码中，模块的依赖可以用表达式的方式（这在其他打包工具中是没有支持的），这种模块依赖叫做动态模块依赖。4.插件系统： webpack 的可定制化在于其插件系统，其本身的很多功能也是通过插件的方式实现，插件系统形成了 webpack 的生态，是的可以使用很多开源的第三方插件。 三、webpack 核心思想1.万物皆模块： 在 webpack 的世界中，除了 Javascript，其他任何资源都可以当做模块的方式引用。2.按需加载： webapp 的优化关键在于代码体积，当应用体积增大，实现代码的按需加载是毕需，这也是 webpack 出现的根本原因。3.可定制化： 任何一个工具都不可能解决所有问题，提供解决方案才是最可行的，webpack 基于可定制化的理念构建，通过插件系统，配置文件，可以实现大型项目的定制需求。 四、安装配置在此之前你应该已经安装了 node.js. 全局安装webapck或webpack-dev-server(开启一个本地服务)12$ npm install webpack -g$ npm install webpack-dev-server -g 在项目中安装webpack和webpack-dev-server12$ npm install webpack --save-dev$ npm install webpack-dev-server --save-dev webpack使用1234567//name.jslet name = 'hzzly'export default name//index.jsimport name from './name'document.getElementById('app').textContent = `hello~$&#123;name&#125;` 1.命令行的使用1$ webpack src/index.js dist/bundle.js 语法：webpack 要打包的文件 打包输出的文件 2.配置文件的使用在项目目录下创建 webpack.config.js如下(简单的配置)：12345678910111213141516171819202122232425262728var webpack = require('webpack')module.exports = &#123; entry: './src/index.js', //入口 output: &#123; path: './dist/', //输出路径 filename: 'bundle.js' //输出文件名 &#125;, module: &#123; loaders: [ &#123; test: /\\.js[x]?$/, exclude: /node_modules/, loader: 'babel-loader', //处理.js或.jsx文件loader query: &#123; presets: ['env'] &#125; &#125;, &#123; test: /\\.css$/, loader: \"style-loader!css-loader\" //处理.css文件loader &#125;, &#123; test: /\\.(png|jpg)$/, loader: 'url-loader?limit=8192' //处理图片loader &#125; ] &#125;&#125; 执行：123$ webpack//或开启本地服务器并实时监听文件变化$ webpack-dev-server --inline --colors --hot Github地址： https://github.com/hzzly/webpack欢迎大家的star啦~ 好了，装了一大波，溜了溜了。。。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"前后端分离的尝试","date":"2017-03-06T02:21:49.000Z","path":"2017/03/06/前后端分离的尝试/","text":"首次尝试前后端分离是在一个外包项目中: 点匠科技 o2o的家装类 移动项目微信平台前端开发主要工作内容是将原有的android、ios 应用 配合后端工程师开发一套 微信产品,个人角色为 前端开发工程师 负责界面 html css vue 前后端数据联调等工作 项目地址(测试账号:15103585135 测试密码:123456) 这次的项目技术栈 vue vue-router vuex weui sass es6 ajax 通过这次项目，让我体会到了这种前后端分离的快感，所以特来分享一波。 如果你没有尝试过前后端分离的工作流程，那么可以先试想一下这样的流程改变： 把流程从 PM：“我要这个功能” 后端：“这个先找前端做个模板” 前端：“模板做完了” 后端：“我来对接一下，这里样式不对” 前端：“我改完了” 后端：“功能交付” PM：“春节要加这个活动” 后端：“这个先找前端改个模板” 前端：“模板做完了” 后端：“我来对接一下，这里样式不对” 前端：“我改完了” 后端：“功能交付” 变成 PM：“我要这个功能” 前端：“我要接口” 后端：“接口完成了” 前端：“我来对接一下，功能交付” PM：“春节要加这个活动” 前端：“需要增加接口” 后端：“接口完成了” 前端：“我来对接一下，功能交付” 由此可见，前后端分离的主要概念就是：后台只需提供API接口，前端调用AJAX实现数据呈现。 前后端分离的实现对技术人员尤其是前端人员的要求会上升一个层次，前端的工作不只是切页面写模板或是处理一些简单的js逻辑，前端需要处理服务器返回的各种数据格式，还需要掌握一系列的数据处理逻辑、MVVM思想和各种主流前端框架(React, Vue..)。 意义对于前后端分离的意义我们也可以看做是前端渲染的意义，我主要总结了下面四点： 1. 彻底解放前端 前端不再需要向后台提供模板或是后台在前端html中嵌入后台代码，前后端解耦，增加可读性。 2. 提高工作效率，分工更加明确 前后端分离的工作流程可以使前端只关注前端的事，后台只关心后台的活，两者开发可以同时进行，在后台还没有时间提供接口的时候，前端可以先将数据写死或者调用本地的json文件即可，页面的增加和路由的修改也不必再去麻烦后台，开发更加灵活。 3. 局部性能提升 通过前端路由的配置，我们可以实现页面的按需加载，无需一开始加载首页便加载网站的所有的资源，服务器也不再需要解析前端页面，在页面交互及用户体验上有所提升。 4. 降低维护成本 通过目前主流的前端MVVM框架，我们可以非常快速的定位及发现问题的所在，客户端的问题不再需要后台人员参与及调试，代码重构及可维护性增强。 面对快速发展的前端，我们应该去适应其带来的工作方式和流程的改变，目前的前后端分离的工作方式必然是今后的趋势所在，作为一个前端开发人员，我们应当承担这个普及前端新知识和改变现状的职责。 我的Github 好了，装了一大波，溜了溜了。。。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"前端入坑笔记–JavaScript类型检测","date":"2017-03-05T12:29:59.000Z","path":"2017/03/05/前端入坑笔记–JavaScript类型检测/","text":"JavaScript变量可以用来保存两种类型的值：基本类型值和引用类型值 5种基本数据类型：String Number Boolean Undefined Null 引用类型：Object Array Data RegExp Function Error Map … ES6引入了一种新的原始数据类型Symbol，表示独一无二的值 一、typeof typeof 用来判断各种数据类型,有两种写法：typeof xxx, typeof(xxx) 123456789101112131415161718var a = 'hzzly';var b = true;var c = 22;var d;var e = null;var o = new Object();var f = function () &#123;&#125;console.log( typeof a ); //stringconsole.log( typeof b ); //booleanconsole.log( typeof c ); //numberconsole.log( typeof d ); //undefinedconsole.log( typeof e ); //objectconsole.log( typeof o ); //objectconsole.log( typeof f ); //functionconsole.log( typeof &#123;&#125; ); //objectconsole.log( typeof [] ); //object 这里面包含了js里面的五种数据类型 number string boolean undefined object和函数类型 function 看到这里你肯定会问了：我怎么去区分对象，数组和null呢? 接下来我们就用到另外两个利器：Object.prototype.toString.call instanceof/constructor 二、Object.prototype.toString.call1234567891011121314151617var gettype=Object.prototype.toStringgettype.call('hzzly') 输出 [object String]gettype.call(22) 输出 [object Number]gettype.call(true) 输出 [object Boolean]gettype.call(undefined) 输出 [object Undefined]gettype.call(null) 输出 [object Null]gettype.call(&#123;&#125;) 输出 [object Object]gettype.call([]) 输出 [object Array]gettype.call(function()&#123;&#125;) 输出 [object Function] 三、instanceof/constructor根据规定，所有引用类型的值都是Object的实例。因此，在检测一个引用类型值和Object 构造函数时，instanceof 操作符始终会返回true。当然，如果使用instanceof 操作符检测基本类型的值，则该操作符始终会返回false，因为基本类型不是对象。 123456789console.log([] instanceof Array); //trueconsole.log(/^$/ instanceof RegExp); //trueconsole.log([] instanceof Object); //trueconsole.log([].constructor === Array); //trueconsole.log([].constructor === Object); //false 我们的constructor可以避免instanceof检测的时候,用Object也是true的问题console.log(&#123;&#125;.constructor === Object); //trueconsole.log(1 instanceof Number); //false 看到这里，刚才的问题我们解决了 检测数组，ECMAScript5新增了Array.isArray() 方法。这个方法的目的是最终确定某个值到底是不是数组，而不管它是在哪个全局执行环境中创建。这个方法的用法如下： 123if( Array.isArray(value) )&#123; //对数组执行某些操作&#125; 四、题外话基本类型值与引用类型值具有如下特点： 基本类型值在内存中占据固定大小的空间，因此被保存在栈内存中 从一个变量向另一个变量复制基本类型的值，会创建这个值得一个副本 引用类型的值是对象，保存在堆内存中 包含引用类型值得变量实际上包含的并不是对象本身，而是一个指向该对象的指针 从一个变量向另一个变量复制引用类型的值，复制的其实是指针，因此两个变量最终都指向同一个对象 好了，遛了遛了。。。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"手把手用Node的socket.io撸一个简单聊天室","date":"2017-03-04T14:51:43.000Z","path":"2017/03/04/手把手用Node的socket.io撸一个简单聊天室/","text":"点击查看效果 Socket.IO用于浏览器与Node.js之间实现实时通信。 Socket.IO设计的目标是支持任何的浏览器，任何Mobile设备。 支持主流的PC浏览器 (IE,Safari,Chrome,Firefox,Opera等)， Mobile浏览器(iphone Safari/ipad Safari/Android WebKit/WebOS WebKit等)。 Socket.IO解决了实时的通信问题，并统一了服务端与客户端的编程方式。 启动了socket以后，就像建立了一条客户端与服务端的管道，两边可以互通有无。 一、初始化一个Express项目通过应用生成器工具 express 可以快速创建一个应用的骨架。 123456789101112// 全局安装express 脚手架$ npm install express-generator -g//在当前工作目录创建一个命名为 chat-node 的应用$ express -e chat-node//安装所有依赖$ cd chat-node $ npm install//启动这个应用（MacOS 或 Linux 平台）：$ npm start 然后在浏览器中打开 http://localhost:3000/ 网址就可以看到这个应用了 二、安装Socket.IO这里使用 npm 安装到项目依赖中 1$ npm install socket.io --save 三、整合Socket.IO到项目中找到服务开启的www文件 根目录 &gt; bin &gt; www 1234567891011121314151617181920212223//在创建服务器(var server = http.createServer(app))之后添加如下代码var io = require('socket.io')(server);// 在线用户var onlineUser = &#123;&#125;;// 在线人数var onlineCount = 0;io.on('connection', (socket) =&gt; &#123; // 监听新用户加入 console.log('a user connected'); socket.on('disconnect', () =&gt; &#123; console.log('user disconnected'); &#125;); //监听post数据加入 socket.on('post', function(say) &#123; io.emit('post', say) //通过io的emit把数据发送到前台 &#125;);&#125;); 通过传递server(HTTP服务器)来初始化socket.io的一个新实例，然后监听连接sockets的connection事件，并将其记录到控制台。 三、修改前台代码在 views 目录下新建一个index.html 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0\"&gt; &lt;title&gt;聊天室&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"chat\" id=\"chatApp\" v-cloak&gt; &lt;ul class=\"room-list\"&gt; &lt;li v-for=\"item in msgList\"&gt; &lt;div class=\"msg-detail\"&gt;&#123;&#123;item&#125;&#125;&lt;/div&gt; &lt;/li&gt; &lt;/ul&gt; &lt;div class=\"send-box\"&gt; &lt;input type=\"text\" placeholder=\"写点什么喃...\" v-model=\"sendMsg\"&gt; &lt;button type=\"button\" @click=\"doSendMsg\"&gt;发送&lt;/button&gt; &lt;/div&gt;&lt;/div&gt;&lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/socket.io/1.7.3/socket.io.min.js\"&gt;&lt;/script&gt;&lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.1.3/vue.js\"&gt;&lt;/script&gt;&lt;script src=\"/javascripts/index.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 我在里面引入了socket.io以及vue(更好的渲染数据) 四、编写业务代码 在 public &gt; javascripts 下新建一个index.js 12345678910111213141516171819202122const socket = io(); //加载socket.io-client会暴露一个全局io并连接。const vue = new Vue(&#123; //实例化一个Vue实例 el: \"#chatApp\", data() &#123; return &#123; //数据驱动 sendMsg: '', msgList: [] &#125; &#125;, mounted() &#123; socket.on('post', (say) =&gt; &#123; //接收服务端的 post 命令 this.msgList.push(say) //添加到msgList中给前台渲染出来 &#125;) &#125;, methods: &#123; doSendMsg() &#123; //监听按钮发送的事件 socket.emit('post', this.sendMsg) //把要发送的数据emit到服务端 this.sendMsg = '' &#125; &#125;&#125;) 五、在对应路由中打开index.html 在 routes &gt; index.js 修改如下代码 1234/* GET home page. */router.get('/', function(req, res, next) &#123; res.sendFile(path.join(__dirname, '../views', 'index.html'));&#125;); 然后在浏览器中打开 http://localhost:3000/ 网址就可以看到这个应用de效果了 Github Demo欢迎star 好了，遛了遛了。。。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"Web的Flex弹性盒模型","date":"2017-03-03T01:24:26.000Z","path":"2017/03/03/Web的Flex弹性盒模型/","text":"一、Flex布局是什么？Flex是Flexible Box的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。任何一个容器都可以指定为Flex布局。 123.box&#123; display: flex;&#125; 行内元素也可以使用Flex布局。 123.box&#123; display: inline-flex;&#125; 二、容器的属性 [ flex-direction ] [ flex-wrap ] [ flex-flow ] [ justify-content ] [ align-self ] [ align-items ] [ align-content ] [ order ] 点击查看实例 下方为简略图 好了，遛了遛了。。。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"博客正式上线","date":"2017-03-02T00:49:45.000Z","path":"2017/03/02/博客正式上线/","text":"折腾了一个晚上，终于把Github Page上的博客搭起来了，有点小激动。哈哈哈，蛋定蛋定。之前一直想弄一个博客来着，偶然间发现了这个基于Node的Hexo博客，还可以放到Github上，很方便。你也可以试一试 (:好了，不扯这么多了，此博客将记录我学习的笔记、知识，并将其中承载的价值传给他人。 整理知识，学习笔记 发布日报，杂文，所见所想 撰写发布技术博客（代码支持） 撰写发布学术论文 1234567891011class Refuel &#123; constructor (refuel) &#123; this.refuel = refuel &#125; refuel () &#123; alert(this.refuel) &#125;&#125;new Refuel('加油！！！'); 好了，遛了遛了。。。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"Hello Hexo","date":"2017-03-01T09:33:06.116Z","path":"2017/03/01/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]