[{"title":"动手搭建react开发环境二","date":"2019-07-12T01:31:10.000Z","path":"2019/07/12/动手搭建react开发环境二/","text":"版本 webpack 4 Babel 7 本篇主要使用针对上篇的webpack配置进行优化 快速浏览： webpack基础篇 webpack优化1、抽取css（MiniCssExtractPlugin）为每个引入 CSS 的 JS 文件创建一个 CSS 文件，提高首页加载速度 把 style-loader 替换成 MiniCssExtractPlugin.loader 新增 plugins 1yarn add mini-css-extract-plugin -D 1234567891011121314151617181920212223const MiniCssExtractPlugin = require('mini-css-extract-plugin'); module.exports = &#123; //...同上 module: &#123; rules: [ &#123; test: /\\.(sc|sa|c)ss$/, use: [ // 'style-loader', MiniCssExtractPlugin.loader, // ...同上 ], &#125;, ], &#125;, plugins: [ new MiniCssExtractPlugin(&#123; filename: '[name].[hash].css', chunkFilename: '[id].[hash].css', &#125;), ]&#125; 2、压缩CSS（OptimizeCssAssetsWebpackPlugin）1yarn add optimize-css-assets-webpack-plugin -D 12345678const OptimizeCssAssetsWebpackPlugin = require('optimize-css-assets-webpack-plugin'); module.exports = &#123; //...同上 plugins: [ new OptimizeCssAssetsWebpackPlugin(), ]&#125; 3、压缩JSwebpack 4只要在生产模式下， 代码就会自动压缩1mode: 'production', 4、代码分割（SplitChunksPlugin）代码分割，单独打包，可以有效避免所有页面只生成一个js文件，首屏加载很慢的情况。 1234567891011121314151617181920212223242526module.exports = &#123; //... optimization: &#123; splitChunks: &#123; chunks: 'all', // include all types of chunks // minSize: 30000, // 引入的库大于30kb时才会做代码分割 // minChunks: 1, // 一个模块至少被用了1次才会被分割 // maxAsyncRequests: 5, // 同时异步加载的模块数最多是5个，如果超过5个则不做代码分割 // maxInitialRequests: 3, // 入口文件进行加载时，引入的库最多分割出3个js文件 // automaticNameDelimiter: '~', // 生成文件名的文件链接符 // name: true, // 开启自定义名称效果 // cacheGroups: &#123; // 判断分割出的代码放到那里去 // vendors: &#123; // 配合chunks：‘all’使用，表示如果引入的库是在node-modules中，那就会把这个库分割出来并起名为vendors.js // test: /[\\/]node_modules[\\/]/, // priority: -10, // filename: 'vendors.js' // &#125;, // default: &#123; // 为非node-modules库中分割出的代码设置默认存放名称 // priority: -20, // reuseExistingChunk: true, // 避免被重复打包分割 // filename: 'common.js' // &#125; // &#125; &#125; &#125;&#125;; 5、配置全局变量12345678910const webpack = require(\"webpack\"); module.exports = &#123; //...同上 plugins: [ new webpack.DefinePlugin(&#123; 'process.env.NODE_ENV': JSON.stringify('development'), &#125;), ]&#125; 🔥Tip1 问题：当用 DefinePlugin 来配置全局变量时，只给依赖中注入了环境变量，也就是src文件夹下面的和依赖的模块。当我们在webpack配置文件中去取 process.env.NODE_ENV 依然是 undefined。 解决：在package.json命令中注入123\"scripts\": &#123; \"start\": \"webpack-dev-server NODE_ENV=development --config ./build/webpack.config.js\",&#125; 6、CSS Tree Shaking去除项目代码中用不到的 CSS 样式，仅保留被使用的样式代码 🔥Tip2 问题：当使用 CSS Tree Shaking 的时候，需要把 css-modules 关闭，不然 css 会被全部清除掉。1yarn add glob-all purify-css purifycss-webpack -D 123456789101112131415const PurifyCSS = require(\"purifycss-webpack\");const glob = require(\"glob-all\");module.exports = &#123; //...同上 plugins: [ new PurifyCSS(&#123; paths: glob.sync([ // 要做CSS Tree Shaking的路径文件 path.resolve(__dirname, \"../public/*.html\"), // 请注意，我们同样需要对 html 文件进行 tree shaking path.resolve(__dirname, \"../src/*.js\") ]) &#125;) ]&#125; 7、JS Tree Shaking清除到代码中无用的js代码，只支持import方式引入，不支持commonjs的方式引入 webpack 4只要在生产模式下， tree shaking就会生效。 8、resolve（解析）能设置模块如何被解析。 extension: 指定extension之后可以不用在require或是import的时候加文件扩展名,会依次尝试添加扩展名进行匹配 alias: 配置别名可以加快webpack查找模块的速度 123456789module.exports = &#123; //...同上 resolve: &#123; extensions: ['.js', '.jsx'], alias: &#123; '@': path.join(__dirname, '../src'), &#125;, &#125;,&#125; 9、模块热替换HMR模块热替换也称为HMR，代码更新时只会更新被修改部分都显示。有如下有点 针对于样式调试更加方便 只会更新被修改代码的那部分显示，提升开发效率 保留在完全重新加载页面时丢失的应用程序状态。 这里我们采用Node.js的方式实现 1234yarn add express webpack-dev-middleware webpack-hot-middleware react-hot-loader cross-env -D cd buildtouch dev-server.js 1234567891011121314151617181920212223242526272829303132// dev-server.jsconst path = require('path');const express = require('express');const webpack = require('webpack');const webpackDevMiddleware = require('webpack-dev-middleware');const webpackHotMiddleware = require(\"webpack-hot-middleware\")const config = require('./webpack.config.js'); const complier = webpack(config); // 编译器，编译器执行一次就会重新打包一下代码const app = express(); // 生成一个实例const DIST_DIR = path.resolve(__dirname, '../', 'dist'); // 设置静态访问文件路径const port = parseInt(process.env.PORT, 10) || 8586;const host = process.env.HOST || 'localhost'; const devMiddleware = webpackDevMiddleware(complier, &#123; quiet: true, noInfo: true, stats: 'minimal'&#125;)const hotMiddleware = webpackHotMiddleware(complier, &#123; log: false, heartbeat: 2000&#125;) app.use(devMiddleware)app.use(hotMiddleware)// 设置访问静态文件的路径app.use(express.static(DIST_DIR))app.listen(port, () =&gt; &#123; console.log(`App running at: http://$&#123;host&#125;:$&#123;port&#125;`);&#125;) //监听端口 修改webpack.config.js123456789101112131415161718192021222324252627282930313233343536// webpack.config.jsconst isDev = process.env.NODE_ENV === 'development'; module.exports = &#123; entry: &#123; main: [ 'webpack-hot-middleware/client?noInfo=true&amp;reload=true', './src/index.js' ] &#125;, module: &#123; rules: [ &#123; test: /\\.(sc|sa|c)ss$/, use: [ isDev ? 'style-loader' : MiniCssExtractPlugin.loader, &#123; loader: 'css-loader', options: &#123; modules: &#123; localIdentName: '[local]_[hash:base64:5]', &#125;, sourceMap: !isDev &amp;&amp; true, // 开发时刷新会导致闪屏（样式加载慢一步） &#125;, &#125;, 'postcss-loader', // 使用 postcss 为 css 加上浏览器前缀 'sass-loader', // 编译scss ], &#125;, ], &#125;, plugins: [ new webpack.NamedModulesPlugin(), // 用于启动HMR时可以显示模块的相对路径 new webpack.HotModuleReplacementPlugin(), // 开启HMR(热替换功能,替换更新部分,不重载页面！) 相当于在命令行加 --hot ]&#125; 修改入口文件index.js123456789101112131415161718192021222324252627// index.jsimport React from 'react';import ReactDOM from 'react-dom';import &#123; AppContainer &#125; from 'react-hot-loader';import &#123; BrowserRouter &#125; from 'react-router-dom';import Router from './router';function render() &#123; ReactDOM.render( &lt;AppContainer&gt; &lt;BrowserRouter&gt; &lt;Router /&gt; &lt;/BrowserRouter&gt; &lt;/AppContainer&gt;, document.getElementById('root') );&#125;/* 初始化 */render();/* 热更新 */if (module.hot) &#123; module.hot.accept('./router/index.js', () =&gt; &#123; render(); &#125;);&#125; 修改script命令行1\"start\": \"cross-env NODE_ENV=development node ./build/dev-server.js\", ok，当我们修改代码时，页面就不需要刷新了，而是直接更新变化的部分。 10、BundleAnalyzerPlugin使用交互式可缩放树形图可视化webpack输出文件的大小，可以方便我们针对代码依赖的大小进行优化。 1yarn add webpack-bundle-analyzer -D 12345678910111213141516171819const BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin;module.exports = &#123; //...同上 plugins: [ new BundleAnalyzerPlugin(&#123; analyzerMode: 'server', analyzerHost: '127.0.0.1', analyzerPort: 8889, reportFilename: 'report.html', defaultSizes: 'parsed', openAnalyzer: true, generateStatsFile: false, statsFilename: 'stats.json', statsOptions: null, logLevel: 'info' &#125;) ]&#125; 123456// package.json&#123; \"script\": &#123; \"analyz\": \"cross-env NODE_ENV=production npm_config_report=true npm run build\" &#125;&#125; webpack分离配置文件针对开发环境和发布环境配置对应的webpack，公共的部分提取出来，再使用 webpack-merge 来将不同环境下的配置合并起来 123456cd buildtouch webpack.base.conf.jstouch webpack.dev.conf.jstouch webpack.prd.conf.js yarn add webpack-merge -D 1、提取公共配置1234567891011121314151617181920212223242526272829303132333435363738// webpack.base.conf.jsconst path = require('path');const HtmlWebpackPlugin = require('html-webpack-plugin');const &#123; CleanWebpackPlugin &#125; = require('clean-webpack-plugin');const MiniCssExtractPlugin = require('mini-css-extract-plugin');const isDev = process.env.NODE_ENV === 'development';module.exports = &#123; entry: ['./src/index.js'], output: &#123; // 输出目录 path: path.resolve(__dirname, '../dist'), &#125;, module: &#123; // ...同webpack.config.js的modules &#125;, plugins: [ new CleanWebpackPlugin(), new HtmlWebpackPlugin(&#123; filename: 'index.html', // 最终创建的文件名 template: path.join(__dirname, '../public/index.html'), // 指定模板路径 &#125;), ], resolve: &#123; extensions: ['.js', '.jsx'], alias: &#123; '@': path.join(__dirname, '../src'), &#125;, &#125;, optimization: &#123; splitChunks: &#123; // 代码分割按需加载、提取公共代码 chunks: 'all', // 所有的 chunks 代码公共的部分分离出来成为一个单独的文件 &#125;, &#125;, performance: false, // 关闭性能提示&#125;; 2、配置开发环境123456789101112131415161718192021222324252627282930313233343536373839404142// webpack.dev.conf.jsconst path = require(\"path\");const webpack = require(\"webpack\");const merge = require('webpack-merge');const commonConfig = require('./webpack.base.conf.js');module.exports = merge(commonConfig, &#123; mode: \"development\", devtool: 'cheap-module-eval-soure-map', entry: &#123; //实现刷新浏览器webpack-hot-middleware/client?noInfo=true&amp;reload=true 是必填的 main: [ 'webpack-hot-middleware/client?noInfo=true&amp;reload=true', './src/index.js' ] &#125;, output: &#123; // 输出目录 path: path.resolve(__dirname, \"../dist\"), // 文件名称 filename: \"bundle.[name].[hash].js\", chunkFilename: '[name].[hash].js' &#125;, plugins: [ new webpack.NamedModulesPlugin(), new webpack.HotModuleReplacementPlugin(), // new webpack.DefinePlugin(&#123; // 'process.env.NODE_ENV': JSON.stringify('development'), // &#125;), ], devServer: &#123; hot: true, contentBase: path.resolve(__dirname, \"../dist\"), host: \"localhost\", port: 8586, historyApiFallback: true, // 该选项的作用所有的404都连接到index.html proxy: &#123; // 代理到后端的服务地址 // \"/api\": \"http://localhost:3000\" &#125; &#125;&#125;); 3、配置发布环境123456789101112131415161718192021222324252627282930313233343536373839// webpack.prd.conf.jsconst path = require('path');const merge = require('webpack-merge');const commonConfig = require('./webpack.base.conf.js');module.exports = merge(commonConfig, &#123; mode: 'production', devtool: 'cheap-module-source-map', output: &#123; publicPath: '/', // 打包路径 // 输出目录 path: path.resolve(__dirname, '../dist'), // 文件名称 filename: 'bundle.[name].[hash].js', chunkFilename: '[name].[hash].js', &#125;, optimization: &#123; usedExports: true, splitChunks: &#123; chunks: 'all', // 所有的 chunks 代码公共的部分分离出来成为一个单独的文件 cacheGroups: &#123; // 公共代码打包分组配置 vendors: &#123; test: /[\\\\/]node_modules[\\\\/]/, name: 'vendors', &#125;, &#125;, &#125;, &#125;, plugins: [ new MiniCssExtractPlugin(&#123; filename: '[name].[hash].css', chunkFilename: '[id].[hash].css', &#125;), // new webpack.DefinePlugin(&#123; // 'process.env.NODE_ENV': JSON.stringify('production'), // &#125;), ],&#125;); 4、修改script命令行12\"start\": \"cross-env NODE_ENV=development node ./build/dev-server.js\",\"build\": \"cross-env NODE_ENV=production webpack --config ./build/webpack.prod.conf.js\", 写到这里，一个基本的React开发环境也就搭起来了，接下来就可以针对代码或者开发效率进行优化。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"},{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"},{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"动手搭建react开发环境一","date":"2019-07-11T01:42:50.000Z","path":"2019/07/11/动手搭建react开发环境一/","text":"前言：接触webpack从在学校的那会起，也一直在使用它，用的都是别人封装好的，偶尔去修改一点点配置，也没有真正自己从零开始配置一个脚手架，接下来几篇将记录我对webpack以及开发中提升效率的配置，其中遇到的一些坑也会提示出来。 版本 webpack 4 Babel 7 本篇主要使用webpack搭建基础的React环境 快速浏览： webpack优化篇 webpack核心概念 entry: 入口起点 output: 输出 module: 模块，webpack中一切皆是模块 loader: 转换工具，webpack 只能理解 JavaScript 和 JSON 文件。loader 让 webpack 能够去处理其他类型的文件，并将它们转换为有效模块，以供应用程序使用，以及被添加到依赖图中 plugin: 扩展插件，loader 用于转换某些类型的模块，而插件则可以用于执行范围更广的任务，在webpack构建流程中的特定时机注入扩展逻辑来改变构建结果或做你想要做的事情，比如：打包优化，资源管理，注入环境变量等等 mode: webpac的打包环境[development, production] chunk: 代码库，一个chunk由十多个模块组合而成，用于代码合并与分割 基础配置1、初始化项目1234567mkdir webpack-templatecd webpack-templatemkdir srcmkdir publicmkdir buildmkdir distnpm init -y 2、安装webpack123yarn add webpack webpack-cli -Dcd buildtouch webpack.config.js 12345678910111213141516// 简单的webpack配置// webpack.config.js初始化内容const path = require('path'); module.exports = &#123; mode: \"development\", // 指定环境 entry: [\"./src/index.js\"], // 打包入口文件 output: &#123; // 输出目录 path: path.resolve(__dirname, \"../dist\"), // 文件名称 filename: \"bundle.js\" &#125;, // 打包输出到 dist/bundle.js. module:&#123;&#125;, plugins:[]&#125; package.json更改123\"scripts\": &#123; \"start\": \"webpack --config ./build/webpack.config.js\"&#125;, 3、HtmlWebpackPlugin将打包的js自动插入到 index.html 里面去。123yarn add html-webpack-plugin -Dcd publictouch index.html 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Webpack Template&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"root\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011const HtmlWebpackPlugin = require('html-webpack-plugin'); module.exports = &#123; //...同上 plugins:[ new HtmlWebpackPlugin(&#123; filename: 'index.html', // 最终创建的文件名 template: path.join(__dirname, '../public/index.html'), // 指定模板路径 &#125;), ]&#125; 4、配置转义ES6/ES7/JSX1yarn add babel-loader @babel/core @babel/preset-env @babel/preset-react @babel/plugin-transform-runtime @babel/plugin-proposal-class-properties -D 123456789101112module.exports = &#123; //...同上 module: &#123; rules: [ &#123; test: /\\.(js|jsx)$/, exclude: /node_modules/, use: 'babel-loader', &#125; ], &#125;,&#125; 新建.babelrc文件1234&#123; \"presets\": [\"@babel/preset-env\", \"@babel/preset-react\"], \"plugins\": [\"@babel/plugin-transform-runtime\", \"@babel/plugin-proposal-class-properties\"]&#125; 🔥Tip1 问题：Support for the experimental syntax ‘classProperties’ isn’t currently enabled yarn add @babel/plugin-proposal-class-properties 并在plugins中配置 5、配置转义Typescript1yarn add typescript ts-loader -D 123456789101112module.exports = &#123; //...同上 module: &#123; rules: [ &#123; test: /\\.tsx?$/, exclude: /node_modules/, loader: \"ts-loader\" &#125; ], &#125;,&#125; 新建tsconfig.json123456789101112131415161718192021222324252627282930&#123; \"compilerOptions\": &#123; \"baseUrl\": \".\", \"rootDir\": \".\", \"outDir\": \"dist\", \"module\": \"esnext\", // 模块引入的方式 \"target\": \"es6\", // 转换为es6 \"lib\": [\"dom\", \"es7\"], \"jsx\": \"preserve\", \"moduleResolution\": \"node\", \"sourceMap\": true, \"allowJs\": true, // 在typescript中允许引入js文件 \"forceConsistentCasingInFileNames\": true, \"noImplicitReturns\": true, \"noImplicitThis\": true, \"noImplicitAny\": true, \"noUnusedLocals\": true, \"noUnusedParameters\": true, \"strictNullChecks\": true, \"importHelpers\": true, \"suppressImplicitAnyIndexErrors\": true, \"experimentalDecorators\": true, \"downlevelIteration\": true, \"allowSyntheticDefaultImports\": true, \"paths\": &#123; \"@/*\": [\"src/*\"] &#125; &#125;, \"exclude\": [\"node_modules\", \"dist\", \"build\", \"mock\"]&#125; 6、CleanWebpackPlugin清除 dist 目录下旧版本文件。1yarn add clean-webpack-plugin -D 123456789const &#123; CleanWebpackPlugin &#125; = require('clean-webpack-plugin'); module.exports = &#123; //...同上 plugins:[ //...同上 new CleanWebpackPlugin() ]&#125; 7、source-map可以帮助我们定位到错误信息位置的文件12devtool: \"cheap-module-eval-source-map\", // developmentdevtool: \"cheap-module-source-map\", // production 8、WebpackDevServerwebpack在本地为搭建了一个静态文件服务器，实时打包重加载修改的代码。 1yarn add webpack-dev-server -D 1234567891011121314module.exports = &#123; //...同上 devServer: &#123; hot: true, contentBase: path.resolve(__dirname, \"../dist\"), host: \"localhost\", port: 8586, historyApiFallback: true, // 该选项的作用所有的404都连接到index.html proxy: &#123; // 代理到后端的服务地址 // \"/api\": \"http://localhost:3000\" &#125; &#125;&#125; 修改package.json命令1234// package.json\"scripts\": &#123; \"start\": \"webpack-dev-server --config ./build/webpack.config.js\",&#125;, 9、编译css和scss并使用css-modules1yarn add css-loader style-loader sass-loader node-sass -D 1234567891011121314151617181920212223module.exports = &#123; //...同上 module: &#123; rules: [ &#123; test: /\\.(sc|sa|c)ss$/, use: [ 'style-loader', &#123; loader: 'css-loader', options: &#123; modules: &#123; localIdentName: '[local]_[hash:base64:5]', &#125;, // sourceMap: !isDev &amp;&amp; true, &#125;, &#125;, 'sass-loader', // 编译scss ], &#125;, ], &#125;,&#125; 🔥Tip2 问题：当在 css-loader 配置上 sourceMap 时，配合热加载样式会闪屏 sourceMap: !isDev &amp;&amp; true, 10、集成postcss为css某些特性自动增加前缀，并做一些兼容处理。 1yarn add postcss-loader postcss-preset-env -D 123456789101112131415module.exports = &#123; //...同上 module: &#123; rules: [ &#123; test: /\\.(sc|sa|c)ss$/, use: [ //...同上 'postcss-loader', // 使用 postcss 为 css 加上浏览器前缀 'sass-loader', ], &#125;, ], &#125;,&#125; 新建postcss.config.js文件123456module.exports = &#123; loader: 'postcss-loader', plugins: &#123; 'postcss-preset-env': &#123;&#125;, &#125;&#125; 新建.browserlistrc文件12341% in CNandroid &gt;= 4.4ios &gt;= 8not ie &lt;= 11 11、图片处理123yarn add file-loader url-loader -D# file-loader 解决css等文件中引入图片路径的问题# url-loader 当图片较小的时候会把图片BASE64编码，大于limit参数的时候还是使用file-loader 进行拷贝 1234567891011121314151617module.exports = &#123; //...同上 module: &#123; rules: [ &#123; test: /\\.(png|jpg|jpeg|gif|svg)/, use: &#123; loader: 'url-loader', options: &#123; outputPath: 'images/', limit: 10 * 1024, &#125;, &#125;, &#125;, ], &#125;,&#125; 12、字体文件处理123456789101112131415161718192021module.exports = &#123; //...同上 module: &#123; rules: [ &#123; test: /\\.(eot|woff2?|ttf|svg)$/, use: [ &#123; loader: 'url-loader', options: &#123; name: '[name]-[hash:5].min.[ext]', limit: 5000, publicPath: 'fonts/', outputPath: 'fonts/', &#125;, &#125;, ], &#125;, ], &#125;,&#125; 到这里，webpack的基本配置我们已经准备的差不多了，赶紧写点react来试试水。 测试React环境1yarn add react react-dom react-router react-router-dom 123456789101112131415161718// src/index.jsimport React, &#123; PureComponent &#125; from 'react';import ReactDOM from 'react-dom'; export default class App extends PureComponent &#123; render() &#123; return ( &lt;div&gt; hello word~ &lt;/div&gt; ) &#125;&#125; ReactDOM.render( &lt;App /&gt;, document.getElementById('root')); 执行 npm start ，如果页面上能正常显示 hello word~ 那表示我们的webapck基础配置成功。 第一篇webpack基础配置到此结束了，下一篇对webpack进行优化配置。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"},{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"},{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"Nginx下升级https","date":"2019-06-11T07:26:49.000Z","path":"2019/06/11/Nginx下升级https/","text":"购买证书可以去阿里云的云盾证书服务购买 下载证书在证书控制台下载 Nginx 版本证书。下载到本地的压缩文件包解压后包含： .pem文件：证书文件 .key文件：证书的私钥文件（申请证书时如果没有选择自动创建CSR，则没有该文件） 配置Nginx1、在 Nginx 的安装目录下创建 cert 目录，并且将下载的全部文件拷贝到 cert 目录中，如果申请证书时是自己创建的CSR文件，请将对应的私钥文件放到 cert 目录下。 2、打开 Nginx 安装目录下 conf 目录中的 nginx.conf 文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#user nobody;worker_processes 1;#error_log logs/error.log;#error_log logs/error.log notice;#error_log logs/error.log info;#pid logs/nginx.pid;events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application/octet-stream; #log_format main '$remote_addr - $remote_user [$time_local] \"$request\" ' # '$status $body_bytes_sent \"$http_referer\" ' # '\"$http_user_agent\" \"$http_x_forwarded_for\"'; #access_log logs/access.log main; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; gzip on; #开启gzip gzip_min_length 1k; #低于1kb的资源不压缩 gzip_comp_level 3; #压缩级别【1-9】，越大压缩率越高，同时消耗cpu资源也越多，建议设置在4左右。 gzip_types text/plain application/javascript application/x-javascript text/javascript text/xml text/css; #需要压缩哪些响应类型的资源，多个空格隔开。不建议压缩图片，下面会讲为什么。 gzip_disable \"MSIE [1-6]\\.\"; #配置禁用gzip条件，支持正则。此处表示ie6及以下不启用gzip（因为ie低版本不支持） gzip_vary on; #是否添加“Vary: Accept-Encoding”响应头 server &#123; listen 80 default backlog=2048; #配置http可用 listen 443 ssl; #配置https server_name localhost; ssl_certificate ../cert/hzzly.pem; #配置证书文件 ssl_certificate_key ../cert/hzzly.key; #配置私钥文件 ssl_session_cache shared:SSL:1m; ssl_session_timeout 5m; ssl_ciphers HIGH:!aNULL:!MD5; ssl_prefer_server_ciphers on; location / &#123; root /home/hzzly; index index.html index.htm; &#125; # location ^~ /apis/ &#123; # proxy_set_header Host $host; # proxy_set_header X-Real-IP $remote_addr; # proxy_set_header X-Forwarded-Server $host; # # 匹配任何以 /apis/ 开始的请求，并停止匹配 其它location # proxy_pass http://xxxxxxxxxx/; # &#125; # location ^~ /assets/ &#123; # gzip_static on; # expires max; # add_header Cache-Control public; # &#125; &#125;&#125; 3、重启 Nginx 12$ cd /usr/local/nginx/sbin$ ./nginx -s reload 错误详解1、Nginx如果未开启SSL模块，配置Https时提示错误1nginx: [emerg] the \"ssl\" parameter requires ngx_http_ssl_module in ... Nginx开启SSL模块 切换到源码包： 1$ cd /usr/local/src/nginx-1.16.0 修改新的configure参数 1$ ./configure --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_ssl_module 配置完成后，运行命令 1$ make //这里不要进行make install，否则就是覆盖安装 备份原有已安装好的nginx 1$ cp /usr/local/nginx/sbin/nginx /usr/local/nginx/sbin/nginx.bak 将刚刚编译好的nginx覆盖掉原有的nginx 1$ cp ./objs/nginx /usr/local/nginx/sbin/ 重启 Nginx 12$ cd /usr/local/nginx/sbin$ ./nginx -s reload","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"},{"name":"nginx","slug":"nginx","permalink":"http://yoursite.com/tags/nginx/"}]},{"title":"图解词法作用域与作用域链","date":"2019-03-04T07:53:11.000Z","path":"2019/03/04/图解词法作用域与作用域链/","text":"作用域 作用域是指程序源代码中定义变量的区域。 作用域规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。 JavaScript 采用词法作用域(lexical scoping)，也就是静态作用域。 想了解更多关于作用域的问题推荐阅读《你不知道的JavaScript上卷》第一章（或第一部分），从编译原理的角度说明什么是作用域。概括的说作用域就是一套设计良好的规则来存储变量，并且之后可以方便地找到这些变量。 词法作用域在你不知道的javascript上卷中是这样定义的：词法作用域就是定义在词法阶段的作用域。换句话说，词法作用域是由你在写代码时将变量和块作用域写在哪里来决定的，因此当词法分析器处理代码时会保持作用域不变(大部分情况下是这样的)。 在JS中词法作用域的规则： 函数允许访问函数外部的数据 整个代码结构中只有函数可以限定作用域 作用规则首先使用提升规则分析 如果当前作用域中有了名字了，就不考虑外面的名字 栗1：123456var a = 2;function foo() &#123; var a = 3; console.log(a); // 3&#125;foo(); 栗2：123456789function foo() &#123; console.log(a); // 2&#125;function bar() &#123; var a = 3; foo();&#125;var a = 2;bar(); 作用域链只有函数才能制造作用域结构，那么只要是代码，至少有一个作用域，即全局作用域。 凡是代码中有函数，那么这个函数就构成另一个作用域。如果函数中还有函数，那么在这个作用域中就又可以诞生一个作用域，那么将这样的所有作用域列出来，可以有一个结构：函数内指向函数外的链式结构。 以上面栗2：123456789function foo() &#123; console.log(a); // 2&#125;function bar() &#123; var a = 3; foo();&#125;var a = 2;bar(); 全局作用域，有三个标识符：foo、bar、a bar 所创建的作用域，其中有一个标识符：a 作用域是由代码写在哪里决定的，并且是逐级包含的。 我们用级链来表示一下以上代码块： 从图中我们可以看到：函数foo和bar以及变量 a=2， 在1级链，而bar下又可以展开2级链，2级链上有a=3。程序bar()调用进入中间2级链，而bar中又调用了foo函数，此时程序进入foo的作用域链，按照向上查找的原则，程序会从这一条链向上查找，首先2级链没有a，向上到达1级链，刚好1级链上有a=2，所以就直接使用2，程序最后的结果就是打印2。 所以无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处的位置决定。 实践《JavaScript深入之词法作用域和动态作用域》思考题123456789var scope = \"global scope\";function checkscope()&#123; var scope = \"local scope\"; function f()&#123; return scope; &#125; return f();&#125;checkscope(); 参考 JavaScript深入之词法作用域和动态作用域","tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"gitflow基本操作","date":"2019-03-03T15:34:28.000Z","path":"2019/03/03/gitflow基本操作/","text":"前言：在多组员，多项目等环境进行协同工作时，如果没有统一规范、统一流程，则会导致额外的工作量，甚至会做无用功。所以要减少版本冲突，减轻不必要的工作，就需要规范化的工作流程，本文就gitflow作简要的命令操作。 主分支 master 只负责管理发布的状态。在提交时使用标签记录发布版本号。develop 针对发布的日常开发分支。刚才我们已经讲解过有合并分支的功用。 开发分支Git创建Develop分支的命令：1git checkout -b develop master 将Develop分支发布到Master分支的命令：1234# 切换到Master分支git checkout master# 对Develop分支进行合并(使用了--no-ff参数，生成一个新的节点提交)git merge --no-ff develop 临时性分支 功能（feature）分支预发布（release）分支修补bug（fixbug）分支 功能分支创建一个功能分支：1git checkout -b feature-x develop 开发完成后，将功能分支合并到develop分支：12git checkout developgit merge --no-ff feature-x 删除feature分支：123git branch -d feature-x# 删除远程分支git push origin --delete feature-x 预发布分支创建一个预发布分支：1git checkout -b release-1.2 develop 确认没有问题后，合并到master分支：1234git checkout mastergit merge --no-ff release-1.2# 对合并生成的新节点，做一个标签git tag -a 1.2 再合并到develop分支：12git checkout developgit merge --no-ff release-1.2 最后，删除预发布分支：1git branch -d release-1.2 修补bug分支创建一个修补bug分支：1git checkout -b fixbug-0.1 master 修补结束后，合并到master分支：1234git checkout mastergit merge --no-ff fixbug-0.1# 对合并生成的新节点，做一个标签git tag -a 0.1.1 再合并到develop分支：12git checkout developgit merge --no-ff fixbug-0.1 最后，删除修补bug分支：1git branch -d fixbug-0.1 取消刚才的合并merge1git reset --hard HEAD~ 合并123456# rebase 合并git checkout issue3git rebase master# master 合并git checkout mastergit merge issue3 修改冲突后的提交1git rebase --continue 取消rebase1git rebase --abort 回退commit 回退 commit log commit reset push 回退 push log push reset 标签添加轻标签12345git tag v2.0# 显示标签列表git tag# 显示标签列表包含标签资料的历史记录git log --decorate 添加注解标签12345git tag -a v3.0// 或git tag -am \"注解\" v3.0# 显示标签的列表和注解git tag -n 删除标签12git tag -d v2.0git tag -d v3.0 推送标签到远程1git push origin v1.5 查看远程分支1git branch -a Git远程仓库地址变更查看所有远程仓库1git remote 删除远程仓库地址1git remote rm origin 修改变更后的远程仓库地址1git remote add origin http://xxx.git 参考 《Git分支管理策略–阮一峰》 猴子都能懂的GIT入门","tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"dva models一些隐藏的骚操作","date":"2019-02-27T12:34:09.000Z","path":"2019/02/27/dva models一些隐藏的骚操作/","text":"dva 是一个基于 redux 和 redux-saga 的数据流方案redux-saga API take(pattern) 使用take操作进行事件监听，用来命令 middleware 在 Store 上等待指定的 action。 在发起与 pattern 匹配的 action 之前，Generator 将暂停（eg：下一个请求的参数依赖前一个请求的结果）。 1234567891011121314*fetchList(&#123; payload, callback &#125;, &#123; call, put, select, take &#125;) &#123; yield put(&#123; type: 'dict/xxxx', payload: &#123; ... &#125;, &#125;); yield take('dict/xxxx/@@end'); const dictData = yield select(state =&gt; state.dict.dicts); const response = yield call(getList, &#123; xxx: dictData.xxx ... &#125;);&#125; race(effects) 任务的竞争，用来命令 middleware 在多个 Effect 间运行 竞赛（Race）（与 Promise.race([…]) 的行为类似）。 123456789*fetchList(&#123; payload, callback &#125;, &#123; race &#125;) &#123; const &#123; list, timeout &#125; = yield race(&#123; list: call(services.fetchList), timeout: call(delay, TIMEOUT), &#125;); if (timeout) &#123; throw new Error('timeout'); &#125;&#125; 任务的并行执行 把多个要并行执行的东西放在一个数组里，就可以并行执行，等所有的都结束之后，进入下个环节，类似promise.all的操作。一般有一些集成界面，比如dashboard，其中各组件之间业务关联较小，就可以用这种方式去分别加载数据，此时，整体加载时间只取决于时间最长的那个。 之前是 yield [], 后来 dva 升级了 saga 的版本之后就推荐用 yield all([]) yield [] 1234567*fetchList(&#123; payload, callback &#125;, &#123; &#125;) &#123; const [xx1_req, xx2_req, xx3_req] = yield [ call(xx1, payload), call(xx2, payload), call(xx3, payload), ]&#125; yield all([]) 1234567*fetchList(&#123; payload, callback &#125;, &#123; all &#125;) &#123; const [xx1_req, xx2_req, xx3_req] = yield all([ call(xx1, payload), call(xx2, payload), call(xx3, payload), ])&#125;","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}]},{"title":"折腾一个chrome插件","date":"2019-01-04T09:43:48.000Z","path":"2019/01/04/折腾一个chrome插件/","text":"前言：作为一个开发者，是否有时一个单词不认识或者业务命名而烦恼呢，以至于需要打开浏览器，然后打开google翻译，如此繁琐的打开页面可能一天重复好几遍，而我们开发者对于浏览器标签打开的又多，所以如何简化我们重新打开标签来翻译呢？所以浏览器插件就非常强大了。 chrome浏览器是一个工作、学习和生活的必备工具。除了chrome本身的基本能力（控制台等）外，能大幅提高这个神器的使用体验的是它可扩展能力（插件）以及丰富的插件生态。接下来我们就来折腾一个在线翻译的chrome插件。 好了，有了需求我们就得开发了(囧)！ 要点： manifest.json // chrome配置文件 webpack配置(打包，热编译) jsonp ajax封装 开发之前了解一下什么是Chrome插件=&gt; 什么是Chrome插件Chrome插件是一个用Web技术开发、用来增强浏览器功能的软件，它其实就是一个由HTML、CSS、JS、图片等资源组成的一个.crx后缀的压缩包。 核心介绍（manifest.json）这是一个Chrome插件最重要也是必不可少的文件，用来配置所有和插件相关的配置，必须放在需要浏览器打包的根目录。其中，manifest_version、name、version3个是必不可少的，description和icons是推荐的。 栗子(比较全)：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&#123; // 清单文件的版本，这个必须写，而且必须是2 \"manifest_version\": 2, // 插件的名称 \"name\": \"demo\", // 插件的版本 \"version\": \"1.0.0\", // 插件描述 \"description\": \"简单的Chrome扩展demo\", // 图标，一般偷懒全部用一个尺寸的也没问题 \"icons\": &#123; \"16\": \"img/icon.png\", \"48\": \"img/icon.png\", \"128\": \"img/icon.png\" &#125;, // 会一直常驻的后台JS或后台页面 \"background\": &#123; // 2种指定方式，如果指定JS，那么会自动生成一个背景页 \"page\": \"background.html\" //\"scripts\": [\"js/background.js\"] &#125;, // 浏览器右上角图标设置，browser_action、page_action、app必须三选一 \"browser_action\": &#123; \"default_icon\": \"img/icon.png\", // 图标悬停时的标题，可选 \"default_title\": \"这是一个示例Chrome插件\", \"default_popup\": \"popup.html\" &#125;, // 当某些特定页面打开才显示的图标 /*\"page_action\": &#123; \"default_icon\": \"img/icon.png\", \"default_title\": \"我是pageAction\", \"default_popup\": \"popup.html\" &#125;,*/ // 需要直接注入页面的JS \"content_scripts\": [&#123; //\"matches\": [\"http://*/*\", \"https://*/*\"], // \"&lt;all_urls&gt;\" 表示匹配所有地址 \"matches\": [\"&lt;all_urls&gt;\"], // 多个JS按顺序注入 \"js\": [\"js/jquery-1.8.3.js\", \"js/content-script.js\"], // JS的注入可以随便一点，但是CSS的注意就要千万小心了，因为一不小心就可能影响全局样式 \"css\": [\"css/custom.css\"], // 代码注入的时间，可选值： \"document_start\", \"document_end\", or \"document_idle\"，最后一个表示页面空闲时，默认document_idle \"run_at\": \"document_start\" &#125;, &#123; // 这里仅仅是为了演示content-script可以配置多个规则 \"matches\": [\"*://*/*.png\", \"*://*/*.jpg\", \"*://*/*.gif\", \"*://*/*.bmp\"], \"js\": [\"js/show-image-content-size.js\"] &#125;], // 权限申请 \"permissions\": [ \"contextMenus\", // 右键菜单 \"tabs\", // 标签 \"notifications\", // 通知 \"webRequest\", // web请求 \"webRequestBlocking\", \"storage\", // 插件本地存储 \"http://*/*\", // 需要请求的地址 \"https://*/*\" // 需要请求的地址 ]&#125; 介绍完后我们就来开发了(码代码中…) 开发(基于Vue)初始化项目123456789101112mkdir online-translatecd online-translatenpm init// 文件层级├── chrome // 浏览器打包的文件夹├── index.html├── package.json├── src // 源码└── webpack.config.js // wepack 安装依赖12345// 安装项目依赖npm install vue element-ui --save// 安装开发依赖npm install babel-core babel-loader babel-plugin-component babel-preset-env cross-env css-loader file-loader html-webpack-plugin style-loader vue-loader vue-template-compiler webpack webpack-dev-server --save-dev webpack配置12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485// webpack.config.jsvar path = require('path')var webpack = require('webpack')const HtmlWebpackPlugin = require('html-webpack-plugin')module.exports = &#123; entry: &#123; popup: './src/popup.js', &#125;, output: &#123; path: path.resolve(__dirname, './chrome'), publicPath: '/', filename: '[name].[hash].js' &#125;, module: &#123; rules: [ &#123; test: /\\.vue$/, loader: 'vue-loader', options: &#123; loaders: &#123; &#125; // other vue-loader options go here &#125; &#125;, &#123; test: /\\.js$/, loader: 'babel-loader', exclude: /node_modules/ &#125;, &#123; test: /\\.css$/, loader: 'style-loader!css-loader' &#125;, &#123; test: /\\.(eot|svg|ttf|woff|woff2)(\\?\\S*)?$/, loader: 'file-loader' &#125;, &#123; test: /\\.(png|jpg|gif|svg)$/, loader: 'file-loader', options: &#123; name: '[name].[ext]?[hash]' &#125; &#125; ] &#125;, plugins: [ // new webpack.HotModuleReplacementPlugin(), // new webpack.NamedModulesPlugin(), new HtmlWebpackPlugin(&#123; template: path.join(__dirname, './index.html'), inject: true &#125;) ], devServer: &#123; historyApiFallback: true, noInfo: true &#125;, performance: &#123; hints: false &#125;, devtool: '#eval-source-map'&#125;if (process.env.NODE_ENV === 'production') &#123; module.exports.devtool = '#source-map' // http://vue-loader.vuejs.org/en/workflow/production.html module.exports.plugins = (module.exports.plugins || []).concat([ new webpack.DefinePlugin(&#123; 'process.env': &#123; NODE_ENV: '\"production\"' &#125; &#125;), new webpack.optimize.UglifyJsPlugin(&#123; sourceMap: false, compress: &#123; warnings: false &#125; &#125;), new webpack.LoaderOptionsPlugin(&#123; minimize: true &#125;) ])&#125; 配置好了，我们就能愉快的开发了 接下来就是 Vue 的开发了！正常的项目开发… 详细源码可以看github webpack打包1npm run build 把代码打包到了chrome文件夹内，然后就可以使用chrome扩展进行打包扩展程序，会生成.crx和.pem文件，然后直接发布或者把.crx文件拖进扩展程序内进行内测。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"},{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"},{"name":"chrome","slug":"chrome","permalink":"http://yoursite.com/tags/chrome/"}]},{"title":"Node 配置文件的定制","date":"2018-11-13T13:54:17.000Z","path":"2018/11/13/Node-配置文件的定制/","text":"在任何一个项目中都缺少不了配置文件具有下面的特点: 数据量不大,信息需要长期保存,容易维护 现在是大前端的时代，Node 的重要性不言而喻。在使用 Node 作为后端或者中间层的技术架构时，往往需要用到一些可配置的变量，比如数据库，在开发时我们会连开发的数据库，生成环境我们需要连生产的数据库，这样我们就需要根据不同的环境加载不一样的配置文件，从而提高我们的开发效率，接下来我们就一起来定制我们的配置文件。 环境变量在 Node 中可以通过 process.env 来访问当前的环境变量信息。比如我们在 package.json 中通过 scripts 定义的shell脚本执行对应的命令。12345678910// package.json&#123; ... \"scripts\": &#123; \"start\": \"node ./bin/www\", \"dev\": \"NODE_ENV=dev node ./bin/www\", \"pro\": \"NODE_ENV=pro node ./bin/www\" &#125;, ...&#125; 可以看到，上面有三条条启动命令，一条是默认的 start，另外两条我们通过 NODE_ENV=xxx 来设置了对应的环境，当我们使用 npm run dev 启动项目的时候，通过 process.env.NODE_ENV 就可以取到项目的当前环境。 通过环境变量指定对应的配置文件在上面我们通过shell脚本指定了对应的环境，那我们就可以通过 process.env.NODE_ENV 来加载对应的配置文件了。12345678910111213141516// config/index.jsmodule.exports = &#123; dev: &#123; ...省略 mongodb: 'mongodb://localhost:27017/demo' &#125;, build: &#123; ...省略 mongodb: 'mongodb://127.0.0.0:27017/demo' &#125;&#125;// app.jsconst config = require('./config')const mongodb = process.env.NODE_ENV === 'dev' ? config.build.mongodb : config.dev.mongodb 这样，我们就可以开开心心的放心的写代码了，但这样\b写还不是很优雅，都写到一个文件里了，不太好维护，接下来我们就真正的动态加载，不需要我们再加判断了。 config-lite config-lite： A super simple &amp; flexible &amp; intuitive config module, support yaml &amp; toml. 这一次，我们针对不同的环境，将配置写入不同的配置文件中，在项目根目录下新建config目录，里面新建不同环境的配置文件：default.js、dev.js和pro.js。12345678910111213141516171819202122232425// default.jsmodule.exports = &#123; session: &#123; secret: 'config-lite-demo', resave: false, saveUninitialized: true, cookie: &#123; maxAge: 1000*60*60 &#125; &#125;&#125;;// dev.jsmodule.exports = &#123; host: \"https://dev.com\", mongodb: 'mongodb://localhost:27017/test', ...省略&#125;;// pro.jsmodule.exports = &#123; host: \"https://pro.com\", mongodb: 'mongodb://127.0.0.0:27017/test', ...省略&#125;; 好了，配置文件写好了，如何使用呢？这里我们使用的 config-lite 插件，这个插件依旧是依据我们shell脚本指定的对应环境来选择不同的配置文件。 Install1$ npm i config-lite --save 当我们使用 npm run dev 启动项目的时候，config-lite会去抓取dev.js配置，并且会与default.js里配置去合并，如果有相同的对象，会覆盖default.js里的配置。同理 npm run pro Usage1234567891011121314151617181920212223242526272829303132// app.jsconst config = require('config-lite')(__dirname);// 1、如果\b运行 npm run devconfig = &#123; host: \"https://dev.com\", mongodb: 'mongodb://localhost:27017/test', session: &#123; secret: 'config-lite-demo', resave: false, saveUninitialized: true, cookie: &#123; maxAge: 1000*60*60 &#125; &#125; ...省略&#125;// 2、如果\b运行 npm run proconfig = &#123; host: \"https://pro.com\", mongodb: 'mongodb://127.0.0.0:27017/test', session: &#123; secret: 'config-lite-demo', resave: false, saveUninitialized: true, cookie: &#123; maxAge: 1000*60*60 &#125; &#125; ...省略&#125; \b至此，我们就得到了更好维护的动态加载配置文件。还有一个问题（大多数情况下，在windows平台下使用类似于: NODE_ENV=pro的命令行指令会卡住，windows平台与POSIX在使用命令行时有许多区别（例如在POSIX，使用$ENV_VAR,在windows，使用%ENV_VAR%。。。））。那该如何解决呢？👇 cross-env cross-env 让这一切变得简单，不同平台使用唯一指令，无需担心跨平台问题 Install1$ npm i cross-env --save Usage12345678910// package.json&#123; ... \"scripts\": &#123; \"start\": \"node ./bin/www\", \"dev\": \"cross-env NODE_ENV=dev node ./bin/www\", \"pro\": \"cross-env NODE_ENV=pro node ./bin/www\" &#125;, ...&#125; 这样 NODE_ENV 便设置成功，无需担心跨平台问题。 egg 配置文件的使用在 config 目录(脚手架生成的)新增 config.dev.js 和 config.pro.js，然后在文件内写我们对应环境的配置。 配置环境1234567891011// package.json&#123; ... \"script\": &#123; ... \"dev\": \"EGG_SERVER_ENV=dev egg-bin dev\", \"pro\": \"EGG_SERVER_ENV=pro egg-scripts start\", ... &#125; ...&#125; 在 egg 中通过 EGG_SERVER_ENV \b来声明对应的环境变量。 使用1const config = this.app.config // 得到对应环境的配置文件(也会和 default 进行合并) 完结，好久没写了，有点生疏了，苦笑！！！","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"},{"name":"node","slug":"node","permalink":"http://yoursite.com/tags/node/"}]},{"title":"前端路由的实现原理","date":"2017-09-16T13:09:32.000Z","path":"2017/09/16/前端路由的实现原理/","text":"路由 在现代前端开发中，路由是非常重要的一环。但路由到底是什么呢？有些说：路由就是指随着浏览器地址栏的变化，展示给用户的页面也不相同。这是从路由的用途上来解释路由是什么的，还有一种说法是：路由就是URL到函数的映射。这是从路由的实现原理上来解释路由是什么的。这两种说法都很有道理。 早期的路由都是后端实现的，直接根据 url 来 reload 页面，页面变得越来越复杂服务器端压力变大，随着 ajax 的出现，页面实现非 reload 就能刷新数据，也给前端路由的出现奠定了基础。我们可以通过记录 url 来记录 ajax 的变化，从而实现前端路由。 前端路由说白了就是监听浏览器路由地址的变化，渲染不同的页面或组件。下面主要讲两种主流方式实现前端路由： History这里不细说每一个 API 的用法，大家可以看 MDN 的文档：https://developer.mozilla.org… 14年后，因为HTML5标准发布，新增了两个 API，history.pushState 和 history.replaceState，通过这两个 API 可以改变 url 地址且不会发送请求。 这两个 API 都接收三个参数，分别是 状态对象（state object） — 一个JavaScript对象，与用pushState()方法创建的新历史记录条目关联。无论何时用户导航到新创建的状态，popstate事件都会被触发，并且事件对象的state属性都包含历史记录条目的状态对象的拷贝。 标题（title） — FireFox浏览器目前会忽略该参数，虽然以后可能会用上。考虑到未来可能会对该方法进行修改，传一个空字符串会比较安全。或者，你也可以传入一个简短的标题，标明将要进入的状态。 地址（URL） — 新的历史记录条目的地址。浏览器不会在调用pushState()方法后加载该地址，但之后，可能会试图加载，例如用户重启浏览器。新的URL不一定是绝对路径；如果是相对路径，它将以当前URL为基准；传入的URL与当前URL应该是同源的，否则，pushState()会抛出异常。该参数是可选的；不指定的话则为文档当前URL。相同之处是两个 API 都会操作浏览器的历史记录，而不会引起页面的刷新。 不同之处在于，pushState会增加一条新的历史记录，而replaceState则会替换当前的历史记录。 我们拿大百度的控制台举例子（具体说是我的浏览器在百度首页打开控制台。。。） 我们在控制台输入 1window.history.pushState(null, null, \"https://www.baidu.com/?name=hzzly\"); 好，我们观察此时的 url 变成了这样https://www.baidu.com/?name=hzzly 我们这里不一一测试，直接给出其它用法，大家自行尝试1234567891011121314window.history.pushState(null, null, \"https://www.baidu.com/name/hzzly\");//url: https://www.baidu.com/name/hzzly window.history.pushState(null, null, \"?name=hzzly\");//url: https://www.baidu.com?name=hzzly window.history.pushState(null, null, \"name=hzzly\");//url: https://www.baidu.com/name=hzzly window.history.pushState(null, null, \"/name/hzzly\");//url: https://www.baidu.com/name/hzzly window.history.pushState(null, null, \"name/hzzly\");//url: https://www.baidu.com/name/hzzly 每次改变 url 页面并没有刷新，同样根据上文所述，浏览器会产生历史记录。 我们需要一个根据监听history变化触发的事件 —— popstate 事件12345function matchAndUpdate () &#123; // 匹配路径 做 dom 更新操作&#125;window.addEventListener('popstate', matchAndUpdate) hash我们经常在 url 中看到 #，这个 # 有两种情况，一个是我们所谓的锚点，比如典型的各个标题之间的跳转等，路由里的 # 不叫锚点，我们称之为 hash。 同样我们需要一个根据监听哈希变化触发的事件 —— hashchange 事件 12345function matchAndUpdate () &#123; // 匹配 hash 做 dom 更新操作&#125;window.addEventListener('hashchange', matchAndUpdate) 我们用 window.location 处理哈希的改变时不会重新渲染页面，而是当作新页面加到历史记录中，这样我们跳转页面就可以在 hashchange 事件中注册 ajax 从而改变页面内容。 前端路由优缺点优点：1.从性能和用户体验的层面来比较的话，后端路由每次访问一个新页面的时候都要向服务器发送请求，然后服务器再响应请求，这个过程肯定会有延迟。而前端路由在访问一个新页面的时候仅仅是变换了一下路径而已，没有了网络延迟，对于用户体验来说会有相当大的提升。2.在某些场合中，用ajax请求，可以让页面无刷新，页面变了但Url没有变化，用户就不能复制到想要的地址，用前端路由做单页面网页就很好的解决了这个问题 缺点：使用浏览器的前进，后退键的时候会重新发送请求，没有合理地利用缓存。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"在Vue.js中使用Mixins","date":"2017-09-12T03:15:14.000Z","path":"2017/09/12/在Vue-js中使用Mixins/","text":"一个很常见的场景: 有两个非常相似的组件, 它们拥有非常相似的基本功能, 但是它们之间又有足够的不同的地方, 该如何选择呢? 我们是应该将它们分成两个完全不同的组件呢? 还是创建一个基础组件, 然后定义足够多的props以方便区分使用场景? 这两种方式都不是完美的: 如果你将它们分成两个完全不同的组件, 在需求变化(功能变化)时, 可能会增加需要同时修改两个组件的风险, 这违反了”DRY”的前提. 另一方面, 太多的props很快会让人变得凌乱, 并且, 迫使维护人员, 甚至是你自己, 要首先理解这些props的上下文才能使用它, 这会让人非常失望. Vue的Mixins是非常实用的编程方式, 因为最终实用的编程是通过不断减少运动部件(moving parts)使代码变得容易理解. (关于这一点, Michael Feathers有一个很好的引用). 一个mixin允许你封装一个功能, 以便你能在整个应用程序中的不同组件中使用它. 如果mixin被正确的创建, 它们是纯粹的–它们不会修改或更改函数的作用范围(scope)之外的内容, 因此, 您可以在多个地方执行它们, 并且只要输入值相同, 总是能非常可靠得得到相同的结果. 这真的非常强大. 认识Mixins混合 (mixins) 是一种分发 Vue 组件中可复用功能的非常灵活的方式。混合对象可以包含任意组件选项。以组件使用混合对象时，所有混合对象的选项将被混入该组件本身的选项。 栗子 假设我们有一些不同的组件, 它们的工作是切换状态boolean, 一个模态(modal)和一个提示(tooltip). 这些tooltips和modals没有很多共同之处, 除了这个功能: 它们看起来不一样, 它们使用起来也不尽相同, 但是它们的逻辑是相似的 . 1234567891011121314151617181920212223242526272829//modalconst Modal = &#123; template: '#modal', data() &#123; return &#123; isShowing: false &#125; &#125;, methods: &#123; toggleShow() &#123; this.isShowing = !this.isShowing; &#125; &#125;&#125; //tooltipconst Tooltip = &#123; template: '#tooltip', data() &#123; return &#123; isShowing: false &#125; &#125;, methods: &#123; toggleShow() &#123; this.isShowing = !this.isShowing; &#125; &#125;&#125; 我们可以从中提取逻辑, 并创建可以复用的部分：12345678910111213141516171819202122const toggle = &#123; data() &#123; return &#123; isShowing: false &#125; &#125;, methods: &#123; toggleShow() &#123; this.isShowing = !this.isShowing; &#125; &#125;&#125; const Modal = &#123; template: '#modal', mixins: [toggle]&#125;; const Tooltip = &#123; template: '#tooltip', mixins: [toggle]&#125;; duang — 一个小而简单的🌰让我们知道了Mixins对于封装一些可复用的功能如此有趣、方便、实用。 项目实践 MagicMusic star(200+)","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"},{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"Vue插件的开发(一)","date":"2017-08-25T05:59:55.000Z","path":"2017/08/25/Vue插件的开发-一/","text":"前言：随着 Vue.js 越来越火，Vue.js 的相关插件也在不断的被贡献出来，数不胜数。比如官方推荐的 vue-router、vuex 等，都是非常优秀的插件。但是我们更多的人还只停留在使用的阶段，比较少自己开发。所以接下来通过一个简单的 vue-toast 插件，来了解掌握插件的开发和使用。 认识插件想要开发插件，先要认识一个插件是什么样子的。官方文档:插件 Vue.js 的插件应当有一个公开方法 install 。这个方法的第一个参数是 Vue 构造器 , 第二个参数是一个可选的选项对象: 1234567891011121314151617181920MyPlugin.install = function (Vue, options) &#123; Vue.myGlobalMethod = function () &#123; // 1. 添加全局方法或属性，如: vue-custom-element // 逻辑... &#125; Vue.directive('my-directive', &#123; // 2. 添加全局资源：指令/过滤器/过渡等，如 vue-touch bind (el, binding, vnode, oldVnode) &#123; // 逻辑... &#125; ... &#125;) Vue.mixin(&#123; created: function () &#123; // 3. 通过全局 mixin方法添加一些组件选项，如: vuex // 逻辑... &#125; ... &#125;) Vue.prototype.$myMethod = function (options) &#123; // 4. 添加实例方法，通过把它们添加到 Vue.prototype 上实现 // 逻辑... &#125;&#125; 接下来要讲到的 vue-toast 插件则是通过添加实例方法实现的。我们先来看个小例子。先新建个js文件来编写插件：toast.js 123456// toast.jsvar Toast = &#123;&#125;;Toast.install = function (Vue, options) &#123; Vue.prototype.$msg = 'Hello World';&#125;module.exports = Toast; 在 main.js 中，需要导入 toast.js 并且通过全局方法 Vue.use() 来使用插件： 1234// main.jsimport Vue from 'vue';import Toast from './toast.js';Vue.use(Toast); 然后，我们在组件中来获取该插件定义的 $msg 属性。 123456// App.vueexport default &#123; mounted()&#123; console.log(this.$msg); // Hello World &#125;&#125; 可以看到，控制台成功的打印出了 Hello World 。既然 $msg 能获取到，那么我们就可以来实现我们的 vue-toast 插件了。 开发 vue-toast 插件需求：在组件中通过调用 this.$toast(‘网络请求失败’) 来弹出提示，默认在底部显示。可以通过调用 this.$toast.top() 或 this.$toast.center() 等方法来实现在不同位置显示。 整理一下思路，弹出提示的时候，我可以在 body 中添加一个 div 用来显示提示信息，不同的位置我通过添加不同的类名来定位，那就可以开始写了。 123456789101112131415// toast.jsvar Toast = &#123;&#125;;Toast.install = function (Vue, options) &#123; Vue.prototype.$toast = (tips) =&gt; &#123; let toastTpl = Vue.extend(&#123; // 1、创建构造器，定义好提示信息的模板 template: '&lt;div class=\"vue-toast\"&gt;' + tips + '&lt;/div&gt;' &#125;); let tpl = new toastTpl().$mount().$el; // 2、创建实例，挂载到文档以后的地方 document.body.appendChild(tpl); // 3、把创建的实例添加到body中 setTimeout(function () &#123; // 4、延迟2.5秒后移除该提示 document.body.removeChild(tpl); &#125;, 2500) &#125;&#125;module.exports = Toast; 好像很简单，我们就实现了 this.$toast() ，接下来显示不同位置 123456// toast.js['bottom', 'center', 'top'].forEach(type =&gt; &#123; Vue.prototype.$toast[type] = (tips) =&gt; &#123; return Vue.prototype.$toast(tips,type) &#125;&#125;) 这里把 type 传给 $toast 在该方法里进行不同位置的处理，上面说了通过添加不同的类名(toast-bottom、toast-top、toast-center)来实现，那 $toast 方法需要小小修改一下 123456Vue.prototype.$toast = (tips,type) =&gt; &#123; // 添加 type 参数 let toastTpl = Vue.extend(&#123; // 模板添加位置类 template: '&lt;div class=\"vue-toast toast-'+ type +'\"&gt;' + tips + '&lt;/div&gt;' &#125;); ...&#125; 好像差不多了。但是如果我想默认在顶部显示，我每次都要调用 this.$toast.top() 好像就有点多余了，我能不能 this.$toast() 就直接在我想要的地方呢？还有我不想要 2.5s 后才消失呢？这时候注意到 Toast.install(Vue,options) 里的 options 参数，我们可以在 Vue.use() 通过 options 传进我们想要的参数。最后修改插件如下： 123456789101112131415161718192021222324252627282930313233var Toast = &#123;&#125;;Toast.install = function (Vue, options) &#123; let opt = &#123; defaultType:'bottom', // 默认显示位置 duration:'2500' // 持续时间 &#125; for(let property in options)&#123; opt[property] = options[property]; // 使用 options 的配置 &#125; Vue.prototype.$toast = (tips,type) =&gt; &#123; if(type)&#123; opt.defaultType = type; // 如果有传type，位置则设为该type &#125; if(document.getElementsByClassName('vue-toast').length)&#123; // 如果toast还在，则不再执行 return; &#125; let toastTpl = Vue.extend(&#123; template: '&lt;div class=\"vue-toast toast-'+opt.defaultType+'\"&gt;' + tips + '&lt;/div&gt;' &#125;); let tpl = new toastTpl().$mount().$el; document.body.appendChild(tpl); setTimeout(function () &#123; document.body.removeChild(tpl); &#125;, opt.duration) &#125; ['bottom', 'center', 'top'].forEach(type =&gt; &#123; Vue.prototype.$toast[type] = (tips) =&gt; &#123; return Vue.prototype.$toast(tips,type) &#125; &#125;)&#125;module.exports = Toast; 这样子一个简单的 vue 插件就实现了，并且可以通过 npm 打包发布，下次就可以使用 npm install 来安装了。 好久没更新博客，逃。。。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"},{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"vue与echarts的可视化","date":"2017-07-09T13:51:32.000Z","path":"2017/07/09/vue与echarts的可视化/","text":"好久没有更新博客了，但我并没有偷懒哦。因为进入了公司实习，需要熟悉项目需求以及技术栈，公司技术栈用的react与dva，所以需要现学现卖。趁着周末写写vue，美滋滋，哈哈哈。 一、配方 vue echarts 二、参考案例 gallery 社区demo 三、实践3.1安装 echarts1npm install echarts --save 3.2vue dom 结构1&lt;div id=\"charts\" style=\"height:300px;width:300px\"&gt;&lt;/div&gt; 3.3在vue中引入echarts因为ECharts初始化必须绑定dom，所以我们只能在vue的mounted生命周期里初始化。 3.3.1全部引入可以直接在项目代码中 require(‘echarts’) 或 import 得到 ECharts，我这里通过es6的import来引入123456789101112131415161718192021222324252627import echarts from 'echarts' mounted () &#123; this.initChart()&#125;,methods: &#123; initChart () &#123; this.chart = echarts.init(document.getElementById('charts')) let option = &#123; title: &#123; text: 'ECharts 入门示例' &#125;, tooltip: &#123;&#125;, xAxis: &#123; data: [\"衬衫\",\"羊毛衫\",\"雪纺衫\",\"裤子\",\"高跟鞋\",\"袜子\"] &#125;, yAxis: &#123;&#125;, series: [&#123; name: '销量', type: 'bar', data: [5, 20, 36, 10, 10, 20] &#125;] &#125; this.chart.setOption(option) &#125;&#125; 3.3.2按需引入默认使用 require(‘echarts’) 得到的是已经加载了所有图表和组件的 ECharts 包，因此体积会比较大，如果在项目中对体积要求比较苛刻，也可以只按需引入需要的模块。 例如上面示例代码中只用到了柱状图，提示框和标题组件，因此在引入的时候也只需要引入这些模块，可以有效的将打包后的体积从 400 多 KB 减小到 170 多 KB。 123456789// 引入 ECharts 主模块import echarts from 'echarts/lib/echarts'// 引入柱状图import 'echarts/lib/chart/bar'// 引入提示框和标题组件import 'echarts/lib/component/tooltip'import 'echarts/lib/component/title' // 后面的跟上面的就一样了 3.3.3动态改变ECharts的配置(option)12345678910111213141516//第一种 watch options变化 利用vue的深度 watcher，options一有变化就重新setOptionwatch: &#123; options: &#123; handler(options) &#123; this.chart.setOption(this.options) &#125;, deep: true &#125;,&#125;//第二种 只watch 数据的变化 只有数据变化时触发EChartswatch: &#123; seriesData(val) &#123; this.setOptions(&#123;series:val&#125;) &#125;&#125; 3.4结果到这我们在页面上就可以显示图表了，实现可视化数据，是不是很酷炫。 四、参考在 webpack 中使用 ECharts","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"},{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"},{"name":"echarts","slug":"echarts","permalink":"http://yoursite.com/tags/echarts/"}]},{"title":"基于vue-cli配置proxyTable开发环境的跨域","date":"2017-06-21T02:30:54.000Z","path":"2017/06/21/基于vue-cli配置proxyTable开发环境的跨域/","text":"前言：目前前端项目普遍采用前后端分离的思想来开发，这样在和后端进行数据联调时势必会面临恼人的跨域问题，最近几个基于Vue开发项目时也遇到了这个问题，网上关于跨域的解决方案很多，这里就简单的介绍基于vue-cli配置proxyTable的开发环境来解决跨域。 还不懂前后端分离的可以移步👉：前后端分离的尝试 配置 proxyTable在 config/index.js 中，把 dev 下的 proxytable 里面配置如下：123456789proxyTable: &#123; '/api': &#123; target: 'http://api.hjingren.cn', changeOrigin: true, pathRewrite: &#123; '^/api': '' &#125; &#125;&#125; 使用（请求）1fetch('/api/playlist/detail?id=12345') 最后：vue-cli的这个配置来自于其使用的插件http-proxy-middleware，想进一步了解的可以深入研究。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"},{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"基于vue-cli配置移动端自适应","date":"2017-06-16T10:44:03.000Z","path":"2017/06/16/基于vue-cli配置移动端自适应/","text":"之前写过一篇关于移动端屏幕适配：移动端屏幕适配的解决，今天来聊一聊基于vue-cli配置的移动端屏幕适配问题。 配方还是一样：手淘的 lib-flexible + rem 配置 flexible安装 lib-flexible在命令行中运行如下安装： 1npm i lib-flexible --save 引入 lib-flexible在项目入口文件 main.js 里 引入 lib-flexible 12// main.jsimport 'lib-flexible' 添加 meta 标签在项目根目录的 index.html 中添加如下 meta 1&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; px 转 rem实际开发中，我们通过设计稿得到的值单位是 px，所以要将 px 转换成 rem 再写进样式中。将 px 转换成 rem 我们将使用 px2rem 这个工具，它有 webpack 的 loader：px2rem-loader 安装 px2rem-loader在命令行中运行如下安装： 1npm i px2rem-loade --save-dev 配置 px2rem-loade在 vue-cli 生成的 webpack 配置中，vue-loader 的 options 和其他样式文件 loader 最终是都是由 build/utils.js 里的一个方法生成的。 我们只需在 cssLoader 后再加上一个 px2remLoader 即可，px2rem-loader 的 remUnit 选项意思是 1rem=多少像素，结合 lib-flexible 的方案，我们将 px2remLoader 的 options.remUnit 设置成设计稿宽度的 1/10，这里我们假设设计稿宽为 750px。 12345678910111213141516// utils.jsvar cssLoader = &#123; loader: 'css-loader', options: &#123; minimize: process.env.NODE_ENV === 'production', sourceMap: options.sourceMap &#125;&#125;var px2remLoader = &#123; loader: 'px2rem-loader', options: &#123; remUnit: 75 &#125;&#125;// ... 并放进 loaders 数组中 1234// utils.jsfunction generateLoaders(loader, loaderOptions) &#123; var loaders = [cssLoader, px2remLoader] // ... 修改配置后需要重启，然后我们在组件中写单位直接写 px，设计稿量多少就可以写多少了，舒服多了。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"},{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"Nginx与Node的纠缠","date":"2017-06-11T12:10:54.000Z","path":"2017/06/11/Nginx与Node的纠缠/","text":"前言：前几天面试被问到：“nginx的好处？nginx和node的比较”，所以在这里总结一波。 nginx的好处 热部署 高并发连接 处理响应请求很快 具有很高的可靠性 热部署在不停止服务的情况下修改配置文件，更换日志文件等功能。 高并发连接高并发：是指在同一个时间点，有很多用户同时的访问URL地址，比如：淘宝的双11，双12，就会产生高并发。 这是一个很重要的一个特性！在这一个 互联网 快速发展， 互联网 用户数量不断增加，一些大公司、网站都需要面对高并发请求，如果有一个能够在峰值顶住10万以上并发请求的Server，肯定会得到大家的青睐。理论上，Nginx支持的并发连接上限取决于你的内存，10万远未封顶。 Nginx能做什么 反向代理 负载均衡 HTTP服务器（包含动静分离） 正向代理 反向代理反向代理应该是Nginx做的最多的一件事了，什么是反向代理呢，以下是百度百科的说法：反向代理（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。简单来说就是真实的服务器不能直接被外部网络访问，所以需要一台代理服务器，而代理服务器能被外部网络访问的同时又跟真实服务器在同一个网络环境，当然也可能是同一台服务器，端口不同而已。 下面贴上一段简单的实现反向代理的代码： 123456789server &#123; listen 80; server_name localhost; location / &#123; proxy_pass http://localhost:8081; proxy_set_header Host $host:$server_port; &#125;&#125; 当我们访问localhost的时候，就相当于访问localhost:8081了 负载均衡负载均衡可以把用户的请求分摊到多个服务器上进行处理，从而实现了对海量用户的访问支持。负载均衡的架构如图所示： 简单而言就是当有2台或以上服务器时，根据规则随机的将请求分发到指定的服务器上处理，负载均衡配置一般都需要同时配置反向代理，通过反向代理跳转到负载均衡。 1234567891011121314upstream test &#123; server localhost:8080; server localhost:8081;&#125;server &#123; listen 81; server_name localhost; location / &#123; proxy_pass http://test; proxy_set_header Host $host:$server_port; &#125;&#125; HTTP服务器Nginx本身也是一个静态资源的服务器，当只有静态资源的时候，就可以使用Nginx来做服务器，同时现在也很流行动静分离，就可以通过Nginx来实现。 123456789101112131415161718server &#123; listen 80; server_name localhost; location / &#123; root /home/hzzly; index index.html index.htm; &#125; #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125;&#125; 正向代理正向代理，意思是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端才能使用正向代理。当你需要把你的服务器作为代理服务器的时候，可以用Nginx来实现正向代理。 node的特点 它是一个javascript运行环境 依赖于Chrome V8引擎进行代码解释 事件驱动 非阻塞I/O 轻量、可伸缩，适于实时数据交互应用 并发连接（高并发） node应用场景NodeJS适合运用在高并发、I/O密集、少量业务逻辑的场景。（RESTful API，聊天） Event Loop、消息队列、事件轮询通过回调函数（Callback）和异步机制来实现非阻塞。通过事件队列和事件循环来实现并发连接。 异步函数在执行结束后，会在事件队列中添加一个事件（回调函数）(遵循先进先出原则)，主线程中的代码执行完毕后（即一次循环结束），下一次循环开始就在事件队列中“读取”事件，然后调用它所对应的回调函数。这个过程是循环不断的，所以整个的这种运行机制又称为Event Loop（事件循环） nginx和node的比较 一个更专业，一个更全面。 Nginx 采用C编写，性能更高，但是它仅适合于做web服务器，用于反向代理或者负载均衡等服务。 NodeJs高性能平台，web服务只是其中一块，NodeJs在处理业务层用的是JS编写,采用的是异步编程方式和思维方式。 Node.js发展方向不再单独是一个Web服务器，而是一个面向网络的平台，它甚至可以是TCP服务器，或者变身为远端服务器的客户端。 nginx与node的完美搭配node自己本身可以作为服务器进行驱动，但是node本身对文件的处理能力并不是很好，所以当我们的生产环境中应尽量使用nginx来处理静态的资源以及反向代理，同时也解决了node分布式以及负载均衡的相关问题。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"},{"name":"nginx","slug":"nginx","permalink":"http://yoursite.com/tags/nginx/"},{"name":"node","slug":"node","permalink":"http://yoursite.com/tags/node/"}]},{"title":"js实现图片懒加载","date":"2017-06-09T14:23:39.000Z","path":"2017/06/09/js实现图片懒加载/","text":"前言：最近面试都被问到了这个问题，所以在这里整理一波。 懒加载的意义 懒加载的主要目的是作为服务器前端的优化，减少请求数或延迟请求数，对服务器缓压。 预加载:提前加载好，缓存到本地，当需要的时候直接读取缓存，对服务器增压 懒加载实现方式 第一种是纯粹的延迟加载，使用setTimeOut或setInterval进行加载延迟 第二种是条件加载，符合某些条件，或触发了某些事件才开始异步下载 第三种是可视区加载，即仅加载用户可以看到的区域，这个主要由监控滚动条来实现，一般会在距用户看到某图片前一定距离遍开始加载，这样能保证用户拉下时正好能看到图片 Web 图片的懒加载就是通过读取img元素，然后获得img元素的data-src（也可以约定为其他属性名）属性的值，并赋予img的src，从而实现动态加载图片的机制 1、懒加载HTML约定我们首先需要给准备实施懒加载的img元素添加指定的class 这里为m-lazyload ,同时将img src赋值给 data-src属性。具体示例为：1&lt;img class=\"m-lazyload\" data-src=\"imgUrl\"&gt; 2、懒加载JavaScript实现动态加载总共分为以下几个步骤:1、添加页面滚动监听事件1234567891011121314151617imgBoxList.addEventListener('scroll', debounce(() =&gt; &#123; _loadImage();&#125;, 200)); // 简单的防抖函数function debounce(func, delay) &#123; let timer return function (...args) &#123; if (timer) &#123; clearTimeout(timer) &#125; timer = setTimeout(() =&gt; &#123; func.apply(this, args) &#125;, delay) &#125;&#125; 2、当触发监听事件时会执行 _loadImage 函数，该函数负责加载图片12345678910function _loadImage() &#123; const domOffsetHeight = imgBoxList.offsetHeight; const imgs = imgBoxList.querySelectorAll('img[data-src]'); for (let i = 0; i &lt; imgs.length; i++) &#123; const el = imgs[i]; if (_isShow(el, domOffsetHeight)) &#123; el.src = el.getAttribute('data-src') &#125; &#125;&#125; 3、判断该图片是否在当前窗口的可视区域内1234function _isShow(el, domHeight) &#123; const rect = el.getBoundingClientRect(); return rect.top &lt;= domHeight + 200;&#125; 到这一个简单的图片懒加载就写成了 当网页滚动的事件被触发 -&gt; 执行加载图片操作 -&gt; 判断图片是否在可视区域内 -&gt; 在，则动态将data-src的值赋予该图片。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"DIY一个自己的音乐播放器2.0来袭","date":"2017-06-05T13:32:59.000Z","path":"2017/06/05/DIY一个自己的音乐播放器2-0来袭/","text":"前言：之前做的第一版播放器功能做出来了，但发现结构不是很优雅以及后端api很不稳定，所以进行了一次小升级。此次升级 功能更全，体验更好，api更稳定，技术栈更多，收获也更多👍。 [温馨提示：pc浏览f12手机模式最佳,手机建议wifi下访问,低版本浏览器可能有兼容性问题] 预览地址： http://hzzly.net/magic-musicGithub地址： https://github.com/hzzly/MagicMusic欢迎大家的star和fork😄~ 实现的功能 首页 轮播 个性推荐[流行、古典、轻音乐、流行] 歌曲操作（动画） 底部播放控件 播放、暂停、下一曲 实时播放进度条 播放页 上一曲、播放、暂停、下一曲 播放进度条（弧形进度条） 歌词滚动、歌词高亮 播放列表 播放歌曲高亮 切歌(单击切歌) 删歌(点击右侧小X) 清空播放列表 本地缓存播放列表 排行榜 排行榜列表 排行榜里的歌曲(单击播放)、全部播放 音乐搜索 搜索单曲、歌手 搜索历史记录 侧边栏 未实现的功能 喜欢、分享、下载、切换播放模式 预览 更多预览👉更多 技术栈1、Vue全家桶(vue2、vue-router、vuex) 快速开发SPA神器2、Axios vue作者推荐的数据请求方案3、ES6 全面过度es6的写法 趋势4、Webpack2 脚手架已经配置好了，超贴心5、Promise 把请求封装在promise中，方便的可以使用.then回调6、flex布局 对于移动端可以放心大胆的使用7、移动端屏幕适配 采用手淘的flexible+rem方案8、本地存储(sessionStorage、localStorage) 避免重复资源请求，快速读取9、图片懒加载 vue-lazyload 提升用户体验 本次更新日志 后端api采用pm2来部署，防止断开后数据无法请求的尴尬。 把监听audio加载完数据事件统一管理起来，避免重复监听，优化代码结构。 更新axios请求，让请求更加优美。 修改播放页面，优化用户体验。 添加加载音乐loading等待，提升用户体验。 添加播放全部，避免一个一个添加。 本地缓存播放列表与清空。 修改首页tab切换动效 DIY一个自己的音乐播放器1.0 后记MagicMusic还在不断努力的改进，觉得还行的可以点个star，你的star是我继续开源创作的动力，谢谢！！！当然有建议可以在issues里提。项目地址： https://github.com/hzzly/MagicMusic欢迎大家的star啦~ 求实习本人大三，求一个前端实习：简历","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"},{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"},{"name":"vuex","slug":"vuex","permalink":"http://yoursite.com/tags/vuex/"}]},{"title":"CentOS 7 Nginx的折腾","date":"2017-06-05T05:52:23.000Z","path":"2017/06/05/CentOS-7-Nginx的折腾/","text":"CentOS 7 下安装 Nginx查看centos版本1$ cat /etc/redhat-release 一. gcc 安装 安装 nginx 需要先将官网下载的源码进行编译，编译依赖 gcc 环境，如果没有 gcc 环境，则需要安装： 1$ yum install gcc-c++ 二. pcre pcre-devel 安装 PCRE(Perl Compatible Regular Expressions) 是一个Perl库，包括 perl 兼容的正则表达式库。nginx 的 http 模块使用 pcre 来解析正则表达式，所以需要在 linux 上安装 pcre 库，pcre-devel 是使用 pcre 开发的一个二次开发库。nginx也需要此库。命令： 1$ yum install -y pcre pcre-devel 三. zlib 安装 zlib 库提供了很多种压缩和解压缩的方式， nginx 使用 zlib 对 http 包的内容进行 gzip ，所以需要在 Centos 上安装 zlib 库。 1$ yum install -y zlib zlib-devel 四. OpenSSL 安装 OpenSSL 是一个强大的安全套接字层密码库，囊括主要的密码算法、常用的密钥和证书封装管理功能及 SSL 协议，并提供丰富的应用程序供测试或其它目的使用。nginx 不仅支持 http 协议，还支持 https（即在ssl协议上传输http），所以需要在 Centos 安装 OpenSSL 库。 1$ yum install -y openssl openssl-devel 五、官网下载 打开http://nginx.org/en/download.html 找到Stable version下的 nginx-1.12.0 右键 复制链接 使用wget命令下载 12$ cd /usr/local/$ wget -c http://nginx.org/download/nginx-1.12.0.tar.gz 解压12$ tar -zxvf nginx-1.12.0.tar.gz$ cd nginx-1.12.0 配置 使用默认配置 1$ ./configure 编译安装12$ make$ make install 查找安装路径：1$ whereis nginx 启动、停止nginx12345$ cd /usr/local/nginx/sbin/$ ./nginx $ ./nginx -s stop //此方式相当于先查出nginx进程id再使用kill命令强制杀掉进程。$ ./nginx -s quit //此方式停止步骤是待nginx进程处理任务完毕进行停止。$ ./nginx -s reload //重启，当 ngin x的配置文件 nginx.conf 修改后，要想让配置生效需要重启 nginx，使用-s reload不用先停止 ngin x再启动 nginx 即可将配置信息在 nginx 中生效 检验是否安装成功打开浏览器访问此机器的 IP，如果浏览器出现 Welcome to nginx! 则表示 Nginx 已经安装并运行成功。 开机自启动即在rc.local增加启动代码就可以了。1$ vi /etc/rc.local 增加一行 /usr/local/nginx/sbin/nginx 设置执行权限：1$ chmod 755 /etc/rc.local","tags":[{"name":"nginx","slug":"nginx","permalink":"http://yoursite.com/tags/nginx/"}]},{"title":"征服前端面试","date":"2017-05-31T08:52:12.000Z","path":"2017/05/31/前端面试整理/","text":"前言：以下是整理一些面试中经常会遇到的经典面试题以及自己面试过程中有一些未解决的问题，通过对知识的整理以及经验的总结，重新巩固自身的前端基础知识，如有错误或更好的答案，欢迎指正，水平有限，望各位不吝指教。:） JavaScript原型 我们创建的每一个函数，都可以有一个prototype属性，该属性指向一个对象。这个对象，就是原型。 当我们在创建对象时，可以根据自己的需求，选择性的将一些属性和方法通过prototype属性，挂载在原型对象上。而每一个new出来的实例，都有一个proto属性，该属性指向构造函数的原型对象，通过这个属性，让实例对象也能够访问原型对象上的方法。因此，当所有的实例都能够通过proto访问到原型对象时，原型对象的方法与属性就变成了共有方法与属性。 1234567891011121314// 声明构造函数function Person(name, age) &#123; this.name = name; this.age = age;&#125; // 通过prototye属性，将方法挂载到原型对象上Person.prototype.getName = function() &#123; return this.name;&#125; var p1 = new Person('tim', 10);var p2 = new Person('jak', 22);console.log(p1.getName === p2.getName); // true 通过图示我们可以看出，构造函数的prototype与所有实例对象的proto都指向原型对象。而原型对象的constructor指向构造函数。 原型链 我们知道所有的函数都有一个叫做toString的方法。那么这个方法到底是在哪里的呢？ 先随意声明一个函数： 1function foo() &#123;&#125; 其中foo是Function对象的实例。而Function的原型对象同时又是Object的实例。这样就构成了一条原型链。原型链的访问，其实跟作用域链有很大的相似之处，他们都是一次单向的查找过程。因此实例对象能够通过原型链，访问到处于原型链上对象的所有属性与方法。这也是foo最终能够访问到处于Object原型对象上的toString方法的原因。 作用域链作用域链的作用是保证执行环境里有权访问的变量和函数是有序的，作用域链的变量只能向上访问，变量访问到window对象即被终止，作用域链向下访问变量是不被允许的。 闭包 第一种理解（红宝书）：是指有权访问另一个函数作用域中的变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量 第二种理解（你不知道的javascript）：当函数可以记住并访问所在的词法作用域时，就产生了闭包，这个函数持有对该词法作用域的引用，这个引用就叫做闭包 闭包本质还是函数，只不过这个函数绑定了上下文环境（函数内部引用的所有变量） 缺点：常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。作用(使用场景)：可以用来管理私有变量和私有方法，将对变量（状态）的变化封装在安全的环境中，使得这些变量不能被外部随意修改，同时又可以通过指定的函数接口来操作。闭包有三个特性：1.函数嵌套函数2.函数内部可以引用外部的参数和变量3.参数和变量不会被垃圾回收机制回收 题外话： JavaScript的作用域就是词法作用域而不是动态作用域, 词法作用域最重要的特征是它的定义过程发生在代码的书写阶段 动态作用域的作用域链是基于调用栈的 词法作用域的作用域链是基于代码中的作用域嵌套 this JavaScript的this总是指向一个对象，而具体指向哪个对象是在运行时基于函数的执行环境动态绑定的，而非函数被声明时的环境。 this的指向： 1、作为普通函数调用（this指向全局对象window对象）2、作为对象的方法调用（this指向该对象）3、构造器调用（this指向用new返回的这个对象）4、call、apply、bind的调用（this指向第一个参数对象） 高阶函数1、函数作为参数传递2、函数作为返回值输出 new操作符具体干了什么呢?1、创建一个新对象2、将构造函数的作用域赋给新对象（因此this就指向了这个新对象）3、执行构造函数中的代码（为这个新对象添加属性）4、返回新对象 继承1、简单原型链继承1234567function Super()&#123; this.name = 'hzzly';&#125;function Sub()&#123; // ...&#125;Sub.prototype = new Super(); // 核心 缺点：修改sub1.name后sub2.name也变了，因为来自原型对象的引用属性是所有实例共享的。 2、构造函数式继承12345678910function Super(val)&#123; this.val = val; this.fun = function()&#123; // 实例函数 // ... &#125;&#125;function Sub(val)&#123; Super.call(this, val); // 核心 // ...&#125; 缺点：无法实现函数复用，每个子类实例都持有一个新的fun函数，太多了就会影响性能，内存爆炸。。 3、组合式继承123456789101112function Super()&#123; this.name = 'hzzly';&#125;// 原型函数Super.prototype.fun1 = function()&#123;&#125;;Super.prototype.fun2 = function()&#123;&#125;;//Super.prototype.fun3...function Sub()&#123; Super.call(this); // 核心 // ...&#125;Sub.prototype = new Super(); // 核心 缺点：子类原型上有一份多余的父类实例属性，因为父类构造函数被调用了两次，生成了两份，而子类实例上的那一份屏蔽了子类原型上父类的。。。又是内存浪费。 4、寄生组合式继承123456789101112function Super()&#123; this.name = 'hzzly';&#125;Super.prototype.fun1 = function()&#123;&#125;;Super.prototype.fun2 = function()&#123;&#125;;//Super.prototype.fun3...function Sub()&#123; Super.call(this); // 核心 // ...&#125;Sub.prototype=Object.create(Super.prototype) // 核心Sub.prototype.constructor=Sub // 核心 5、es6的class继承方式123456class A &#123;&#125;class B extends A &#123;&#125;B.__proto__ === A // trueB.prototype.__proto__ === A.prototype // true es6引入了class、extends、super、static(部分为ES2016标准) null和undefined的区别？1、null是一个表示”无”的对象，转为数值时为0；undefined是一个表示”无”的原始值，转为数值时为NaN。2、undefined表示”缺少值”，就是此处应该有一个值，但是还没有定义。3、null表示”没有对象”，即该处不应该有值。 call、apply、bind的区别 三者都是用来改变函数的this对象的指向的。 三者第一个参数都是this要指向的对象，也就是想指定的上下文。 call 传入的参数数量不固定，第二部分参数要一个一个传，用，隔开。 apply 接受两个参数，第二个参数为一个带下标的集合，可以为数组，也可以为类数组。 bind 是返回一个改变了上下文的函数副本，便于稍后调用；apply 、call 则是立即调用 。 本地存储 sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储。 localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。 具体参见：本地存储sessionStorage与localStorage cookie 和session1、cookie数据存放在客户的浏览器上，session数据放在服务器上。2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗，考虑到安全应当使用session。3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，考虑到减轻服务器性能方面，应当使用COOKIE。4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。每次请求一个新的页面的时候Cookie都会被发送过去，与服务器进行交互。 XML和JSON的区别？1、数据体积方面。JSON相对于XML来讲，数据的体积小，传递的速度更快些。2、数据交互方面。JSON与JavaScript的交互更加方便，更容易解析处理，更好的数据交互。3、数据描述方面。JSON对数据的描述性比XML较差。4、传输速度方面。JSON的速度要远远快于XML。 如何实现浏览器内多个标签页之间的通信?调用localstorge、cookies等本地存储方式 线程与进程的区别1、一个程序至少有一个进程,一个进程至少有一个线程.2、线程的划分尺度小于进程，使得多线程程序的并发性高。3、进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。4、线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。5、从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。 渐进增强和优雅降级 渐进增强 ：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。 优雅降级 ：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。 性能优化 网页内容 减少 http请求次数 减少 DNS查询次数 避免页面跳转 缓存 Ajax 延迟加载 提前加载 减少 DOM元素数量 避免 404 服务器 使用CDN(内容分发网络) 添加Expires或Cache-Control报文头 Gzip压缩传输文件 CSS 将样式表置顶 用代替@import JavaScript 把脚本置于页面底部 使用外部JavaScript和CSS 精简JavaScript和CSS 去除重复脚本 减少DOM访问 图片 优化图像 优化CSS Spirite 不要在HTML中缩放图片 favicon.ico要小而且可缓存 如何解决跨域问题?jsonp、CORS、document.domain+iframe、window.name、window.postMessage jsonp的原理是动态插入script标签 请解释一下 JavaScript 的同源策略。这里的同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议。 指一段脚本只能读取来自同一来源的窗口和文档的属性。 哪些操作会造成内存泄漏？1、内存泄漏指任何对象在您不再拥有或需要它之后仍然存在。2、垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收。3、setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环） Javascript垃圾回收方法1、标记清除：这是JavaScript最常见的垃圾回收方式，当变量进入执行环境的时候，比如函数中声明一个变量，垃圾回收器将其标记为“进入环境”，当变量离开环境的时候（函数执行结束）将其标记为“离开环境”。 2、引用计数：引用计数的策略是跟踪记录每个值被使用的次数，当声明了一个 变量并将一个引用类型赋值给该变量的时候这个值的引用次数就加1，如果该变量的值变成了另外一个，则这个值得引用次数减1，当这个值的引用次数变为0的时 候，说明没有变量在使用，这个值没法被访问了，因此可以将其占用的空间回收，这样垃圾回收器会在运行的时候清理掉引用次数为0的值占用的空间。 事件、IE与火狐的事件机制有什么区别？ 如何阻止冒泡？事件处理机制：IE是事件冒泡、firefox同时支持两种事件模型，也就是：捕获型事件和冒泡型事件。 阻止冒泡：ev.stopPropagation() 说说严格模式的限制 变量必须声明后再使用 函数的参数不能有同名属性，否则报错 禁止this指向全局对象 不能使用with语句 增加了保留字 arguments不会自动反映函数参数的变化 设立”严格模式”的目的： 消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为; 消除代码运行的一些不安全之处，保证代码运行的安全； 提高编译器效率，增加运行速度； 为未来新版本的Javascript做好铺垫。 请解释什么是事件代理事件代理（Event Delegation），又称之为事件委托。即是把原本需要绑定的事件委托给父元素，让父元素担当事件监听的职务。事件代理的原理是DOM元素的事件冒泡。使用事件代理的好处是可以提高性能。 Event Loop、消息队列、事件轮询异步函数在执行结束后，会在事件队列中添加一个事件（回调函数）(遵循先进先出原则)，主线程中的代码执行完毕后（即一次循环结束），下一次循环开始就在事件队列中“读取”事件，然后调用它所对应的回调函数。这个过程是循环不断的，所以整个的这种运行机制又称为Event Loop（事件循环） 主线程运行的时候，产生堆（heap）和栈（stack），栈中的代码（同步任务）调用各种外部API，它们在”任务队列”中加入各种事件（click，load，done）。只要栈中的代码执行完毕，主线程就会去读取”任务队列”，依次执行那些事件所对应的回调函数。 执行栈中的代码（同步任务），总是在读取”任务队列”（异步任务）之前执行。 缓存 浏览器缓存（Browser Caching）是浏览器端保存数据用于快速读取或避免重复资源请求的优化机制，有效的缓存使用可以避免重复的网络请求和浏览器快速地读取本地数据， http缓存 http缓存是基于HTTP协议的浏览器文件级缓存机制。即针对文件的重复请求情况下，浏览器可以根据协议头判断从服务器端请求文件还是从本地读取文件判断expires，如果未过期，直接读取http缓存文件 indexDB 是一个在客户端存储可观数量的结构化数据,并且为这些数据添加索引进行高性能检索。 cookie 指一般网站为了辨别用户身份、储存在用户本地终端上的数据（通常经过加密）。cookie一般通过http请求中在头部一起发送到服务器端。一条cookie记录主要由键、值、域、过期时间、大小组成，一般用户保存用户的认证信息。 localstorage localStorage是h5的一种新的本地缓存方案,加快下次页面打开时的渲染速度,除非主动删除数据，否则数据是永远不会过期的。 sessionstorage 也是h5的一种本地缓存方案，数据的存储仅特定于某个会话中，也就是说数据只保持到浏览器关闭，当浏览器关闭后重新打开这个页面时， 之前的存储已经被清除。 ES6ES6的了解es6是一个新的标准，它包含了许多新的语言特性和库，是JS最实质性的一次升级。比如’箭头函数’、’字符串模板’、’generators(生成器)’、’async/await’、’解构赋值’、’class’等等，还有就是引入module模块的概念。 箭头函数可以让this指向固定化，这种特性很有利于封装回调函数（1）函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。（2）不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。（3）不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用Rest参数代替。（4）不可以使用yield命令，因此箭头函数不能用作Generator函数。 async/await是写异步代码的新方式，以前的方法有回调函数和Promise。async/await是基于Promise实现的，它不能用于普通的回调函数。async/await与Promise一样，是非阻塞的。async/await使得异步代码看起来像同步代码，这正是它的魔力所在。 说说你对Promise的理解 Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件监听——更合理和更强大。 所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。 Promise对象有以下两个特点: 对象的状态不受外界影响，Promise对象代表一个异步操作，有三种状态：Pending（进行中）、Resolved（已完成，又称 Fulfilled）和Rejected（已失败） 一旦状态改变，就不会再变，任何时候都可以得到这个结果。 说说你对AMD和Commonjs的理解CommonJS是服务器端模块的规范，Node.js采用了这个规范。CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。AMD规范则是非同步加载模块，允许指定回调函数。 AMD推荐的风格通过返回一个对象做为模块对象，CommonJS的风格通过对module.exports或exports的属性赋值来达到暴露模块对象的目的。 Gulp、Webpack比较 Gulp 1、Gulp就是为了规范前端开发流程，实现前后端分离、模块化开发、版本控制、文件合并与压缩、mock数据等功能的一个前端自动化构建工具。2、Gulp就像是一个产品的流水线，整个产品从无到有，都要受流水线的控制，在流水线上我们可以对产品进行管理。3、Gulp是通过task对整个开发过程进行构建。 Webpack 1、当下最热门的前端资源模块化管理和打包工具2、可以很好的管理模块以及各个模块之间的依赖3、对js、css、图片等资源文件都支持打包4、有独立的配置文件webpack.config.js5、可以将代码切割成不同的chunk，实现按需加载，降低了初始化时间6、可以生成优化且合并后的静态资源 两大特色：1、代码可以自动完成编译。2、loader 可以处理各种类型的静态文件，并且支持串联操作 CSSdisplay:none和visibility:hidden的区别？display:none 隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，就当他从来不存在。 visibility:hidden 隐藏对应的元素，但是在文档布局中仍保留原来的空间。 position:absolute和float属性的异同A：共同点：对内联元素设置float和absolute属性，可以让元素脱离文档流，并且可以设置其宽高。 B：不同点：float仍会占据位置，position会覆盖文档流中的其他元素。 box-sizing属性 content-box：让元素维持W3C的标准盒模型。元素的宽度/高度由border + padding + content的宽度/高度决定，设置width/height属性指的是content部分的宽/高，一旦修改了元素的边框或内距，就会影响元素的盒子尺寸，就不得不重新计算元素的盒子尺寸，从而影响整个页面的布局。 border-box：让元素维持IE传统盒模型（IE6以下版本和IE6~7的怪异模式）。设置width/height属性指的是border + padding + content position的值 static 默认值。没有定位，元素出现在正常的流中 relative 生成相对定位的元素，相对于其在普通流中的位置进行定位。 absolute 生成绝对定位的元素， 相对于最近一级的 定位不是 static 的父元素来进行定位。 fixed （老IE不支持）生成绝对定位的元素，相对于浏览器窗口进行定位。 CSS3新特性CSS3实现圆角（border-radius），阴影（box-shadow），对文字加特效（text-shadow、），线性渐变（gradient），旋转（transform）transform:rotate(9deg) scale(0.85,0.90) translate(0px,-30px) skew(-9deg,0deg);//旋转,缩放,定位,倾斜增加了更多的CSS选择器 多背景 rgba在CSS3中唯一引入的伪元素是::selection.媒体查询，多栏布局border-image CSS sprites CSS Sprites 其实就是把网页中一些背景图片整合到一张图片文件中，再利用CSS的“background-image”，“background- repeat”，“background-position”的组合进行背景定位，background-position可以用数字能精确的定位出背景图片的位置。这样可以减少很多图片请求的开销，因为请求耗时比较长；请求虽然可以并发，但是也有限制，一般浏览器都是6个。对于未来而言，就不需要这样做了，因为有了http2。 解释下浮动和它的工作原理？清除浮动的技巧浮动元素脱离文档流，不占据空间。浮动元素碰到包含它的边框或者浮动元素的边框停留。1.使用空标签清除浮动。 这种方法是在所有浮动标签后面添加一个空标签 定义css clear:both. 弊端就是增加了无意义标签。2.使用overflow。 设置overflow为hidden或者auto，给包含浮动元素的父标签添加css属性 overflow:auto; zoom:1; zoom:1用于兼容IE6。3.使用after伪对象清除浮动。 该方法只适用于非IE浏览器。该方法中必须为需要清除浮动元素的伪对象中设置 height:0，否则该元素会比实际高出若干像素； 1234567#box:after&#123; content:\".\"; height:0; visibility:hidden; display:block; clear:both;&#125; 浮动元素引起的问题1、父元素的高度无法被撑开，影响与父元素同级的元素2、与浮动元素同级的非浮动元素（内联元素）会跟随其后3、若非第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面显示的结构 HTML说说你对语义化的理解1、去掉或者丢失样式的时候能够让页面呈现出清晰的结构2、有利于SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重；3、方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页；4、便于团队开发和维护，语义化更具可读性，是下一步吧网页的重要动向，遵循W3C标准的团队都遵循这个标准，可以减少差异化。 Doctype作用? 严格模式与混杂模式如何区分？它们有何意义?1、&lt;!DOCTYPE&gt; 告知浏览器的解析器用什么文档标准解析这个文档。2、严格模式的排版和 JS 运作模式是以该浏览器支持的最高标准运行。3、在混杂模式中，页面以宽松的向后兼容的方式显示。模拟老式浏览器的行为以防止站点无法工作。4、&lt;!DOCTYPE&gt; 不存在或格式不正确会导致文档以混杂模式呈现。 你知道多少种Doctype文档类型？该标签可声明三种 DTD 类型，分别表示严格版本、过渡版本以及基于框架的 HTML 文档。HTML 4.01 规定了三种文档类型：Strict、Transitional 以及 Frameset。XHTML 1.0 规定了三种 XML 文档类型：Strict、Transitional 以及 Frameset。Standards （标准）模式（也就是严格呈现模式）用于呈现遵循最新标准的网页，而 Quirks（包容）模式（也就是松散呈现模式或者兼容模式）用于呈现为传统浏览器而设计的网页。 HTML与XHTML——二者有什么区别1、所有的标记都必须要有一个相应的结束标记2、所有标签的元素和属性的名字都必须使用小写3、所有的XML标记都必须合理嵌套4、所有的属性必须用引号””括起来5、把所有&lt;和&amp;特殊符号用编码表示6、给所有属性赋一个值7、不要在注释内容中使“–”8、图片必须有说明文字 html5有哪些新特性语义化更好的内容标签（header,nav,footer,aside,article,section）音频、视频API(audio,video)画布(Canvas) API地理(Geolocation) API拖拽释放(Drag and drop) API本地离线存储表单控件，calendar、date、time、email、url、search 计算机网络HTTP请求类型GET：向特定的资源发出请求POST：向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的创建和/或已有资源的修改PUT：向指定资源位置上传其最新内容DELETE：请求服务器删除Request-URI所标识的资源OPTIONS：返回服务器针对特定资源所支持的HTTP请求方法。也可以利用向Web服务器发送’*’的请求来测试服务器的性能。 HTTP请求四部分1、HTTP请求的方法或动作，比如是get还是post请求；2、正在请求的URL（请求的地址）；3、请求头，包含一些客户端环境信息、身份验证信息等；4、请求体（请求正文），可以包含客户提交的查询字符串信息、表单信息等。 请求头字段： Accept:text/html,image/*(告诉服务器，浏览器可以接受文本，网页图片) Accept-Charaset:ISO-8859-1 [接受字符编码：iso-8859-1] Accept-Encoding:gzip,compress[可以接受 gzip,compress压缩后数据] Accept-Language:zh-cn[浏览器支持的语言] Host:localhost:8080[浏览器要找的主机] If-Modified-Since:Tue, 09 May 2017 01:34:02 GMT[告诉服务器我这缓存中有这个文件,该文件的时间是…] User-Agent:Nozilla/4.0(Com…)[告诉服务器我的浏览器内核，客户端环境信] Cookie：[身份验证信息] Connection:close/Keep-Alive [保持链接，发完数据后，我不关闭链接] HTTP响应三部分1、一个数字和文字组成的状态码，用来显示请求是成功还是失败；2、响应头，响应头也和请求头一样包含许多有用的信息，例如服务器类型、日期时间、内容类型和长度等；3、响应体（响应正文）。 响应头字段： Cache-Control:[告诉浏览器如何缓存页面(因为浏览器的兼容性最好设置两个)] Connection:close/Keep-Alive [保持链接，发完数据后，我不关闭链接] Content-Type:text/html;charset=gb2312[内容格式和编码] Last-Modified:Tue,11 Juj,2017 18 18:29:20[告诉浏览器该资源上次更新时间是多少] ETag:”540-54f0d59b8b680” Expires:Fri, 26 May 2017 13:28:33 GMT [失效日期] server:apache tomcat nginx [哪种服务器] 说说TCP传输的三次握手第一次握手，客户端给服务器发送数据包（带SYN标志的数据包）。此时服务器确认自己可以接收客户端的包，而客户端不确认服务器是否接收到了自己发的数据包。 第二次握手，服务器端回复（回传一个带有SYN/ACK标志的数据包以示传达确认信息）客户端。此时客户端确认自己发的包被服务器收到，也确认自己可以正常接收服务器包，客户端对此次通信没有疑问了。服务器也可以确认自己能接收到客户端的包，但不能确认客户端能否接收自己发的包。 第三次握手，客户端回复（发送端再回传一个带ACK标志的数据包，代表“握手”结束）服务器。 客户端已经没有疑问了，服务器也确认刚刚客户端收到了自己的数据包。两边都没有问题，开始通信。 为什么要三次握手：为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。也防止了服务器端的一直等待而浪费资源TCP作为一种可靠传输控制协议，其核心思想：既要保证数据可靠传输，又要提高传输的效率，而用三次恰恰可以满足以上两方面的需求！ 四次挥手1、主机向服务器发送一个断开连接的请求（ 不早了，我该走了 ）,发送一个FIN报文段；2、服务器接到请求后发送确认收到请求的信号（ 知道了 ）回一个ACK报文段；3、服务器向主机发送断开通知（ 我也该走了 ）发送FIN报文段，请求关闭连接；4、主机接到断开通知后断开连接并反馈一个确认信号（ 嗯，好的 ），服务器收到确认信号后也断开连接； TCP和UDP的区别TCP（Transmission Control Protocol，传输控制协议）是基于连接的协议，也就是说，在正式收发数据前，必须和对方建立可靠的连接。一个TCP连接必须要经过三次“对话”才能建立起来 UDP（User Data Protocol，用户数据报协议）是与TCP相对应的协议。它是面向非连接的协议，它不与对方建立连接，而是直接就把数据包发送过去！UDP适用于一次只传送少量数据、对可靠性要求不高的应用环境。 HTTP和HTTPS1、HTTP协议通常承载于TCP协议之上，在HTTP和TCP之间添加一个安全协议层（SSL或TSL），这个时候，就成了我们常说的HTTPS2、默认HTTP的端口号为80，HTTPS的端口号为443 HTTPS 相对于 HTTP 性能上差点，因为多了 SSL/TLS 的几次握手和加密解密的运算处理，但是加密解密的运算处理已经可以通过特有的硬件来加速处理。 什么是Etag？把Last-Modified和ETag请求的http报头一起使用，可利用客户端（例如浏览器）的缓存。ETag用于标识资源的状态，当资源发生变更时，如果其头信息中一个或者多个发生变化，或者消息实体发生变化，那么ETag也随之发生变化。浏览器下载组件的时候，会将它们存储到浏览器缓存中。如果需要再次获取相同的组件，浏览器将检查组件的缓存时间，假如已经过期，那么浏览器将发送一个条件GET请求到服务器，服务器判断缓存还有效，则发送一个304响应，告诉浏览器可以重用缓存组件。 Expires和Cache-ControlExpires 用来控制缓存的失效日期Cache-Control 用来控制网页的缓存 常见的取值有private、no-cache、max-age、must-revalidate等，默认为private。 关于Http 2.0 你知道多少？HTTP/2引入了“服务端推（server push）”的概念，它允许服务端在客户端需要数据之前就主动地将数据发送到客户端缓存中，从而提高性能。HTTP/2提供更多的加密支持HTTP/2使用多路技术，允许多个消息在一个连接上同时交差。它增加了头压缩（header compression），因此即使非常小的请求，其请求和响应的header都只会占用很小比例的带宽。 一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？1、浏览器根据请求的URL交给DNS域名解析，找到真实IP，向服务器发起请求（TCP三次握手）；2、服务器交给后台处理完成后返回数据，浏览器接收文件（HTML、JS、CSS、图象等）；3、浏览器对加载到的资源（HTML、JS、CSS等）进行语法解析，建立相应的内部数据结构（如HTML的DOM）；4、载入解析到的资源文件，渲染页面，完成。 浏览器的渲染过程1、浏览器请求到HTML代码后，在生成DOM的最开始阶段，并行发起css、图片、js的请求，无论他们是否在HEAD里。浏览器会将HTML解析成一个DOM树，DOM 树的构建过程是一个深度遍历过程：当前节点的所有子节点都构建好后才会去构建当前节点的下一个兄弟节点。2、CSS文件下载完成，开始构建CSSOM3、所有CSS文件下载完成，CSSOM构建结束后，和 DOM 一起生成 Render Tree。4、有了Render Tree，浏览器已经能知道网页中有哪些节点、各个节点的CSS定义以及他们的从属关系。下一步操作就是计算出每个节点在屏幕中的位置。5、最后一步，按照算出来的规则，把内容渲染到屏幕上。 以上五个步骤前3个步骤因为DOM、CSSOM、Render Tree都可能在第一次Painting后又被更新多次，比如JS修改了DOM或者CSS属性。Layout 和 Painting 也会被重复执行，除了DOM、CSSOM更新的原因外，图片下载完成后也需要调用Layout 和 Painting来更新网页。 display:none 的节点不会被加入 Render Tree，而 visibility: hidden 则会，所以，如果某个节点最开始是不显示的，设为 display:none 是更优的。 一个完整的URL包括以下几部分 http://www.hzzly.net:8080/news/index.php?boardID=5&amp;ID=24618&amp;page=1#name 1、协议部分2、域名部分3、端口部分4、虚拟目录部分：从域名后的第一个“/”开始到最后一个“/”为止5、文件名部分：从域名后的最后一个“/”开始到“？”为止6、参数部分：从“？”开始到“#”为止之间的部分7、锚部分：从“#”开始到最后 GET和POST的区别GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在1024字节，Get是通过地址栏来传值。 POST：一般用于修改服务器上的资源，对所发送的信息没有限制。（常用于发送表单数据，新建、修改等），Post是通过提交表单来传值。 常见HTTP状态码1xx（临时响应）表示临时响应并需要请求者继续执行操作的状态码。2xx（成功）表示成功处理了请求的状态码。200（成功）：服务器已成功处理了请求。通常，这表示服务器提供了请求的网页。3xx（重定向）要完成请求，需要进一步操作。301（永久移动）：请求的网页已永久移动到新位置。302（临时移动）：服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来响应以后的请求。304（未修改）：自从上次请求后，请求的网页未修改过。4xx（请求错误）这些状态码表示请求可能出错，妨碍了服务器的处理。400（错误请求）：服务器不理解请求的语法。404（未找到）：服务器找不到请求的网页。5xx（服务器错误）这些状态码表示服务器在处理请求时发生内部错误。500（服务器内部错误）：服务器遇到错误，无法完成请求。503（服务不可用）：服务器目前无法使用（由于超载或停机维护）。 说说网络分层里七层模型是哪七层应用层、表示层、会话层（从上往下）（HTTP、FTP、SMTP、DNS） 传输层（TCP和UDP） 网络层（IP） 物理和数据链路层（以太网） 讲讲304缓存的原理服务器首先产生ETag，服务器可在稍后使用它来判断页面是否已经被修改。本质上，客户端通过将该记号传回服务器要求服务器验证其（客户端）缓存。 304是HTTP状态码，服务器用来标识这个文件没修改，不返回内容，浏览器在接收到个状态码后，会使用浏览器已缓存的文件 http keep-alive与tcp keep-alivehttp keep-alive是为了让tcp活得更久一点，以便在同一个连接上传送多个http，提高socket的效率。而tcp keep-alive是TCP的一种检测TCP连接状况的保鲜机制。 常见web安全及防护原理 sql注入原理 就是通过把SQL命令插入到Web表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。 XSS 指的是攻击者往Web页面里插入恶意html标签或者javascript代码。比如：攻击者在论坛中放一个看似安全的链接，骗取用户点击后，窃取cookie中的用户私密信息；或者攻击者在论坛中加一个恶意表单，当用户提交表单的时候，却把信息传送到攻击者的服务器中，而不是用户原本以为的信任站点。 CSRF CSRF是代替用户完成指定的动作，需要知道其他用户页面的代码和数据包。要完成一次CSRF攻击，受害者必须依次完成两个步骤：1、登录受信任网站A，并在本地生成Cookie。2、在不登出A的情况下，访问危险网站B。 算法数组去重 建一个空对象和空数组，循环遍历需要去重的数组，判断对象有没有此属性，没有的话就给对象添加此属性，并向空数组中push这个值。 123456789101112131415//es5function unique(arr)&#123; var obj = &#123;&#125; var result = [] for(var i in arr)&#123; if(!obj[arr[i]])&#123; obj[arr[i]] = true; result.push(arr[i]); &#125; &#125; return result;&#125;//es6[...new Set(arr)] 冒泡排序 相邻两个对比，最后把最大的排到了最后，重复此过程。 12345678910111213function bubbleSort(arr) &#123; var len = arr.length; for (var i = 0; i &lt; len; i++) &#123; for (var j = 0; j &lt; len - 1 - i; j++) &#123; if (arr[j] &gt; arr[j+1]) &#123; //相邻元素两两对比 var temp = arr[j+1]; //元素交换 arr[j+1] = arr[j]; arr[j] = temp; &#125; &#125; &#125; return arr;&#125; 选择排序 寻找最小的数，保存索引，然后与第一层循环其下标对于的值进行交换 12345678910111213141516function selectionSort(arr) &#123; var len = arr.length; var minIndex, temp; for (var i = 0; i &lt; len - 1; i++) &#123; minIndex = i; for (var j = i + 1; j &lt; len; j++) &#123; if (arr[j] &lt; arr[minIndex]) &#123; //寻找最小的数 minIndex = j; //将最小数的索引保存 &#125; &#125; temp = arr[i]; arr[i] = arr[minIndex]; arr[minIndex] = temp; &#125; return arr;&#125; 快速排序 选取一个记录作为中间轴，然后将比‘这个记录值’小的移到‘记录值’之前，大的移到之后，然后递归 1234567891011121314151617function quickSort(arr) &#123; if(arr.length == 0) &#123; return []; // 返回空数组 &#125; var cIndex = Math.floor(arr.length / 2); var c = arr.splice(cIndex, 1); var l = []; var r = []; for (var i = 0; i &lt; arr.length; i++) &#123; if(arr[i] &lt; c) &#123; l.push(arr[i]); &#125; else &#123; r.push(arr[i]); &#125; &#125; return quickSort(l).concat(c, quickSort(r));&#125; 其它对前端界面工程师这个职位是怎么样理解的前端是最贴近用户的程序员，前端的能力就是能让产品从 90分进化到 100 分，甚至更好1、实现界面交互2、提升用户体验 谈谈你对重构的理解在不改变外部行为的前提下，简化结构、添加可读性，而在网站前端保持一致的行为。也就是说是在不改变UI的情况下，对网站进行优化，在扩展的同时保持一致的UI。 减少代码间的耦合让代码保持弹性严格按规范编写代码设计可扩展的API代替旧有的框架、语言(如VB)增强用户体验通常来说对于速度的优化也包含在重构中 你遇到过比较难的技术问题是？你是如何解决的？平时是如何学习前端开发的？平时如何管理你的项目？先期团队必须确定好全局样式（globe.css），编码模式(utf-8) 等； 编写习惯必须一致（例如都是采用继承式的写法，单样式都写成一行）； 标注样式编写人，各模块都及时标注（标注关键样式调用的地方）； 页面进行标注（例如 页面 模块 开始和结束）； CSS跟HTML 分文件夹并行存放，命名都得统一（例如style.css）； JS 分文件夹存放 命名以该JS功能为准的英文翻译。 图片采用整合的 images.png png8 格式文件使用尽量整合在一起使用方便将来的管理 说说最近最流行的一些东西吧？常去哪些网站？Node.js、Mongodb、npm、MVVM、MEAN、three.js、React、Vue、WebGL网站：掘金、segmentfault、Github、w3cplus、前端圈、知乎等","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"},{"name":"面试","slug":"面试","permalink":"http://yoursite.com/tags/面试/"}]},{"title":"Fetch学习笔记","date":"2017-05-20T15:52:22.000Z","path":"2017/05/20/Fetch学习笔记/","text":"前言: 前几天面试问到 Ajax和Fetch的区别，因为以前也用过这两个东西，所以也没难倒我，现在回头整理一遍。 fetch 与XMLHttpRequest(XHR)类似，fetch()方法允许你发出AJAX请求。区别在于Fetch API使用Promise，因此是一种简洁明了的API，比XMLHttpRequest更加简单易用。 如果还不了解Promise，可以移步👉浅谈Promise这篇博客 比较XMLHttpRequest（传统Ajax）创建步骤： 创建XMLHttpRequest对象，也就是创建一个异步调用对象 创建一个新的HTTP请求，并指定该HTTP请求的方法、URL及验证信息 发送HTTP请求 处理响应，获取异步调用返回的数据 可以发现，主要的不同点在于：传统Ajax使用事件处理器，而不是Promise对象，并且请求的发起完全依赖于xhr对象所提供的方法。 想详细了解 Ajax的封装可以查看我上一篇博客，一步步教你 Ajax的封装👉Ajax学习笔记 fetch语法12345678910fetch(url) .then(function(response) &#123; return response.json(); &#125;) .then(function(data) &#123; console.log(data); &#125;) .catch(function(e) &#123; console.log(\"Oops, error\"); &#125;); 使用 ES6 的 箭头函数1234fetch(url) .then(response =&gt; response.json()) .then(data =&gt; console.log(data)) .catch(e =&gt; console.log(\"Oops, error\", e)) 使用 async/await 来做最终优化： 123456789(async function () &#123; try &#123; let response = await fetch(url); let data = response.json(); console.log(data); &#125; catch(e) &#123; console.log(\"Oops, error\", e); &#125;&#125;)(); 使用 await 后，写异步代码就像写同步代码一样爽。await 后面可以跟 Promise 对象，表示等待 Promise resolve() 才会继续向下执行，如果 Promise 被 reject() 或抛出异常则会被外面的 try…catch 捕获。 如果还不了解async/await，可以移步👉es6Async这篇博客 GET请求123456789fetch(url, &#123; method: \"GET\", //默认 headers:&#123; \"Accept\": \"application/json, text/plain, */*\" &#125;&#125;).then(response =&gt; response.json()).then(data =&gt; console.log(data)).catch(e =&gt; console.log(\"Oops, error\", e)) POST请求1234567891011fetch(url, &#123; method: \"POST\", headers: &#123; \"Accept\": \"application/json, text/plain, */*\", \"Content-type\":\"application:/x-www-form-urlencoded; charset=UTF-8\" &#125;, body: \"name=hzzly&amp;age=22\"&#125;).then(response =&gt; response.json()).then(data =&gt; console.log(data)).catch(e =&gt; console.log(\"Oops, error\", e)) 使用Fetch请求发送凭证 要使用Fetch发送带有诸如cookie之类的凭证的请求。你可以在选项对象中将credentials属性值设置为“include”： 123fetch(url,&#123; credentials: \"include\"&#125;) 封装POST请求123456789101112131415161718192021222324252627282930313233//将对象拼接成 name=hzzly&amp;age=22 的字符串形式function params(obj) &#123; let result = '' for(let item in obj) &#123; result += `&amp;$&#123;item&#125;=$&#123;obj[item]&#125;` &#125; if(result) &#123; result = result.slice(1) &#125; return result&#125;function post(url, paramsObj) &#123; let result = fetch(url, &#123; methods: 'POST', credentials: \"include\" headers: &#123; \"Accept\": \"application/json, text/plain, */*\", \"Content-type\":\"application:/x-www-form-urlencoded; charset=UTF-8\" &#125;, body: params(paramsObj) &#125;) return result&#125;let obj = &#123; name: 'hzzly', age: 22&#125;post(url, obj) .then(response =&gt; response.json()) .then(data =&gt; console.log(data)) .catch(e =&gt; console.log(\"Oops, error\", e))","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"Fetch","slug":"Fetch","permalink":"http://yoursite.com/tags/Fetch/"}]},{"title":"Ajax学习笔记","date":"2017-05-17T14:53:25.000Z","path":"2017/05/17/Ajax学习笔记/","text":"在上一个外包项目中，因为用到了前后端分离的思路，所以都要通过Ajax来请求数据然后把数据渲染到页面上，一开始想过直接引用Jquery，但感觉就使用Jquery的Ajax函数，有点太浪费，所以就自己撸了一个Ajax函数。本文由浅入深，一步一步带你封装属于自己的Ajax库。 Ajax简介 Asynchronous Javascript And XML （异步的JavaScript和XML） 它并不是一种单一的技术，而是有机利用一系列交互式网页应用相关的技术所形成的结合体 Ajax是一种用于创建快速动态网页的技术。在前台与后台进行数据交换，Ajax可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，实现局部更新。 1、优点 页面无刷新，用户体验好。 异步通信，更加快的响应能力。 减少冗余请求，减轻了服务器负担。 基于标准化的并被广泛支持的技术 2、应用场景 场景 1. 数据验证 场景 2. 按需取数据 场景 3. 自动更新页面 … 说了这么多，接下来来点干货。 创建ajax的步骤 Ajax的原理简单来说通过XMLHttpRequest对象来向服务器发异步请求，从服务器获得数据，然后用javascript来操作DOM而更新页面。这其中最关键的一步就是从服务器获得请求数据。原生创建ajax可分为以下四步 1、创建XMLHttpRequest对象123456789function createRequest ()&#123; if (window.XMLHttpRequest) &#123; //IE6以上 xhr = new XMLHttpRequest(); &#125; else &#123; xhr = new ActiveXObject(\"Microsoft.XMLHTTP\"); &#125; return xhr;&#125; 2、准备请求1xhr.open(method,url,async); 第一个参数表示请求类型的字符串，其值可以是GET或者POSTGET请求： 1xhr.open(\"GET\",demo.php?name=hzzly&amp;age=21,true); POST请求： 1xhr.open(\"POST\",demo.php,true); 第二个参数是要作为请求发送目标的URL。 第三个参数是true或false，表示请求是以异步还是同步的模式发出。（默认为true，一般不建议为false） 3、发送请求1xhr.send(); GET请求： 12xhr.open(\"GET\",demo.php?name=hzzly&amp;age=21,true);xhr.send(); POST请求 123xhr.open(\"POST\",demo.php,true);xhr.setRequestHeder(\"Content-Type\",\"application/x-www-form-urlencoded;charset=UTF-8\");xhr.send(param) 4、处理响应12345xhr.onreadystatechange = function()&#123; if(xhr.readyState == 4 &amp;&amp; xhr.status == 200)&#123; console.log(xhr.responseText); &#125;&#125; onreadystatechange：当处理过程发生变化的时候执行下面的函数 readyState：ajax处理过程 0：请求未初始化（还没有调用 open()） 1：请求已经建立，但是还没有发送（还没有调用 send()） 2：请求已发送，正在处理中（通常现在可以从响应中获取内容头） 3：请求在处理中；通常响应中已有部分数据可用了，但是服务器还没有完成响应的生成 4：响应已完成；您可以获取并使用服务器的响应了 status属性: 200: “OK” 404: 未找到页面 responseText：获得字符串形式的响应数据，可以用JSON.parse(xhr.responseText)转化为JSON对象 封装例子 1.get请求函数 12345678910111213141516171819202122232425262728293031323334353637383940/** * 一个简单的get请求 * @param &#123;String&#125; url 请求地址,文件名 * @param &#123;Function&#125; fnSucc 请求成功时执行的函数 * @param &#123;Function&#125; fnFaild 请求失败执行的函数 */function Get(url, fnSucc, fnFaild) &#123; //1.创建ajax对象 var xhr = null; /** * 此处必须需要使用window.的方式,表示为window对象的一个属性.不存在时值为undefined. * 进入else若直接使用XMLHttpRequest在不支持的情况下会报错 **/ if (window.XMLHttpRequest) &#123; //IE6以上 xhr = new XMLHttpRequest(); &#125; else &#123; xhr = new ActiveXObject(\"Microsoft.XMLHTTP\"); &#125; //2.连接服务器 //open(方法,url,是否异步) xhr.open(\"GET\", url, true); //3.发送请求 xhr.send(); //4.接收返回 //OnRedayStateChange事件 xhr.onreadystatechange = function () &#123; if (xhr.readyState === 4) &#123; if (xhr.status === 200) &#123; //alert(\"成功\" + xhr.responseText); fnSucc(xhr.responseText); &#125; else &#123; //alert(\"服务器响应失败!\"); if (fnFaild) &#123; fnFaild(); &#125; &#125; &#125; &#125;;&#125; 2.get与post结合的请求函数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/** * AJAX函数封装 * @param &#123;string&#125; url 请求地址（必须） * @param &#123;object&#125; options 发送请求的选项参数 * @config &#123;string&#125; [options.type] 请求发送的类型。默认为GET。 * @config &#123;Object&#125; [options.data] 需要发送的数据。 * @config &#123;Function&#125; [options.onsuccess] 请求成功时触发。（必须） * @config &#123;Function&#125; [options.onfail] 请求失败时触发。 */function AJAX(url, options) &#123; //1.创建ajax对象 var xhr = null; /** * 此处必须需要使用window.的方式,表示为window对象的一个属性.不存在时值为undefined,进入else * 若直接使用XMLHttpRequest,在不支持的情况下会报错 **/ if (window.XMLHttpRequest) &#123; //IE6以上 xhr = new XMLHttpRequest(); &#125; else &#123; xhr = new ActiveXObject(\"Microsoft.XMLHTTP\"); &#125; //2.连接服务器 //open(方法,url,是否异步) var param = \"\"; //请求参数。 //只有data存在，且为对象使才执行 var data = options.data ? options.data : -1; //缓存data if (typeof (data) === \"object\") &#123; for (var key in data) &#123; //请求参数拼接 if (data.hasOwnProperty(key)) &#123; param += `$&#123;key&#125;=$&#123;data[key]&#125;&amp;`; &#125; &#125; param.replace(/&amp;$/, \"\"); &#125; else &#123; param = \"timestamp=\" + new Date().getTime(); &#125; //3.发送请求 var type = options.type ? options.type.toUpperCase() : \"GET\"; if (type === \"GET\") &#123; xhr.open(\"GET\", `$&#123;url&#125;?$&#123;param&#125;`, true); xhr.send(); &#125; else &#123; xhr.open(\"POST\", url, true); xhr.setRequestHeder(\"Content-Type\",\"application/x-www-form-urlencoded;charset=UTF-8\"); xhr.send(param); &#125; //4.接收返回 //OnRedayStateChange事件 xhr.onreadystatechange = function () &#123; if (xhr.readyState === 4) &#123; if (xhr.status === 200) &#123; //请求成功。形参为获取到的字符串形式的响应数据 options.onsuccess(xhr.responseText); &#125; else &#123; //先判断是否存在请求失败函数 //存在时，形参为XMLHttpRequest对象，便于进行错误进行处理 if (options.onfail) &#123; options.onfail(xhr); &#125; &#125; &#125; &#125;;&#125;","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"读书笔记-es6编程风格","date":"2017-05-15T12:48:47.000Z","path":"2017/05/15/读书笔记-es6编程风格/","text":"编程风格块级作用域 let 取代 var ES6提出了两个新的声明变量的命令：let和const。其中，let完全可以取代var，因为两者语义相同，而且let没有副作用。 全局常量和线程安全 在let和const之间，建议优先使用const，尤其是在全局环境，不应该设置变量，只应设置常量。12345678// badvar a = 1, b = 2, c = 3;// goodconst a = 1;const b = 2;const c = 3;// bestconst [a, b, c] = [1, 2, 3]; 了解更多👉：let与const 字符串 静态字符串一律使用单引号或反引号，不使用双引号。动态字符串使用反引号。 123456789// badconst a = \"foobar\";const b = 'foo' + a + 'bar';// acceptableconst c = `foobar`;// goodconst a = 'foobar';const b = `foo$&#123;a&#125;bar`;const c = 'foobar'; 了解更多👉：字符串的扩展 解构赋值 使用数组成员对变量赋值时，优先使用解构赋值。 函数的参数如果是对象的成员，优先使用解构赋值。 如果函数返回多个值，优先使用对象的解构赋值，而不是数组的解构赋值。这样便于以后添加返回值，以及更改返回值的顺序。 123const [first, second] = arr;function getFullName(&#123; firstName, lastName &#125;) &#123; &#125;const &#123; left, right &#125; = processInput(input); 了解更多👉：解构赋值 对象 单行定义的对象，最后一个成员不以逗号结尾。多行定义的对象，最后一个成员以逗号结尾。 12345const a = &#123; k1: v1, k2: v2 &#125;;const b = &#123; k1: v1, k2: v2,&#125;; 对象的属性和方法，尽量采用简洁表达法，这样易于描述和书写 12345678var ref = 'some value';const atom = &#123; ref, value: 1, addValue(value) &#123; return atom.value + value; &#125;,&#125;; 了解更多👉：对象的扩展 数组 使用扩展运算符（…）拷贝数组。 1const itemsCopy = [...items]; 使用Array.from方法，将类似数组的对象转为数组。 1234const foo = document.querySelectorAll('.foo');const nodes = Array.from(foo);//或者扩展运算符(...)const nodes = [...foo]; 了解更多👉：数组的扩展 函数 那些需要使用函数表达式的场合，尽量用箭头函数代替。因为这样更简洁，而且绑定了this。 使用rest运算符（…）代替参数 使用默认值语法设置函数参数的默认值。 1234567[1, 2, 3].map(x =&gt; x * x);function concatenateAll(...args) &#123; return args.join('');&#125;function handleThings(opts = &#123;&#125;) &#123; // ...&#125; 了解更多👉：函数的扩展 Class 总是用Class，取代需要prototype的操作。因为Class的写法更简洁，更易于理解。 使用extends实现继承，因为这样更简单，不会有破坏instanceof运算的危险。 1234567891011121314151617class A &#123; constructor(contents = []) &#123; ... &#125; getA() &#123; ... &#125;&#125;class B extends A &#123; constructor() &#123; super() ... &#125; getB() &#123; ... &#125;&#125; 了解更多👉：Class 模块 使用import取代require。 使用export取代module.exports。 1234import &#123; func1, func2 &#125; from 'moduleA';export default function () &#123; console.log('foo');&#125; 了解更多👉：Module","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"},{"name":"es6","slug":"es6","permalink":"http://yoursite.com/tags/es6/"}]},{"title":"读书笔记-es6Module","date":"2017-05-14T11:13:48.000Z","path":"2017/05/14/读书笔记-es6Module/","text":"Module概述 在 ES6 之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD 两种。前者用于服务器，后者用于浏览器。ES6 在语言标准的层面上，实现了模块功能，ES6 模块的设计思想，是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。比如，CommonJS 模块就是对象，输入时必须查找对象属性。 1234567// CommonJS模块let &#123; stat, exists, readFile &#125; = require('fs');// 等同于let _fs = require('fs');let stat = _fs.stat;let exists = _fs.exists;let readfile = _fs.readfile; 上面代码的实质是整体加载fs模块（即加载fs的所有方法），生成一个对象（_fs），然后再从这个对象上面读取3个方法。这种加载称为“运行时加载”，因为只有运行时才能得到这个对象，导致完全没办法在编译时做“静态优化”。 ES6 模块不是对象，而是通过export命令显式指定输出的代码，再通过import命令输入。 12// ES6模块import &#123; stat, exists, readFile &#125; from 'fs'; 上面代码的实质是从fs模块加载3个方法，其他方法不加载。这种加载称为“编译时加载”或者静态加载，即 ES6 可以在编译时就完成模块加载，效率要比 CommonJS 模块的加载方式高。 严格模式 ES6 的模块自动采用严格模式，不管你有没有在模块头部加上”use strict”;。 严格模式主要有以下限制: 变量必须声明后再使用 函数的参数不能有同名属性，否则报错 不能使用with语句 不能对只读属性赋值，否则报错 不能使用前缀0表示八进制数，否则报错 不能删除不可删除的属性，否则报错 不能删除变量delete prop，会报错，只能删除属性delete global[prop] eval不会在它的外层作用域引入变量 eval和arguments不能被重新赋值 arguments不会自动反映函数参数的变化 不能使用arguments.callee 不能使用arguments.caller 禁止this指向全局对象 不能使用fn.caller和fn.arguments获取函数调用的堆栈 增加了保留字（比如protected、static和interface） export 命令 export命令用于规定模块的对外接口 12345678910111213// 输出变量export let firstName = 'Michael';export let lastName = 'Jackson';export let year = 1958;//或者简写let firstName = 'Michael';let lastName = 'Jackson';let year = 1958;export &#123;firstName, lastName, year&#125;;//输出函数或类（class）export function multiply(x, y) &#123; return x * y;&#125;; import 命令 import命令用于输入其他模块提供的功能，import命令具有提升效果，会提升到整个模块的头部，首先执行 1234import &#123;firstName, lastName, year&#125; from './index';function setName(element) &#123; element.textContent = firstName + ' ' + lastName;&#125; as关键字1234//为输入的变量重新取一个名字import &#123; lastName as surname &#125; from './index';//模块整体加载import * as circle from './circle' export default 命令 为模块指定默认输出 1234567// export-default.jsexport default function () &#123; console.log('foo');&#125;// import-default.jsimport customName from './export-default';customName(); // 'foo' 栗子一个 vuex 模块（module）实例123456789101112131415161718192021222324252627282930313233//com.jsimport * as types from '../types'const state = &#123; showLoading: false,&#125;const actions = &#123; setShowLoading(&#123; commit &#125;, status) &#123; commit(types.COM_SHOW_LOADING, status) &#125;&#125;const getters = &#123; showLoading: state =&gt; state.showLoading,&#125;const mutations = &#123; [types.COM_SHOW_LOADING](state, status) &#123; state.showLoading = status &#125;,&#125;export default &#123; state, actions, getters, mutations&#125;//serach.vueimport &#123; mapGetters &#125; from 'vuex'computed: &#123; //mapGetters(map: Array&lt;string&gt; | Object): Object,创建组件的计算属性返回 getter 的返回值 //使用对象展开运算符将 getters 混入 computed 对象中 ...mapGetters([ 'showLoading' ])&#125;,","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"},{"name":"es6","slug":"es6","permalink":"http://yoursite.com/tags/es6/"}]},{"title":"读书笔记-es6Class的继承","date":"2017-05-13T14:14:52.000Z","path":"2017/05/13/读书笔记-es6Class的继承/","text":"Class的继承一、基本用法 Class之间可以通过extends关键字实现继承，这比ES5的通过修改原型链实现继承，要清晰和方便很多。 123456789class ColorPoint extends Point &#123; constructor(x, y, color) &#123; super(x, y); // 调用父类的constructor(x, y) this.color = color; &#125; toString() &#123; return this.color + ' ' + super.toString(); // 调用父类的toString() &#125;&#125; 子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。如果不调用super方法，子类就得不到this对象。 ES5的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面（Parent.apply(this)）。ES6的继承机制完全不同，实质是先创造父类的实例对象this（所以必须先调用super方法），然后再用子类的构造函数修改this。 在子类的构造函数中，只有调用super之后，才可以使用this关键字，否则会报错。这是因为子类实例的构建，是基于对父类实例加工，只有super方法才能返回父类实例。12345678910111213class Point &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125;&#125;class ColorPoint extends Point &#123; constructor(x, y, color) &#123; this.color = color; // ReferenceError super(x, y); this.color = color; // 正确 &#125;&#125; 下面是生成子类实例的代码，这与ES5的行为完全一致。123let cp = new ColorPoint(25, 8, 'green');cp instanceof ColorPoint // truecp instanceof Point // true 二、类的prototype属性和proto属性 大多数浏览器的ES5实现之中，每一个对象都有proto属性，指向对应的构造函数的prototype属性。Class作为构造函数的语法糖，同时有prototype属性和proto属性，因此同时存在两条继承链。1）子类的proto属性，表示构造函数的继承，总是指向父类。2）子类prototype属性的proto属性，表示方法的继承，总是指向父类的prototype属性。 123456class A &#123;&#125;class B extends A &#123;&#125;B.__proto__ === A // trueB.prototype.__proto__ === A.prototype // true 三、Object.getPrototypeOf() Object.getPrototypeOf方法可以用来从子类上获取父类。可以使用这个方法判断，一个类是否继承了另一个类。 12Object.getPrototypeOf(ColorPoint) === Point// true 四、super 关键字 super这个关键字，既可以当作函数使用，也可以当作对象使用。在这两种情况下，它的用法完全不同。1) super作为函数调用时，代表父类的构造函数。ES6 要求，子类的构造函数必须执行一次super函数。 123456class A &#123;&#125;class B extends A &#123; constructor() &#123; super(); &#125;&#125; 注意，super虽然代表了父类A的构造函数，但是返回的是子类B的实例，即super内部的this指的是B，因此super()在这里相当于A.prototype.constructor.call(this)。 2) super作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。 12345678910111213class A &#123; p() &#123; return 2; &#125;&#125;class B extends A &#123; constructor() &#123; super(); console.log(super.p()); // 2 //super.p() 相当于 A.prototype.p() &#125;&#125;let b = new B(); 由于super指向父类的原型对象，所以定义在父类实例上的方法或属性，是无法通过super调用的。123456789101112class A &#123; constructor() &#123; this.p = 2; &#125;&#125;class B extends A &#123; get m() &#123; return super.p; &#125;&#125;let b = new B();b.m // undefined 如果属性定义在父类的原型对象上，super就可以取到。123456789class A &#123;&#125;A.prototype.x = 2;class B extends A &#123; constructor() &#123; super(); console.log(super.x) // 2 &#125;&#125;let b = new B(); ES6 规定，通过super调用父类的方法时，super会绑定子类的this。 12345678910111213141516171819class A &#123; constructor() &#123; this.x = 1; &#125; print() &#123; console.log(this.x); &#125;&#125;class B extends A &#123; constructor() &#123; super(); this.x = 2; &#125; m() &#123; super.print(); &#125;&#125;let b = new B();b.m() // 2 上面代码中，super.print()虽然调用的是A.prototype.print()，但是A.prototype.print()会绑定子类B的this，导致输出的是2，而不是1。也就是说，实际上执行的是super.print.call(this)。 五、实例的proto属性 子类实例的proto属性的proto属性，指向父类实例的proto属性。也就是说，子类的原型的原型，是父类的原型 1234var p1 = new Point(2, 3);var p2 = new ColorPoint(2, 3, 'red');p2.__proto__ === p1.__proto__ // falsep2.__proto__.__proto__ === p1.__proto__ // true 因此，通过子类实例的proto.proto属性，可以修改父类实例的行为。1234p2.__proto__.__proto__.printName = function () &#123; console.log('Ha');&#125;;p1.printName() // \"Ha\" 上面代码在ColorPoint的实例p2上向Point类添加方法，结果影响到了Point的实例p1。 六、原生构造函数的继承 Boolean() Number() String() Array() Date() Function() RegExp() Error() Object() 以前，这些原生构造函数是无法继承的，比如，不能自己定义一个Array的子类。ES6可以自定义原生数据结构（比如Array、String等）的子类，这是ES5无法做到的。1234567891011121314151617181920212223class VersionedArray extends Array &#123; constructor() &#123; super(); this.history = [[]]; &#125; commit() &#123; this.history.push(this.slice()); &#125; revert() &#123; this.splice(0, this.length, ...this.history[this.history.length - 1]); &#125;&#125;var x = new VersionedArray();x.push(1);x.push(2);x // [1, 2]x.history // [[]]x.commit();x.history // [[], [1, 2]]x.push(3);x // [1, 2, 3]x.revert();x // [1, 2]","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"},{"name":"es6","slug":"es6","permalink":"http://yoursite.com/tags/es6/"}]},{"title":"读书笔记-es6Class","date":"2017-05-11T15:46:21.000Z","path":"2017/05/11/读书笔记-es6Class/","text":"Class一、Class基本语法传统方法:12345678function Point(x, y) &#123; this.x = x; this.y = y;&#125;Point.prototype.toString = function () &#123; return '(' + this.x + ', ' + this.y + ')';&#125;;var p = new Point(1, 2); ES6:12345678910class Point &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125; toString() &#123; return '(' + this.x + ', ' + this.y + ')'; &#125;&#125;var p = new Point(1, 2); ES6的类，完全可以看作构造函数的另一种写法: 12345class Point &#123; // ...&#125;typeof Point // \"function\"Point === Point.prototype.constructor // true 构造函数的prototype属性，在ES6的“类”上面继续存在。事实上，类的所有方法都定义在类的prototype属性上面。 12345678910111213141516class Point &#123; constructor()&#123; // ... &#125; toString()&#123; // ... &#125; toValue()&#123; // ... &#125;&#125;// 等同于Point.prototype = &#123; toString()&#123;&#125;, toValue()&#123;&#125;&#125;; 在类的实例上面调用方法，其实就是调用原型上的方法。 123class B &#123;&#125;let b = new B();b.constructor === B.prototype.constructor // true 由于类的方法都定义在prototype对象上面，所以类的新方法可以添加在prototype对象上面。Object.assign方法可以很方便地一次向类添加多个方法。 1234567891011class Point &#123; constructor()&#123; // ... &#125;&#125;Object.assign(Point.prototype, &#123; toString()&#123;&#125;, toValue()&#123;&#125;&#125;);//prototype对象的constructor属性，直接指向“类”的本身，这与ES5的行为是一致的。Point.prototype.constructor === Point // true 类的内部所有定义的方法，都是不可枚举的（non-enumerable）。这一点与ES5的行为不一致。 二、constructor方法 constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加。 三、类的实例对象 生成类的实例对象的写法，与ES5完全一样，也是使用new命令。如果忘记加上new，像函数那样调用Class，将会报错。 1234// 报错var point = Point(2, 3);// 正确var point = new Point(2, 3); 与ES5一样，实例的属性除非显式定义在其本身（即定义在this对象上），否则都是定义在原型上（即定义在class上）。 12345678910111213141516class Point &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125; toString() &#123; return '(' + this.x + ', ' + this.y + ')'; &#125;&#125;var point = new Point(2, 3);point.toString() // (2, 3)point.hasOwnProperty('x') // truepoint.hasOwnProperty('y') // truepoint.hasOwnProperty('toString') // falsepoint.__proto__.hasOwnProperty('toString') // true 上面代码中，x和y都是实例对象point自身的属性（因为定义在this变量上），所以hasOwnProperty方法返回true，而toString是原型对象的属性（因为定义在Point类上），所以hasOwnProperty方法返回false。这些都与ES5的行为保持一致。 与ES5一样，类的所有实例共享一个原型对象。 123var p1 = new Point(2,3);var p2 = new Point(3,2);p1.__proto__ === p2.__proto__ //true 上面代码中，p1和p2都是Point的实例，它们的原型都是Point.prototype，所以proto属性是相等的。 这也意味着，可以通过实例的proto属性为Class添加方法。1234567var p1 = new Point(2,3);var p2 = new Point(3,2);p1.__proto__.printName = function () &#123; return 'Oops' &#125;;p1.printName() // \"Oops\"p2.printName() // \"Oops\"var p3 = new Point(4,2);p3.printName() // \"Oops\" 上面代码在p1的原型上添加了一个printName方法，由于p1的原型就是p2的原型，因此p2也可以调用这个方法。而且，此后新建的实例p3也可以调用这个方法。这意味着，使用实例的proto属性改写原型，必须相当谨慎，不推荐使用，因为这会改变Class的原始定义，影响到所有实例。 四、不存在变量提升 Class不存在变量提升（hoist），这一点与ES5完全不同。 12new Foo(); // ReferenceErrorclass Foo &#123;&#125; 五、Class表达式 采用Class表达式，可以写出立即执行的Class。 123456789let person = new class &#123; constructor(name) &#123; this.name = name; &#125; sayName() &#123; console.log(this.name); &#125;&#125;('张三');person.sayName(); // \"张三\" 六、私有方法 私有方法是常见需求，但 ES6 不提供，只能通过变通方法模拟实现。 在命名上加以区别:1234567891011class Widget &#123; // 公有方法 foo (baz) &#123; this._bar(baz); &#125; // 私有方法 _bar(baz) &#123; return this.snaf = baz; &#125; // ...&#125; 上面代码中，_bar方法前面的下划线，表示这是一个只限于内部使用的私有方法。但是，这种命名是不保险的，在类的外部，还是可以调用到这个方法。 七、this的指向 类的方法内部如果含有this，它默认指向类的实例 八、Class的取值函数（getter）和存值函数（setter） 与ES5一样，在Class内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。 12345678910111213141516class MyClass &#123; constructor() &#123; // ... &#125; get prop() &#123; return 'getter'; &#125; set prop(value) &#123; console.log('setter: '+value); &#125;&#125;let inst = new MyClass();inst.prop = 123;// setter: 123inst.prop// 'getter' Github地址： https://github.com/hzzly/learn-es6 文章来源hzzly博客技术分享","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"},{"name":"es6","slug":"es6","permalink":"http://yoursite.com/tags/es6/"}]},{"title":"读书笔记-es6Async函数栗子","date":"2017-05-10T12:07:22.000Z","path":"2017/05/10/读书笔记-es6Async函数栗子/","text":"async函数栗子栗子一：从豆瓣 API 获取数据123456789101112131415161718192021222324252627282930313233var fetchDoubanApi = function() &#123; return new Promise((resolve, reject) =&gt; &#123; var xhr = new XMLHttpRequest(); xhr.onreadystatechange = function() &#123; if (xhr.readyState === 4) &#123; if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) &#123; var response; try &#123; response = JSON.parse(xhr.responseText); &#125; catch (e) &#123; reject(e); &#125; if (response) &#123; resolve(response, xhr.status, xhr); &#125; &#125; else &#123; reject(xhr); &#125; &#125; &#125;; xhr.open('GET', 'https://api.douban.com/v2/user/aisk', true); xhr.setRequestHeader(\"Content-Type\", \"text/plain\"); xhr.send(data); &#125;);&#125;;(async function() &#123; try &#123; let result = await fetchDoubanApi(); console.log(result); &#125; catch (e) &#123; console.log(e); &#125;&#125;)(); 栗子二：根据电影文件名，自动下载对应的海报12345678910111213141516171819202122232425262728293031323334353637import fs from 'fs';import path from 'path';import request from 'request';var movieDir = __dirname + '/movies', exts = ['.mkv', '.avi', '.mp4', '.rm', '.rmvb', '.wmv'];// 读取文件列表var readFiles = function () &#123; return new Promise(function (resolve, reject) &#123; fs.readdir(movieDir, function (err, files) &#123; resolve(files.filter((v) =&gt; exts.includes(path.parse(v).ext))); &#125;); &#125;);&#125;;// 获取海报var getPoster = function (movieName) &#123; let url = `https://api.douban.com/v2/movie/search?q=$&#123;encodeURI(movieName)&#125;`; return new Promise(function (resolve, reject) &#123; request(&#123;url: url, json: true&#125;, function (error, response, body) &#123; if (error) return reject(error); resolve(body.subjects[0].images.large); &#125;) &#125;);&#125;;// 保存海报var savePoster = function (movieName, url) &#123; request.get(url).pipe(fs.createWriteStream(path.join(movieDir, movieName + '.jpg')));&#125;;(async () =&gt; &#123; let files = await readFiles(); // await只能使用在原生语法 for (var file of files) &#123; let name = path.parse(file).name; console.log(`正在获取【$&#123;name&#125;】的海报`); savePoster(name, await getPoster(name)); &#125; console.log('=== 获取海报完成 ===');&#125;)();","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"},{"name":"es6","slug":"es6","permalink":"http://yoursite.com/tags/es6/"}]},{"title":"读书笔记-es6Async函数","date":"2017-05-09T06:41:45.000Z","path":"2017/05/09/读书笔记-es6Async函数/","text":"async 函数 async 函数，使得异步操作变得更加方便。它是 Generator 函数的语法糖。 Generator 函数，依次读取两个文件:123456789101112131415var fs = require('fs');var readFile = function (fileName) &#123; return new Promise(function (resolve, reject) &#123; fs.readFile(fileName, function(error, data) &#123; if (error) reject(error); resolve(data); &#125;); &#125;);&#125;;var gen = function* () &#123; var f1 = yield readFile('/etc/fstab'); var f2 = yield readFile('/etc/shells'); console.log(f1.toString()); console.log(f2.toString());&#125;; 写成async函数，就是下面这样:123456var asyncReadFile = async function () &#123; var f1 = await readFile('/etc/fstab'); var f2 = await readFile('/etc/shells'); console.log(f1.toString()); console.log(f2.toString());&#125;; async函数对 Generator 函数的改进，体现在以下四点: 1）内置执行器 Generator 函数的执行必须靠执行器，所以才有了co模块，而async函数自带执行器。也就是说，async函数的执行，与普通函数一模一样，只要一行。1var result = asyncReadFile(); 上面的代码调用了asyncReadFile函数，然后它就会自动执行，输出最后结果。这完全不像 Generator 函数，需要调用next方法，或者用co模块，才能真正执行，得到最后结果。 2）更好的语义 async和await，比起星号和yield，语义更清楚了。async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果。 3）更广的适用性 co模块约定，yield命令后面只能是 Thunk 函数或 Promise 对象，而async函数的await命令后面，可以是Promise 对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）。 4）返回值是 Promise async函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用then方法指定下一步的操作。 进一步说，async函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而await命令就是内部then命令的语法糖。 一、基本用法 async函数返回一个 Promise 对象，可以使用then方法添加回调函数。当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。 12345678910function timeout(ms) &#123; return new Promise((resolve) =&gt; &#123; setTimeout(resolve, ms); &#125;);&#125;async function asyncPrint(value, ms) &#123; await timeout(ms); console.log(value);&#125;asyncPrint('hello world', 5000); 上面代码指定5000毫秒以后，输出hello world。 由于async函数返回的是 Promise 对象，可以作为await命令的参数。所以，上面的例子也可以写成下面的形式:12345678910async function timeout(ms) &#123; await new Promise((resolve) =&gt; &#123; setTimeout(resolve, ms); &#125;);&#125;async function asyncPrint(value, ms) &#123; await timeout(ms); console.log(value);&#125;asyncPrint('hello world', 5000); async 函数多种使用形式123456789101112131415161718192021// 函数声明async function foo() &#123;&#125;// 函数表达式const foo = async function () &#123;&#125;;// 对象的方法let obj = &#123; async foo() &#123;&#125; &#125;;obj.foo().then(...)// Class 的方法class Storage &#123; constructor() &#123; this.cachePromise = caches.open('avatars'); &#125; async getAvatar(name) &#123; const cache = await this.cachePromise; return cache.match(`/avatars/$&#123;name&#125;.jpg`); &#125;&#125;const storage = new Storage();storage.getAvatar('hzzly').then(…);// 箭头函数const foo = async () =&gt; &#123;&#125;; 二、语法 async函数的语法规则总体上比较简单，难点是错误处理机制。 返回 Promise 对象 async函数返回一个 Promise 对象。async函数内部return语句返回的值，会成为then方法回调函数的参数。 12345async function f() &#123; return 'hello world';&#125;f().then(v =&gt; console.log(v))// \"hello world\" Promise 对象的状态变化 async函数返回的 Promise 对象，必须等到内部所有await命令后面的 Promise 对象执行完，才会发生状态改变，除非遇到return语句或者抛出错误。也就是说，只有async函数内部的异步操作执行完，才会执行then方法指定的回调函数。 1234567async function getTitle(url) &#123; let response = await fetch(url); let html = await response.text(); return html.match(/&lt;title&gt;([\\s\\S]+)&lt;\\/title&gt;/i)[1];&#125;getTitle('https://tc39.github.io/ecma262/').then(console.log)// \"ECMAScript 2017 Language Specification\" 上面代码中，函数getTitle内部有三个操作：抓取网页、取出文本、匹配页面标题。只有这三个操作全部完成，才会执行then方法里面的console.log。 三、使用注意点 await命令后面的Promise对象，运行结果可能是rejected，所以最好把await命令放在try…catch代码块中。 1234567891011121314async function myFunction() &#123; try &#123; await somethingThatReturnsAPromise(); &#125; catch (err) &#123; console.log(err); &#125;&#125;// 另一种写法async function myFunction() &#123; await somethingThatReturnsAPromise() .catch(function (err) &#123; console.log(err); &#125;;&#125; 多个await命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。 12345678910//异步操作（即互不依赖），被写成继发关系。这样比较耗时，因为只有getFoo完成以后，才会执行getBar，完全可以让它们同时触发。let foo = await getFoo();let bar = await getBar();// 写法一let [foo, bar] = await Promise.all([getFoo(), getBar()]);// 写法二let fooPromise = getFoo();let barPromise = getBar();let foo = await fooPromise;let bar = await barPromise; await命令只能用在async函数之中，如果用在普通函数，就会报错。 下一节将介绍 async 函数的栗子(🌰)，敬请期待。。。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"},{"name":"es6","slug":"es6","permalink":"http://yoursite.com/tags/es6/"}]},{"title":"读书笔记-es6Generator函数","date":"2017-05-08T14:27:47.000Z","path":"2017/05/08/读书笔记-es6Generator函数/","text":"Generator函数 从语法上，可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。调用 Generator 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象(遍历器对象)。Generator 函数是分段执行的，yield表达式是暂停执行的标记，而next方法可以恢复执行。Generator 函数也不能跟new命令一起用，会报错。 1234567891011121314function* helloWorldGenerator() &#123; yield 'hello'; yield 'world'; return 'ending';&#125;var hw = helloWorldGenerator();hw.next()// &#123; value: 'hello', done: false &#125;hw.next()// &#123; value: 'world', done: false &#125;hw.next()// &#123; value: 'ending', done: true &#125;hw.next()// &#123; value: undefined, done: true &#125; 总结一下，调用 Generator 函数，返回一个遍历器对象，代表 Generator 函数的内部指针。以后，每次调用遍历器对象的next方法，就会返回一个有着value和done两个属性的对象。value属性表示当前的内部状态的值，是yield表达式后面那个表达式的值；done属性是一个布尔值，表示是否遍历结束。 写法1234function * foo(x, y) &#123; ··· &#125;function *foo(x, y) &#123; ··· &#125;function* foo(x, y) &#123; ··· &#125;function*foo(x, y) &#123; ··· &#125; 一、yield 表达式 由于 Generator 函数返回的遍历器对象，只有调用next方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。yield表达式就是暂停标志。 遍历器对象的next方法的运行逻辑如下:1）遇到yield表达式，就暂停执行后面的操作，并将紧跟在yield后面的那个表达式的值，作为返回的对象的value属性值。2）下一次调用next方法时，再继续往下执行，直到遇到下一个yield表达式。3）如果没有再遇到新的yield表达式，就一直运行到函数结束，直到return语句为止，并将return语句后面的表达式的值，作为返回的对象的value属性值。4）如果该函数没有return语句，则返回的对象的value属性值为undefined。 123456function* gen() &#123; yield 123 + 456;&#125;var g = gen()gen.next()//&#123; value: 579, done: false &#125; 二、for…of 循环 for…of循环可以自动遍历 Generator 函数时生成的Iterator对象，且此时不再需要调用next方法。 123456789101112function *foo() &#123; yield 1; yield 2; yield 3; yield 4; yield 5; return 6;&#125;for (let v of foo()) &#123; console.log(v);&#125;// 1 2 3 4 5 这里需要注意，一旦next方法的返回对象的done属性为true，for…of循环就会中止，且不包含该返回对象，所以上面代码的return语句返回的6，不包括在for…of循环之中。 除了for…of循环以外，扩展运算符（…）、解构赋值和Array.from方法内部调用的，都是遍历器接口。这意味着，它们都可以将 Generator 函数返回的 Iterator 对象，作为参数。 1234567891011121314151617181920function* numbers () &#123; yield 1 yield 2 return 3 yield 4&#125;// 扩展运算符[...numbers()] // [1, 2]// Array.from 方法Array.from(numbers()) // [1, 2]// 解构赋值let [x, y] = numbers();x // 1y // 2// for...of 循环for (let n of numbers()) &#123; console.log(n)&#125;// 1// 2 三、作为对象属性的Generator函数1234567891011let obj = &#123; * myGeneratorMethod() &#123; ··· &#125;&#125;;//等同于let obj = &#123; myGeneratorMethod: function* () &#123; // ··· &#125;&#125;; 四、应用 1）异步操作的同步化表达 12345678910function* loadUI() &#123; showLoadingScreen(); yield loadUIDataAsynchronously(); hideLoadingScreen();&#125;var loader = loadUI();// 加载UIloader.next()// 卸载UIloader.next() 123456789101112function* main() &#123; var result = yield request(\"http://some.url\"); var resp = JSON.parse(result); console.log(resp.value);&#125;function request(url) &#123; makeAjaxCall(url, function(response)&#123; it.next(response); &#125;);&#125;var it = main();it.next(); 2）控制流管理 123456789step1(function (value1) &#123; step2(value1, function(value2) &#123; step3(value2, function(value3) &#123; step4(value3, function(value4) &#123; // Do something with value4 &#125;); &#125;); &#125;);&#125;); 采用 Promise 改写上面的代码。12345678910Promise.resolve(step1) .then(step2) .then(step3) .then(step4) .then(function (value4) &#123; // Do something with value4 &#125;, function (error) &#123; // Handle any error from step1 through step4 &#125;) .done(); Generator 函数可以进一步改善代码运行流程。1234567891011121314151617181920function* longRunningTask(value1) &#123; try &#123; var value2 = yield step1(value1); var value3 = yield step2(value2); var value4 = yield step3(value3); var value5 = yield step4(value4); // Do something with value4 &#125; catch (e) &#123; // Handle any error from step1 through step4 &#125;&#125;scheduler(longRunningTask(initialValue));function scheduler(task) &#123; var taskObj = task.next(task.value); // 如果Generator函数未结束，就继续调用 if (!taskObj.done) &#123; task.value = taskObj.value scheduler(task); &#125;&#125;","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"},{"name":"es6","slug":"es6","permalink":"http://yoursite.com/tags/es6/"}]},{"title":"读书笔记-es6Set和Map数据结构","date":"2017-05-07T11:10:28.000Z","path":"2017/05/07/读书笔记-es6Set和Map数据结构/","text":"Set和Map数据结构一、Set 它类似于数组，但是成员的值都是唯一的，没有重复的值。Set 本身是一个构造函数，用来生成 Set 数据结构。 123456const s = new Set();[2, 3, 5, 4, 5, 2, 2].forEach(x =&gt; s.add(x));for (let i of s) &#123; console.log(i);&#125;// 2 3 5 4 Set 函数可以接受一个数组（或类似数组的对象）作为参数，用来初始化。 12345678910111213141516// 例一const set = new Set([1, 2, 3, 4, 4]);[...set]// [1, 2, 3, 4]// 例二const items = new Set([1, 2, 3, 4, 5, 5, 5, 5]);items.size // 5// 例三function divs () &#123; return [...document.querySelectorAll('div')];&#125;const set = new Set(divs());set.size // 56// 类似于divs().forEach(div =&gt; set.add(div));set.size // 56 去除数组重复成员的方法。 12// 去除数组的重复成员[...new Set(array)] 二、Set 实例的属性和方法 属性 Set.prototype.constructor：构造函数，默认就是Set函数。 Set.prototype.size：返回Set实例的成员总数。 方法 add(value)：添加某个值，返回Set结构本身。 delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。 has(value)：返回一个布尔值，表示该值是否为Set的成员。 clear()：清除所有成员，没有返回值。 三、遍历操作 keys()：返回键名的遍历器 values()：返回键值的遍历器 entries()：返回键值对的遍历器 forEach()：使用回调函数遍历每个成员 123456789101112131415161718192021222324252627282930313233let set = new Set(['red', 'green', 'blue']);for (let item of set.keys()) &#123; console.log(item);&#125;// red// green// bluefor (let item of set.values()) &#123; console.log(item);&#125;// red// green// bluefor (let item of set.entries()) &#123; console.log(item);&#125;// [\"red\", \"red\"]// [\"green\", \"green\"]// [\"blue\", \"blue\"]let set = new Set([1, 2, 3]);set.forEach((value, key) =&gt; console.log(value * 2) )// 2// 4// 6let set = new Set([1, 2, 3]);set = new Set([...set].map(x =&gt; x * 2));// 返回Set结构：&#123;2, 4, 6&#125;let set = new Set([1, 2, 3, 4, 5]);set = new Set([...set].filter(x =&gt; (x % 2) == 0));// 返回Set结构：&#123;2, 4&#125;let arr = [3, 5, 2, 2, 5, 5];let unique = [...new Set(arr)];// [3, 5, 2] 四、Map 它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。 123456789const map = new Map([ ['name', '张三'], ['title', 'Author']]);map.size // 2map.has('name') // truemap.get('name') // \"张三\"map.has('title') // truemap.get('title') // \"Author\" 五、Map 实例的属性和方法 属性 Map.prototype.constructor：构造函数，默认就是Map函数。 Map.prototype.size：返回Map实例的成员总数。 方法 set(key, value)：set方法设置键名key对应的键值为value，然后返回整个 Map 结构。如果key已经有值，则键值会被更新，否则就新生成该键。可以采用链式写法。 get(key)：get方法读取key对应的键值，如果找不到key，返回undefined。 has(key)：has方法返回一个布尔值，表示某个键是否在当前 Map 对象之中。 delete(key)：delete方法删除某个键，返回true。如果删除失败，返回false。 clear(): clear方法清除所有成员，没有返回值。 六、遍历操作和 Set 一样","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"},{"name":"es6","slug":"es6","permalink":"http://yoursite.com/tags/es6/"}]},{"title":"读书笔记-es6对象的扩展","date":"2017-05-06T02:17:56.000Z","path":"2017/05/06/读书笔记-es6对象的扩展/","text":"对象的扩展一、属性和方法的简洁表示法12345678910111213141516171819202122var foo = 'bar';var baz = &#123;foo&#125;;baz // &#123;foo: \"bar\"&#125;// 等同于var baz = &#123;foo: foo&#125;;var o = &#123; method() &#123; return \"Hello!\"; &#125;&#125;;// 等同于var o = &#123; method: function() &#123; return \"Hello!\"; &#125;&#125;;//如果某个方法的值是一个Generator函数，前面需要加上星号。var obj = &#123; * m()&#123; yield 'hello world'; &#125;&#125;; 用于函数的返回值，将会非常方便 1234567function getPoint() &#123; var x = 1; var y = 10; return &#123;x, y&#125;;&#125;getPoint()// &#123;x:1, y:10&#125; CommonJS模块输出变量，就非常合适使用简洁写法。 1234567891011121314151617var ms = &#123;&#125;;function getItem (key) &#123; return key in ms ? ms[key] : null;&#125;function setItem (key, value) &#123; ms[key] = value;&#125;function clear () &#123; ms = &#123;&#125;;&#125;module.exports = &#123; getItem, setItem, clear &#125;;// 等同于module.exports = &#123; getItem: getItem, setItem: setItem, clear: clear&#125;; 二、Object.is() Object.is它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。 三、Object.assign() Object.assign方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target） 123456var target = &#123; a: 1 &#125;;var source1 = &#123; b: 2 &#125;;var source2 = &#123; c: 3 &#125;;Object.assign(target, source1, source2);target // &#123;a:1, b:2, c:3&#125;//如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。 Object.assign方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。 1234var obj1 = &#123;a: &#123;b: 1&#125;&#125;;var obj2 = Object.assign(&#123;&#125;, obj1);obj1.a.b = 2;obj2.a.b // 2 对于这种嵌套的对象，一旦遇到同名属性，Object.assign的处理方法是替换，而不是添加。 1234var target = &#123; a: &#123; b: 'c', d: 'e' &#125; &#125;var source = &#123; a: &#123; b: 'hello' &#125; &#125;Object.assign(target, source)// &#123; a: &#123; b: 'hello' &#125; &#125; Object.assign常见用途 1）为对象添加属性 12345class Point &#123; constructor(x, y) &#123; Object.assign(this, &#123;x, y&#125;); &#125;&#125; 上面方法通过Object.assign方法，将x属性和y属性添加到Point类的对象实例。 2）为对象添加方法 123456789101112131415Object.assign(SomeClass.prototype, &#123; someMethod(arg1, arg2) &#123; ··· &#125;, anotherMethod() &#123; ··· &#125;&#125;);// 等同于下面的写法SomeClass.prototype.someMethod = function (arg1, arg2) &#123; ···&#125;;SomeClass.prototype.anotherMethod = function () &#123; ···&#125;; 3）克隆对象 123function clone(origin) &#123; return Object.assign(&#123;&#125;, origin);&#125; 上面代码将原始对象拷贝到一个空对象，就得到了原始对象的克隆。 不过，采用这种方法克隆，只能克隆原始对象自身的值，不能克隆它继承的值。如果想要保持继承链，可以采用下面的代码。1234function clone(origin) &#123; let originProto = Object.getPrototypeOf(origin); return Object.assign(Object.create(originProto), origin);&#125; 4）合并多个对象 12const merge = (target, ...sources) =&gt; Object.assign(target, ...sources); 如果希望合并后返回一个新对象，可以改写上面函数，对一个空对象合并。12const merge = (...sources) =&gt; Object.assign(&#123;&#125;, ...sources); 四、属性的遍历 1）for…in for…in循环遍历对象自身的和继承的可枚举属性（不含Symbol属性）。 2）Object.keys(obj) Object.keys返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含Symbol属性）。 3）Object.getOwnPropertyNames(obj) Object.getOwnPropertyNames返回一个数组，包含对象自身的所有属性（不含Symbol属性，但是包括不可枚举属性）。 4）Object.getOwnPropertySymbols(obj) Object.getOwnPropertySymbols返回一个数组，包含对象自身的所有Symbol属性。 5）Reflect.ownKeys(obj) Reflect.ownKeys返回一个数组，包含对象自身的所有属性，不管属性名是Symbol或字符串，也不管是否可枚举。12Reflect.ownKeys(&#123; [Symbol()]:0, b:0, 10:0, 2:0, a:0 &#125;)// ['2', '10', 'b', 'a', Symbol()] 五、Object.keys()，Object.values()，Object.entries() Object.keys方法，返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键名。 Object.values方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值。Object.values只返回对象自身的可遍历属性。Object.values会过滤属性名为 Symbol 值的属性。如果Object.values方法的参数是一个字符串，会返回各个字符组成的一个数组。 Object.entries方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对数组。如果原对象的属性名是一个 Symbol 值，该属性会被忽略。Object.entries的基本用途是遍历对象的属性。另一个用处是，将对象转为真正的Map结构。 1234567891011121314151617181920212223var obj = &#123; foo: 'bar', baz: 42 &#125;;Object.keys(obj)// [\"foo\", \"baz\"]var obj = &#123; foo: 'bar', baz: 42 &#125;;Object.values(obj)// [\"bar\", 42]var obj = &#123; 100: 'a', 2: 'b', 7: 'c' &#125;;Object.values(obj)// [\"b\", \"c\", \"a\"]var obj = &#123; foo: 'bar', baz: 42 &#125;;Object.entries(obj)// [ [\"foo\", \"bar\"], [\"baz\", 42] ]let &#123;keys, values, entries&#125; = Object;let obj = &#123; a: 1, b: 2, c: 3 &#125;;for (let key of keys(obj)) &#123; console.log(key); // 'a', 'b', 'c'&#125;for (let value of values(obj)) &#123; console.log(value); // 1, 2, 3&#125;for (let [key, value] of entries(obj)) &#123; console.log([key, value]); // ['a', 1], ['b', 2], ['c', 3]&#125; 六、对象的扩展运算符 扩展运算符（…）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。 12345678910let z = &#123; a: 3, b: 4 &#125;;let n = &#123; ...z &#125;;n // &#123; a: 3, b: 4 &#125;let aClone = &#123; ...a &#125;;// 等同于let aClone = Object.assign(&#123;&#125;, a);//合并两个对象let ab = &#123; ...a, ...b &#125;;// 等同于let ab = Object.assign(&#123;&#125;, a, b); Github地址： https://github.com/hzzly/learn-es6","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"},{"name":"es6","slug":"es6","permalink":"http://yoursite.com/tags/es6/"},{"name":"JavaScrip","slug":"JavaScrip","permalink":"http://yoursite.com/tags/JavaScrip/"}]},{"title":"读书笔记-es6函数的扩展","date":"2017-05-05T08:26:01.000Z","path":"2017/05/05/读书笔记-es6函数的扩展/","text":"函数的扩展一、函数参数的默认值 参数变量是默认声明的，所以不能用let或const再次声明 通常情况下，定义了默认值的参数，应该是函数的尾参数 123456function log(x, y = 'World') &#123; console.log(x, y);&#125;log('Hello') // Hello Worldlog('Hello', 'China') // Hello Chinalog('Hello', '') // Hello 二、与解构赋值默认值结合使用1234567function foo(&#123;x, y = 5&#125;) &#123; console.log(x, y);&#125;foo(&#123;&#125;) // undefined, 5foo(&#123;x: 1&#125;) // 1, 5foo(&#123;x: 1, y: 2&#125;) // 1, 2foo() // TypeError: Cannot read property 'x' of undefined 三、rest参数 ES6 引入 rest 参数（形式为“…变量名”），用于获取函数的多余参数，这样就不需要使用arguments对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。 rest 参数之后不能再有其他参数（即只能是最后一个参数），否则会报错 12345678910111213141516function add(...values) &#123; let sum = 0; for (var val of values) &#123; sum += val; &#125; return sum;&#125;add(2, 5, 3) // 10function push(array, ...items) &#123; items.forEach(function(item) &#123; array.push(item); console.log(item); &#125;);&#125;var a = [];push(a, 1, 2, 3) 四、扩展运算符(…) 它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。扩展运算符内部调用的是数据结构的Iterator接口 1234567891011121314console.log(...[1, 2, 3])// 1 2 3console.log(1, ...[2, 3, 4], 5)// 1 2 3 4 5[...document.querySelectorAll('div')]// [&lt;div&gt;, &lt;div&gt;, &lt;div&gt;]function push(array, ...items) &#123; array.push(...items);&#125;function add(x, y) &#123; return x + y;&#125;let numbers = [4, 38];add(...numbers) // 42 栗子： 替代数组的apply方法 123456// ES5的写法Math.max.apply(null, [14, 3, 77])// ES6的写法Math.max(...[14, 3, 77])// 等同于Math.max(14, 3, 77); 合并数组 12345678910111213// ES5[1, 2].concat(more)// ES6[1, 2, ...more]var arr1 = ['a', 'b'];var arr2 = ['c'];var arr3 = ['d', 'e'];// ES5的合并数组arr1.concat(arr2, arr3);// [ 'a', 'b', 'c', 'd', 'e' ]// ES6的合并数组[...arr1, ...arr2, ...arr3]// [ 'a', 'b', 'c', 'd', 'e' ] 与解构赋值结合 123456789const [first, ...rest] = [1, 2, 3, 4, 5];first // 1rest // [2, 3, 4, 5]const [first, ...rest] = [];first // undefinedrest // []:const [first, ...rest] = [\"foo\"];first // \"foo\"rest // [] 五、箭头函数 箭头函数可以让this指向固定化，这种特性很有利于封装回调函数 （1）函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。 （2）不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。 （3）不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用Rest参数代替。 （4）不可以使用yield命令，因此箭头函数不能用作Generator函数。12345678910111213var f = () =&gt; 5;// 等同于var f = function () &#123; return 5 &#125;;var f = v =&gt; v;//等同于：var f = function(v) &#123; return v;&#125;;var sum = (num1, num2) =&gt; num1 + num2;// 等同于var sum = function(num1, num2) &#123; return num1 + num2;&#125;; 箭头函数简化回调函数 123456// 正常函数写法[1,2,3].map(function (x) &#123; return x * x;&#125;);// 箭头函数写法[1,2,3].map(x =&gt; x * x); 箭头函数可以让setTimeout里面的this，绑定定义时所在的作用域，而不是指向运行时所在的作用域 123456789101112131415function Timer() &#123; this.s1 = 0; this.s2 = 0; // 箭头函数 setInterval(() =&gt; this.s1++, 1000); // 普通函数 setInterval(function () &#123; this.s2++; &#125;, 1000);&#125;var timer = new Timer();setTimeout(() =&gt; console.log('s1: ', timer.s1), 3100);setTimeout(() =&gt; console.log('s2: ', timer.s2), 3100);// s1: 3// s2: 0 因为所有的内层函数都是箭头函数，都没有自己的this，它们的this其实都是最外层foo函数的this 12345678910111213function foo() &#123; return () =&gt; &#123; return () =&gt; &#123; return () =&gt; &#123; console.log('id:', this.id); &#125;; &#125;; &#125;;&#125;var f = foo.call(&#123;id: 1&#125;);var t1 = f.call(&#123;id: 2&#125;)()(); // id: 1var t2 = f().call(&#123;id: 3&#125;)(); // id: 1var t3 = f()().call(&#123;id: 4&#125;); // id: 1 Github地址： https://github.com/hzzly/learn-es6","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"},{"name":"es6","slug":"es6","permalink":"http://yoursite.com/tags/es6/"},{"name":"JavaScrip","slug":"JavaScrip","permalink":"http://yoursite.com/tags/JavaScrip/"}]},{"title":"读书笔记-es6数组的扩展","date":"2017-05-04T15:22:23.000Z","path":"2017/05/04/读书笔记-es6数组的扩展/","text":"数组的扩展一、Array.from() 将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括ES6新增的数据结构Set和Map） 123456789101112131415161718192021//类似数组的对象let arrayLike = &#123; '0': 'a', '1': 'b', '2': 'c', length: 3&#125;;// ES5的写法var arr1 = [].slice.call(arrayLike); // ['a', 'b', 'c']// ES6的写法let arr2 = Array.from(arrayLike); // ['a', 'b', 'c']// NodeList对象let ps = document.querySelectorAll('p');Array.from(ps).forEach(function (p) &#123; console.log(p);&#125;);// arguments对象function foo() &#123; var args = Array.from(arguments); // ...&#125; 扩展运算符（…）也可以将某些数据结构转为数组 二、Array.of() 用于将一组值，转换为数组 123Array.of(3, 11, 8) // [3,11,8]Array.of(3) // [3]Array.of(3).length // 1 三、数组实例的copyWithin() 在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组 target（必需）：从该位置开始替换数据。 start（可选）：从该位置开始读取数据，默认为0。如果为负值，表示倒数。 end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。 1234567[1, 2, 3, 4, 5].copyWithin(0, 3)// [4, 5, 3, 4, 5][1, 2, 3, 4, 5].copyWithin(0, 3, 4)// [4, 2, 3, 4, 5]// -2相当于3号位，-1相当于4号位[1, 2, 3, 4, 5].copyWithin(0, -2, -1)// [4, 2, 3, 4, 5] 四、数组实例的find()和findIndex() find方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。 findIndex返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。 12345678[1, 4, -5, 10].find((n) =&gt; n &lt; 0)// -5[1, 5, 10, 15].find(function(value, index, arr) &#123; return value &gt; 9;&#125;) // 10[1, 5, 10, 15].findIndex(function(value, index, arr) &#123; return value &gt; 9;&#125;) // 2 五、数组实例的fill() 使用给定值，填充一个数组 12345['a', 'b', 'c'].fill(7)// [7, 7, 7]//从1号位开始，向原数组填充7，到2号位之前结束['a', 'b', 'c'].fill(7, 1, 2)// ['a', 7, 'c'] 六、数组实例的entries()，keys()和values() keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历 123456789101112131415for (let index of ['a', 'b'].keys()) &#123; console.log(index);&#125;// 0// 1for (let elem of ['a', 'b'].values()) &#123; console.log(elem);&#125;// 'a'// 'b'for (let [index, elem] of ['a', 'b'].entries()) &#123; console.log(index, elem);&#125;// 0 \"a\"// 1 \"b\" 七、数组实例的includes() 返回一个布尔值，表示某个数组是否包含给定的值，与字符串的includes方法类似,方法的第二个参数表示搜索的起始位置，默认为0 123[1, 2, 3].includes(2); // true[1, 2, 3].includes(4); // false[1, 2, NaN].includes(NaN); // true 八、数组的空位 forEach(), filter(), every() 和some()都会跳过空位 map()会跳过空位，但会保留这个值 join()和toString()会将空位视为undefined，而undefined和null会被处理成空字符串 1234567891011121314// forEach方法[,'a'].forEach((x,i) =&gt; console.log(i)); // 1// filter方法['a',,'b'].filter(x =&gt; true) // ['a','b']// every方法[,'a'].every(x =&gt; x==='a') // true// some方法[,'a'].some(x =&gt; x !== 'a') // false// map方法[,'a'].map(x =&gt; 1) // [,1]// join方法[,'a',undefined,null].join('#') // \"#a##\"// toString方法[,'a',undefined,null].toString() // \",a,,\" ES6则是明确将空位转为undefined。尽量建议避免出现空位。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"},{"name":"es6","slug":"es6","permalink":"http://yoursite.com/tags/es6/"}]},{"title":"读书笔记-es6数值的扩展","date":"2017-05-03T15:03:20.000Z","path":"2017/05/03/读书笔记-es6数值的扩展/","text":"数值的扩展一、Number.isFinite(), Number.isNaN() Number.isFinite() 检查一个数值是否为有限的（finite） Number.isNaN() 检查一个值是否为NaN 1234567891011121314151617//Number.isFinite()Number.isFinite(15); // trueNumber.isFinite(0.8); // trueNumber.isFinite(NaN); // falseNumber.isFinite(Infinity); // falseNumber.isFinite(-Infinity); // falseNumber.isFinite('foo'); // falseNumber.isFinite('15'); // falseNumber.isFinite(true); // false//Number.isNaN()Number.isNaN(NaN) // trueNumber.isNaN(15) // falseNumber.isNaN('15') // falseNumber.isNaN(true) // falseNumber.isNaN(9/NaN) // trueNumber.isNaN('true'/0) // trueNumber.isNaN('true'/'true') // true 二、Number.parseInt(), Number.parseFloat() 全局方法parseInt()和parseFloat()，移植到Number对象上面，行为完全保持不变。 12Number.parseInt === parseInt // trueNumber.parseFloat === parseFloat // true 三、Number.isInteger() 判断一个值是否为整数 12345Number.isInteger(25) // trueNumber.isInteger(25.0) // trueNumber.isInteger(25.1) // falseNumber.isInteger(\"15\") // falseNumber.isInteger(true) // false 四、安全整数和Number.isSafeInteger() JavaScript能够准确表示的整数范围在-2^53到2^53之间（不含两个端点），超过这个范围，无法精确表示这个值。Number.isSafeInteger() 用来判断一个整数是否落在这个范围之内 五、Math.trunc() 去除一个数的小数部分，返回整数部分 六、Math.sign() 判断一个数到底是正数、负数、还是零 参数为正数，返回+1； 参数为负数，返回-1； 参数为0，返回0； 参数为-0，返回-0; 其他值，返回NaN。 七、Math.signbit() 判断一个数的符号位是否设置了 如果参数是NaN，返回false 如果参数是-0，返回true 如果参数是负值，返回true 其他情况返回false 1234Math.signbit(2) //falseMath.signbit(-2) //trueMath.signbit(0) //falseMath.signbit(-0) //true 八、指数运算符( ** )122 ** 2 // 42 ** 3 // 8 Github地址： https://github.com/hzzly/learn-es6","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"},{"name":"es6","slug":"es6","permalink":"http://yoursite.com/tags/es6/"},{"name":"JavaScrip","slug":"JavaScrip","permalink":"http://yoursite.com/tags/JavaScrip/"}]},{"title":"DIY一个自己的音乐播放器","date":"2017-04-27T06:47:55.000Z","path":"2017/04/27/DIY一个自己的音乐播放器/","text":"前言：在最近的一个外包项目中包联盟(PC端)中使用到了video，遇到了好多坑。突发奇想来踩一踩audio的坑😀，果然一入深似海，👇下面将分享我的DIY之路-Vue音乐播放器。注：本项目为开源项目，不能用于商业应用，仅供学习。有问题或建议发我邮箱：hjingren@aliyun.com [温馨提示：pc浏览f12手机模式最佳,手机建议wifi下访问] 预览地址： http://hzzly.net/magic-musicGithub地址： https://github.com/hzzly/MagicMusic欢迎大家的star啦😄~ 先来个预览： 更多预览：更多 👉老铁们，准备发车(技能点)： vue文档 vue-router文档 vuex文档 不想看文档的可以看看我这篇博客vuex学习实践笔记 axios文档 或者这篇博客 Vuex2 与 Axios 开发(我也是参考这篇，感谢作者😁) es6(阮一峰的es6入门) 可以参考我的es6之路(还在继续,轻喷) flex (Web的flex弹性盒模型) 移动端屏幕适配的解决 (flexible+rem) 本地存储(sessionStorage、localStorage) 图片懒加载 👉坐好，出发 实现的功能1、首页 [x] 轮播 [x] 个性推荐[流行、古典、轻音乐、流行] [x] 歌曲操作 [x] 加入播放列表 [ ] 喜欢 [ ] 分享 2、底部播放控件 [x] 播放 [x] 暂停 [x] 下一曲 [x] 播放进度条 3、播放页面 [x] 上一曲 [x] 播放 [x] 暂停 [x] 下一曲 [x] 播放进度条[弧形进度条] [x] 歌词滚动 [x] 播放的歌词高亮 [ ] 播放模式[单曲循环、列表循环、随机播放] 4、播放列表 [x] 播放歌曲高亮 [x] 切歌(单击切歌) [x] 删歌(点击右侧小X) [ ] 清空播放列表 [ ] 本地缓存播放列表 5、排行榜 [x] 热门排行榜 [x] 排行榜里的歌曲(单击播放) 6、音乐搜索输入搜索关键词，点击放大镜图标 [x] 单曲(单击或点击歌曲操作(…)添加至音乐播放列表，部分音乐会存在版权问题无法播放) [x] 歌手 [x] 专辑 [x] 歌单 [x] 用户 [x] 本地缓存搜索列表 7、侧边栏 [x] 头像 [x] 菜单 [x] 个人中心 API感谢作者把api整理的这么好(点个赞👍) 网易云音乐 NodeJS 版 API 目录结构123456789101112131415161718192021222324252627282930313233343536|——MagicMusic/| |——build/| |——confg/| |——node_modules/| |——src/| | |——assets/ //静态文件| | |——components/ //公共组件| | |——api/| | | |——index.js //axios封装与api| | |——pages/ //存放项目页面| | | |——classical.vue //古典歌曲页面| | | |——collection.vue //排行榜| | | |——home.vue //首页| | | |——light.vue //轻音乐歌曲页面| | | |——login.vue //登录页面| | | |——popular.vue //流行歌曲页面| | | |——radio.vue //电台歌曲页面| | | |——rank.vue //排行榜列表| | | |——search.vue //搜索页| | | |——user.vue //用户| | |——router/ | | | |——index.js //页面路由| | |——util //公用方法| | |——vuex / //存放vuex代码| | | |——modules / //数据模块| | | |——store.js //vuex主入口| | | |——types.js //vuex的types文件| | |——App.vue //父组件| | |——main.js //入口文件| |——static/| |——.babelrc| |——.editorconfig| |——.gitgnore| |——index.html| |——package.json| |——README.md 开发心得与总结1、轮播图首先感谢作者ShanaMaid/vue-image-scroll开源的代码，我把代码copy下来自己进行了一点修改(没有手指滑动效果)，因为这是移动端，少不了的手指滑动切换，所以添加了vue-touch(偷偷告诉你，vue-touch的next分支还是支持vue2.0的😜)。代码传送门1234567891011121314151617&lt;li v-for=\"(item,index) in image\" :class=\"[move[index]]\"&gt; &lt;v-touch class=\"vuetouch\" v-on:swipeleft=\"nextPic\" v-on:swiperight=\"prePic\"&gt; ... &lt;/v-touch&gt;&lt;/li&gt;methods: &#123; nextPic(event) &#123; let temp = this.move.pop() this.move.unshift(temp) &#125;, prePic(event) &#123; let temp = this.move.shift() this.move.push(temp) &#125;,&#125; 2、歌曲操作(喜欢，分享，加入播放列表)动画、播放列表展开与删除歌曲动画 Vue提供了transition的封装组件，在下列情形中，可以给任何元素和组件添加 entering/leaving 过渡 条件渲染 （使用 v-if） 条件展示 （使用 v-show） 动态组件 组件根节点 12345678910&lt;transition name=\"move\"&gt; &lt;div class=\"menu\" v-show=\"item.menuShow\"&gt; ... &lt;/div&gt;&lt;/transition&gt;&lt;transition-group name=\"slide\" tag=\"div\" class=\"list-wrapper\"&gt; &lt;div class=\"item\" v-for=\"(item, index) in listenLists\" :key=\"item\"&gt; ... &lt;/div&gt;&lt;/transition-group&gt; transition-group一组过度动画，这里有个小坑的，之前看官网列表过渡的栗子，给每一项设置唯一的key值，一般都会用index。所以在做的时候就把index传给key，结果过渡老是不对，后来换成对应的item就正常了(生无可恋脸)。 3、直线进度条、弧形进度条 西班牙建筑大师曾说过：“直线属于人类，曲线则归于上帝”。在这里我大胆的使用了弧形来作为进度条，(几大热门音乐APP貌似还没有弧形进度条😄)。 这里我用到了Vue的绑定内联样式123456789101112//直线进度条&lt;div class=\"progress-bar\"&gt; &lt;div class=\"play\" :style=\"&#123;width: (now / duration).toFixed(3)*100 + '%'&#125;\"&gt;&lt;/div&gt;&lt;/div&gt;//弧形进度条//因为用到了弧形，所以我这里用到了`border-radius`来使它变成一个大圆，然后平移`translateX`居中，其它不要的部分`overflow: hidden`。//这里用两个div来表示进度条，一条固定的进度条，一条慢慢增加。&lt;div class=\"process\" @click=\"showToast\"&gt; &lt;div class=\"line\"&gt;&lt;/div&gt; &lt;div class=\"pro\" :style=\"&#123;transform: `translateX($&#123;translateX&#125;) rotate($&#123;deg*1 + 56.5*((now / size).toFixed(3))&#125;deg)`&#125;\"&gt;&lt;/div&gt;&lt;/div&gt; 4、本地存储 将一些数据缓存到localStorage，可以减少Http请求，从而优化页面加载时间。 在这个项目中首页歌曲列表以及搜索历史用到了本地缓存，拿搜索历史来举栗：12345678910111213141516created() &#123; if (!localStorage.searchHistory) &#123; let searchHistory = ['前端', '童话镇', '刚好遇见你'] localStorage.searchHistory = JSON.stringify(searchHistory) &#125; &#125;,methods: &#123; _search(keywords) &#123; //判断搜索列表中是否已存在 let searchHistory = JSON.parse(localStorage.searchHistory) let find = searchHistory.findIndex((val) =&gt; &#123; return val === keywords &#125;) find === -1 ? localStorage.searchHistory = JSON.stringify([keywords, ...searchHistory]) : '' &#125;&#125; 5、图片懒加载使用了vue-lazyload插件用法👉：1$ npm install vue-lazyload 123456789//main.jsimport VueLazyLoad from 'vue-lazyload'import def_lazy_img from '../static/img/loading.gif' //懒加载的默认图片Vue.use(VueLazyLoad,&#123; loading: def_lazy_img&#125;) //使用懒加载组件//在使用img标签的地方使用&lt;img v-lazy=\"item.al.picUrl\" alt=\"\"&gt; 6、歌词滚动与高亮因为api提供的歌词包括时间，如：[03:57.280]原谅我这一生不羁放纵爱自由所以首先要进行字符串切割：123456789101112131415161718192021222324&lt;div class=\"lyric\"&gt; &lt;div class=\"roll-lyric\" v-html=\"lyrics\" ref=\"lyric\"&gt;&lt;/div&gt;&lt;/div&gt;computed: &#123; lyrics() &#123; let lyrics = '' this.lyricArr = [] if (this.lyric) &#123; let arr = this.lyric.split('\\n') for (let item of arr) &#123; if (item) &#123; let arr2 = item.split(']') this.lyricArr.push(arr2[0].substring(1,3)*60+arr2[0].substring(4)*1) if (arr2) &#123; lyrics += `&lt;p class='lyrichook' style='margin: 10px 0'&gt;$&#123;arr2[1]&#125;&lt;/p&gt;` &#125; &#125; &#125; &#125; else &#123; lyrics = '暂无歌词~' &#125; return lyrics &#125;&#125; 然后在播放的监听事件中与播放的当前做对比：123456789101112131415this.$refs.myAudio.addEventListener('play', () =&gt; &#123; this.pDOM = [...document.querySelectorAll('.lyrichook')] timer = setInterval(() =&gt; &#123; this.now = audioDOM.currentTime this.lyricArr.forEach((item, index) =&gt; &#123; if (parseInt(item) == parseInt(this.now)) &#123; this.pDOM.forEach((p) =&gt; &#123; p.style.color = 'rgba(255,255,255,.8)' //其它歌词清除高亮 &#125;); this.pDOM[index].style.color = '#f12c61' //歌词高亮 this.$refs.lyric.style.transform = `translateY(-$&#123;(index-2)*25&#125;px)` //歌词滚动 &#125; &#125;); &#125;, 1000)&#125;) 到这就ok了😜 7、vuex状态管理推荐官方调试工具 devtools extension 想进一步理解vuex，可以看这篇博客vuex学习实践笔记 之前看到好多人写的vuex，把整个项目的数据放到了一个state里，导致应用的所有状态集中到一个很大的对象。但是，当应用变得很大时，store 对象会变得臃肿不堪。 所以我建议(个人见解，轻喷)：将 store 分割到模块（module）。每个模块拥有自己的 state、mutation、action、getters。这样方便管理与后期的维护。 车已到站✌️。 不知不觉写了这么多，老铁们凑合这看吧😁，觉得还行的可以点个star，你的star是我继续开源创作的动力，谢谢！！！ 项目地址： https://github.com/hzzly/MagicMusic欢迎大家的star啦~","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"},{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"},{"name":"vuex","slug":"vuex","permalink":"http://yoursite.com/tags/vuex/"}]},{"title":"本地存储sessionStorage与localStorage","date":"2017-04-26T15:44:04.000Z","path":"2017/04/26/本地存储sessionStorage与localStorage/","text":"sessionStorage 数据的存储仅特定于某个会话中，也就是说数据只保持到浏览器关闭，当浏览器关闭后重新打开这个页面时， 之前的存储已经被清除。 localStorage 是一个持久化的存储，它并不局限于会话。除非主动删除数据，否则数据是永远不会过期的。 一、localStorage和sessionStorage操作 localStorage和sessionStorage都具有相同的操作方法，例如setItem、getItem和removeItem等 1.setItem存储value12sessionStorage.setItem(\"name\", \"hzzly\");localStorage.setItem(\"blog\", \"hzzly.github.io\"); 2.getItem获取value12let name = sessionStorage.getItem(\"name\");let blog = localStorage.getItem(\"blog\"); 3.removeItem删除key12sessionStorage.removeItem(\"name\");localStorage.removeItem(\"blog\"); 4.clear清除所有的key/value12sessionStorage.clear();localStorage.clear(); 5.其他操作方法：点操作和[] web Storage不但可以用自身的setItem,getItem等方便存取，也可以像普通对象一样用点(.)操作符，及[]的方式进行数据存储及读取，像如下的代码： 12345678910//存localStorage.name = \"hzzly\"; localStorage[\"age\"] = \"21\"; sessionStorage.name = \"hzzly\"; sessionStorage[\"age\"] = \"21\";//取let name1 = localStorage.namelet age1 = localStorage[\"age\"]let name2 = sessionStorage.namelet age2 = sessionStorage[\"age\"] 6.localStorage和sessionStorage的key和length属性实现遍历 sessionStorage和localStorage提供的key()和length可以方便的实现存储的数据遍历，例如下面的代码： 123456var storage = window.localStorage; for (var i=0, len = storage.length; i &lt; len; i++)&#123; let key = storage.key(i); let value = storage.getItem(key); console.log(key + \"=\" + value); &#125; 二、实例 storage只能存储字符串的数据，对于JS中常用的数组或对象却不能直接存储，可以用下面两个方法进行转换： JSON.stringify() 用于从一个对象解析出字符串 JSON.parse() 用于从一个字符串中解析出json对象 1.localStorage/sessionStorage存取数组123456//存let language = ['HTML/HTML5', 'CSS/CSS3', 'JavaScript', 'Vue', 'React']localStorage.language = JSON.stringify(language)sessionStorag.language = JSON.stringify(language)//取let storageLanguage = JSON.parse(localStorage.language) 2.localStorage存取对象1234567891011//存let myInfo = &#123; 'name': 'hzzly', 'age': 21, 'school': 'ECUT', 'city': 'NanChang'&#125;localStorage.myInfo = JSON.stringify(myInfo)sessionStorag.myInfo = JSON.stringify(myInfo)//取let storageLanguage = JSON.parse(localStorage.myInfo)","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"读书笔记-es6字符串的扩展","date":"2017-04-22T15:07:23.000Z","path":"2017/04/22/读书笔记-es6字符串的扩展/","text":"字符串的扩展一、字符串的遍历器接口123456for (let codePoint of 'foo') &#123; console.log(codePoint)&#125;// \"f\"// \"o\"// \"o\" 二、at返回字符串给定位置的字符1234//es5'abc'.charAt(0) // \"a\"//es6'abc'.at(0) // \"a\" 三、indexOf(), includes(), startsWith(), endsWith() indexOf() 确定一个字符串是否包含在另一个字符串中(es5) includes() 返回布尔值，表示是否找到了参数字符串。 startsWith() 返回布尔值，表示参数字符串是否在源字符串的头部。 endsWith()返回布尔值，表示参数字符串是否在源字符串的尾部。 1234var s = 'Hello world!';s.startsWith('Hello') // trues.endsWith('!') // trues.includes('o') // true 支持第二个参数，表示开始搜索的位置1234var s = 'Hello world!';s.startsWith('Hello') // trues.endsWith('!') // trues.includes('o') // true 1234var s = 'Hello world!';s.startsWith('world', 6) // trues.endsWith('Hello', 5) // trues.includes('Hello', 6) // false endsWith的行为与其他两个方法有所不同。它针对前n个字符，而其他两个方法针对从第n个位置直到字符串结束。 四、repeat() 返回一个新字符串，表示将原字符串重复n次。 12'x'.repeat(3) // \"xxx\"'hello'.repeat(2) // \"hellohello\" 五、padStart()，padEnd() 字符串补全长度 padStart() 头部补全 padEnd() 尾部补全第一个参数用来指定字符串的最小长度，第二个参数是用来补全的字符串。如果省略第二个参数，默认使用空格补全长度 1234'x'.padStart(5, 'ab') // 'ababx''x'.padStart(4, 'ab') // 'abax''x'.padEnd(5, 'ab') // 'xabab''x'.padEnd(4, 'ab') // 'xaba' 六、模板字符串123// 字符串中嵌入变量let name = \"hzzly\", time = \"today\";`Hello $&#123;name&#125;, how are you $&#123;time&#125;?` Github地址： https://github.com/hzzly/learn-es6","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"},{"name":"es6","slug":"es6","permalink":"http://yoursite.com/tags/es6/"},{"name":"JavaScrip","slug":"JavaScrip","permalink":"http://yoursite.com/tags/JavaScrip/"}]},{"title":"读书笔记-es6变量的解构赋值","date":"2017-04-21T14:59:09.000Z","path":"2017/04/21/读书笔记-es6变量的解构赋值/","text":"变量的解构赋值 这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。 一、数组的解构赋值数组的元素是按次序排列的，变量的取值由它的位置决定 1234567let [a, b, c] = [1, 2, 3]a // 1b // 2c // 3let [head, ...tail] = [1, 2, 3, 4]head // 1tail // [2, 3, 4] 默认值 12let [foo = true] = [];foo // true 栗子：12345// 返回一个数组function example() &#123; return [1, 2, 3];&#125;let [a, b, c] = example(); 二、对象的解构赋值对象的属性没有次序，变量必须与属性同名，才能取到正确的值 123let &#123; foo, bar &#125; = &#123; foo: \"aaa\", bar: \"bbb\" &#125;;foo // \"aaa\"bar // \"bbb\" 默认值 12345var &#123;x = 3&#125; = &#123;&#125;;x // 3var &#123;x, y = 5&#125; = &#123;x: 1&#125;;x // 1y // 5 栗子： 将现有对象的方法，赋值到某个变量。 12345678910//将Math对象的对数、正弦、余弦三个方法，赋值到对应的变量上let &#123; log, sin, cos &#125; = Math // 返回一个对象function example() &#123; return &#123; foo: 1, bar: 2 &#125;;&#125;let &#123; foo, bar &#125; = example(); 提取json数据 12345678let jsonData = &#123; id: 42, status: \"OK\", data: [867, 5309]&#125;;let &#123; id, status, data: number &#125; = jsonData;console.log(id, status, number);// 42, \"OK\", [867, 5309] 三、字符串的解构赋值123456const [a, b, c, d, e] = 'hzzly'a // \"h\"b // \"z\"c // \"z\"d // \"l\"e // \"y\" 123//length属性let &#123;length : len&#125; = 'hello';len // 5 四、函数参数的解构赋值1234function add([x, y])&#123; return x + y;&#125;add([1, 2]); // 3 Github地址： https://github.com/hzzly/learn-es6","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"},{"name":"es6","slug":"es6","permalink":"http://yoursite.com/tags/es6/"},{"name":"JavaScrip","slug":"JavaScrip","permalink":"http://yoursite.com/tags/JavaScrip/"}]},{"title":"读书笔记-es6let与const","date":"2017-04-09T14:16:56.000Z","path":"2017/04/09/读书笔记-es6let与const/","text":"let和const 两种新的声明变量的方法 一、let用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。 1.块级作用域 2.不存在变量提升 123456// var 的情况console.log(foo); // 输出undefinedvar foo = 2;// let 的情况console.log(bar); // 报错ReferenceErrorlet bar = 2; 3.暂时性死区 12345var tmp = 123;if (true) &#123; tmp = 'abc'; // ReferenceError let tmp;&#125; 上面代码中，存在全局变量tmp，但是块级作用域内let又声明了一个局部变量tmp，导致后者绑定这个块级作用域，所以在let声明变量前，对tmp赋值会报错。 4.不允许重复声明 12345678910// 报错function () &#123; let a = 10; var a = 1;&#125;// 报错function () &#123; let a = 10; let a = 1;&#125; 二、constconst声明一个只读的常量。一旦声明，常量的值就不能改变。const一旦声明变量，就必须立即初始化，不能留到以后赋值。只在声明所在的块级作用域内有效。 const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针，const只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。 123456const foo = &#123;&#125;;// 为 foo 添加一个属性，可以成功foo.prop = 123;foo.prop // 123// 将 foo 指向另一个对象，就会报错foo = &#123;&#125;; // TypeError: \"foo\" is read-only 上面代码中，常量foo储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把foo指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。 Github地址： https://github.com/hzzly/learn-es6 文章来源hzzly博客技术分享","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"},{"name":"es6","slug":"es6","permalink":"http://yoursite.com/tags/es6/"}]},{"title":"vuex学习实践笔记","date":"2017-04-04T12:11:26.000Z","path":"2017/04/04/vuex学习实践笔记/","text":"Vuex是什么？ Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。 栗如(travel store)：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import * as types from '../types'//数据const state = &#123; travelsList: [], searchKey: &#123; page: 0, limit: 20 &#125;, scroll: true&#125;//用户行为(可以处理异步),触发 mutations 来改变 stateconst actions = &#123; /** * 获取约跑步列表 */ getTravelsList(&#123; commit &#125;) &#123; if(state.scroll) &#123; commit(types.GET_TRAVELS_PAGE_NUM) commit(types.COM_LOADING_STATUS, true), commit(types.GET_TRAVELS_SCORLL_STATUS, false) api.TravelsList() .then(res =&gt; &#123; console.log(res) commit(types.COM_LOADING_STATUS, false), commit(types.GET_TRAVELS_SCORLL_STATUS, true) commit(types.GET_TRAVELS_LIST, res) &#125;) &#125; &#125;, /** * 参加 */ joinTravel(&#123; commit &#125;, id) &#123; ... &#125;&#125;//可以过滤 state 中的数据const getters = &#123; travelsList: state =&gt; state.travelsList, travelListIndex: state =&gt; state.travelsList.slice(0,4)&#125;//唯一能改变 state 的方法(纯函数)const mutations = &#123; [types.GET_TRAVELS_LIST](state, res) &#123; if(state.searchKey.page &lt;= 1) &#123; state.travelsList = res.data &#125; else &#123; state.travelsList = state.travelsList.concat(res.data) &#125; &#125;, [types.GET_TRAVELS_SEARCH_KEY](state, params) &#123; state.searchKey = params &#125;, [types.GET_TRAVELS_PAGE_NUM](state) &#123; state.searchKey['page'] += 1 &#125;, [types.GET_TRAVELS_SCORLL_STATUS](state, status) &#123; state.scroll = status &#125;&#125;//导出一个 travel store 模块export default &#123; state, actions, getters, mutations&#125; 每一个 Vuex 应用的核心就是 store（仓库）。”store” 基本上就是一个容器，它包含着你的应用中大部分的状态(state)数据。 Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。 你不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交(commit) mutations。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。 用一张图来理解一下 客户端(Client) -&gt; action -&gt; mutations -&gt; state -&gt; 客户端 可以看出在vuex中数据是单一流向的：视图(view)触发action，action提交(commit)到mutations，mutations改变state(数据)，state的改变，相应的组件也会相应的更新。 1.State 单一状态树，唯一数据源，能够直接清晰的读懂数据的结构。 1.1在 Vue 组件中获得数据123456789101112131415//storeconst state = &#123; travelsList: [], searchKey: &#123; page: 0, limit: 20 &#125;, scroll: true&#125;//在view中直接获取data () &#123; return &#123; scroll: this.$store.state.scroll &#125;&#125;, 1.2mapState 辅助函数12345678910computed: mapState([ // 映射 this.scroll 为 this.$store.state.scroll 'scroll'])//或对象展开运算符computed: &#123; ...mapState(&#123; 'scroll' &#125;)&#125; 2.Getters 对state数据进行过滤或直接返回 2.1在 Vue 组件中获得Getters数据1234567891011//storeconst getters = &#123; travelsList: state =&gt; state.travelsList, travelListIndex: state =&gt; state.travelsList.slice(0,4)&#125;//在view中直接获取data () &#123; return &#123; travelListIndex: this.$store.getters.travelListIndex &#125;&#125;, 2.2mapGetters 辅助函数12345678910computed: mapGetters([ // 映射 this.travelListIndex 为 this.$store.state.travelListIndex 'travelListIndex'])//或对象展开运算符computed: &#123; ...mapGetters(&#123; 'travelListIndex' &#125;)&#125; 3.Mutations 要更改 Vuex 的 store 中的数据，唯一方法是提交 mutation。每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。这个回调函数就是我们实际进行数据更改的地方。 1234567891011const mutations = &#123; //使用常量替代 Mutation 事件类型 [types.GET_TRAVELS_LIST](state, res) &#123; if(state.searchKey.page &lt;= 1) &#123; state.travelsList = res.data &#125; else &#123; state.travelsList = state.travelsList.concat(res.data) &#125; &#125;, ...&#125; 当我们在这改变数据时，其它引用此state数据的 Vue 组件也会自动得到更新。 4.Actions 用户的一些行为，来提交到mutations改变数据。可在这进行异步操作。 1234567891011121314151617181920const actions = &#123; //es6的参数解构 getTravelsList(&#123; commit &#125;) &#123; if(state.scroll) &#123; commit(types.GET_TRAVELS_PAGE_NUM) commit(types.COM_LOADING_STATUS, true), commit(types.GET_TRAVELS_SCORLL_STATUS, false) api.TravelsList() .then(res =&gt; &#123; console.log(res) commit(types.COM_LOADING_STATUS, false), commit(types.GET_TRAVELS_SCORLL_STATUS, true) commit(types.GET_TRAVELS_LIST, res) &#125;) &#125; &#125;, joinTravel(&#123; commit &#125;, id) &#123; ... &#125;&#125; 4.1分发 Action12345created() &#123; if (this.travelListIndex.length == 0) &#123; this.$store.dispatch('getTravelsList') &#125;&#125;, 4.2mapActions 辅助函数12345methods: &#123; ...mapActions([ 'getTravelsList' // 映射 this.getTravelsList() 为 this.$store.dispatch('getTravelsList') ]),&#125; 5.Modules 当应用变得很大时，store 对象会变得臃肿不堪。为了解决这个问题，Vuex 允许我们将 store 分割到模块（module）。每个模块拥有自己的 state、mutation、action、getters 12345678910111213141516171819const moduleA = &#123; state: &#123; ... &#125;, mutations: &#123; ... &#125;, actions: &#123; ... &#125;, getters: &#123; ... &#125;&#125;const moduleB = &#123; state: &#123; ... &#125;, mutations: &#123; ... &#125;, actions: &#123; ... &#125;&#125;const store = new Vuex.Store(&#123; modules: &#123; a: moduleA, b: moduleB &#125;&#125;)store.state.a // -&gt; moduleA 的状态store.state.b // -&gt; moduleB 的状态 6.项目实践 进阶vue全家桶 DIY一个自己的音乐播放器","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"},{"name":"vuex","slug":"vuex","permalink":"http://yoursite.com/tags/vuex/"}]},{"title":"读书笔记-es5Array对象","date":"2017-03-30T04:24:01.000Z","path":"2017/03/30/读书笔记-es5Array对象/","text":"1.创建 Array 对象的语法：123new Array();new Array(size);new Array(element0, element1, ..., elementn) 2.属性 属性 描述 constructor 返回对创建此对象的数组函数的引用 length 设置或返回数组中元素的数目 prototype 允许向对象添加属性和方法 3.常用方法 方法 描述 concat() 连接两个或更多的数组，并返回结果 join() 把数组的所有元素放入一个字符串。元素通过指定的分隔符进行分隔 pop() 删除并返回数组的最后一个元素 push() 向数组的末尾添加一个或更多元素，并返回新的长度 reverse() 颠倒数组中元素的顺序 shift() 删除并返回数组的第一个元素，会修改原数组 unshift() 向数组的开头添加一个或更多元素，并返回新的长度 slice() 从某个已有的数组返回选定的元素，不修改原数组 sort() 对数组的元素进行排序 splice() 删除元素，并向数组添加新元素，返回删除的元素，会修改原数组 valueOf() 返回某个字符串对象的原始值 4.循环 方法 描述 entries() 返回一个数组的迭代对象，该对象包含数组的键值对 (key/value) every() 使用指定函数检测数组中的所有元素是否都符合指定条件（通过函数提供）。如果数组中检测到有一个元素不满足，则返回 false ，且剩余的元素不会再进行检测，如果所有元素都满足条件，则返回 true，不会改变原始数组 filter() 检查指定数组中符合条件的所有元素，并返回符合条件所有元素的数组(新数组)，不会改变原始数组 find() 返回通过测试（函数内判断）的数组的第一个元素的值。当数组中的元素在测试条件时返回 true 时，返回符合条件的元素，之后的值不会再调用执行函数，如果没有符合条件的元素返回 undefined ，不会改变原始数组 findIndex() 返回传入一个测试条件（函数）符合条件的数组第一个元素位置。当数组中的元素在测试条件时返回 true 时，返回符合条件的元素的索引位置，之后的值不会再调用执行函数，如果没有符合条件的元素返回 -1 ，不会改变原始数组 forEach() 对数组的每个元素执行一次提供的函数，但总是返回undefined map() 数组中的每个元素都调用一次提供的函数后返回处理过的结果。返回值是一个新的数组，不会改变原始数组 4.栗子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475//concat()let a = [1,2,3]a.concat(4,5) //[1,2,3,4,5] //join()let a = [1,2,3]a.join() //1,2,3 //shift()let a = [1,2,3,4]a.shift() //1a //[2,3,4] //unshift()let a = [1,2,3,4]a.unshift(6) //5a //[6,1,2,3,4] //slice()let a = [1,2,3]a.slice(1) //[2,3] let a = [1,2,3]a.slice(1,2) //[2] //splice()let a = [1,2,3,4,5]a.splice(1,1) //[2] let a = [1,2,3,4,5]a.splice(1,1,'hzzly') //[2]a //[1, \"hzzly\", 3, 4, 5] //entries()const fruits = [\"Banana\", \"Orange\", \"Apple\", \"Mango\"]fruits.entries()//[0, \"Banana\"]//[1, \"Orange\"]//[2, \"Apple\"]//[3, \"Mango\"] //every()const ages = [32, 33, 16, 40]ages.every((val, index) =&gt; val &gt;= 18) //false //filterconst ages = [32, 33, 16, 40]ages.filter((val, index) =&gt; val &gt;= 18) //[32, 33, 40]ages.filter((val, index) =&gt; val &gt;= 18).length //3 //find()const ages = [32, 33, 16, 40]ages.find((val, index) =&gt; val &gt;= 18) //32 //findIndex()const ages = [32, 33, 16, 40]ages.findIndex((val, index) =&gt; val &gt;= 18) //0ages.findIndex((val, index) =&gt; val === 16) //2ages.findIndex((val, index) =&gt; val &gt; 40) //-1 //forEach()const ages = [32, 33, 16, 40]const arr = ages.forEach((val, index) =&gt; &#123; console.log(val) //可遍历到所有数组元素 return val + 10&#125;)//arr: 总是返回undefined //mapconst ages = [32, 33, 16, 40]const arr = ages.map((val, index) =&gt; &#123; console.log(val) //可遍历到所有数组元素 return val + 10&#125;)// arr: [42, 43, 26, 50]","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"es5","slug":"es5","permalink":"http://yoursite.com/tags/es5/"}]},{"title":"读书笔记-es5String对象","date":"2017-03-29T05:48:14.000Z","path":"2017/03/29/读书笔记-es5String对象/","text":"1.创建 String 对象的语法：12new String(s);String(s); 2.属性 属性 描述 constructor 对创建该对象的函数的引用 length 字符串的长度 prototype 允许向对象添加属性和方法 3.常用方法 方法 描述 charAt() 返回在指定位置的字符 concat() 连接字符串 indexOf() 检索字符串 lastIndexOf() 从后向前搜索字符串 match() 找到一个或多个正则表达式的匹配 slice() 提取字符串的片断，并在新的字符串中返回被提取的部分 split() 把字符串分割为字符串数组 toLowerCase() 把字符串转换为小写 toUpperCase() 把字符串转换为大写 toString() 返回字符串 valueOf() 返回某个字符串对象的原始值 4.栗子123456789101112131415161718192021222324//charAt()let str=\"Hello world!\"str.charAt(1) //e //concat()let str1=\"Hello \"let str2=\"world!\"str1.concat(str2) //Hello world! //indexOf()let str=\"Hello world!\"str.indexOf(\"Hello\") //0str.indexOf(\"World\") //-1 (没有就返回-1)str.indexOf(\"world\") //6 //slice()let str=\"Hello happy world!\"str.slice(6) //happy world! //split()let str=\"How are you doing today?\"str.split(\" \") //[\"How\", \"are\", \"you\", \"doing\", \"today?\"]str.split(\"\") //[\"H\", \"o\", \"w\", \" \", \"a\", \"r\", \"e\", \" \", \"y\", \"o\", \"u\", \" \", \"d\", \"o\", \"i\", \"n\", \"g\", \" \", \"t\", \"o\", \"d\", \"a\", \"y\", \"?\"]str.split(\" \",3) //[\"How\", \"are\", \"you\"]","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"es5","slug":"es5","permalink":"http://yoursite.com/tags/es5/"}]},{"title":"Express与MongoDB的缠绵","date":"2017-03-25T11:00:36.000Z","path":"2017/03/25/Express与MongoDB的缠绵/","text":"前奏Express 是什么？ Express 是一个基于 Node.js 平台的极简、灵活的 web 应用开发框架，它提供一系列强大的特性，帮助你创建各种 Web 和移动设备应用。 全局安装express脚手架1$ npm install express-generator -g 创建express项目1234$ express myapp$ cd myapp$ npm install$ DEBUG=myapp npm start MongoDB与Mongoose？ MongoDB是一个对象数据库，是用来存储数据的；存储的数据格式为JSON。 Mongoose是封装了MongoDB操作(增删改查等)的一个对象模型库,是用来操作这些数据的。 安装MongoDB：https://www.mongodb.com/download-center?jmp=nav 安装Mongoose：1$ npm install mongoose --save 一、连接MongoDB 在项目根目录下新建/lib/mongo.js 123var mongoose = require(\"mongoose\");var db = mongoose.connect('mongodb://localhost:27017/myblog');module.exports = db 要连接的数据库为myblog 二、Schema 一种以文件形式存储的数据库模型骨架，无法直接通往数据库端，不具备对数据库的操作能力，仅仅只是数据库模型在程序片段中的一种表现，可以说是数据属性模型(传统意义的表结构)，又或着是“集合”的模型骨架 新建一个用户Schema 在项目根目录下新建/models/users.js 12345678910111213141516var mongoose = require(\"mongoose\");var db = require('../lib/mongo');//一个用户模型var UserSchema = new mongoose.Schema(&#123; username : &#123; type:String &#125;, password : &#123;type: String&#125;, avatar : &#123;type: String&#125;, age : &#123; type:Number, default:0 &#125;, description : &#123; type: String&#125;, email : &#123; type: String &#125;, github : &#123; type: String &#125;, time : &#123; type:Date, default:Date.now &#125;&#125;);//创建Modelvar UserModel = db.model(\"user\", UserSchema );module.exports = UserModel user：数据库中的集合名称,当我们对其添加数据时如果user已经存在，则会保存到其目录下，如果不存在，则会创建user集合，然后在保存数据。 拥有了Model，我们也就拥有了操作数据库的金钥匙，就可以使用Model来进行增删改查的具体操作。 Entity Entity–由Model创建的实体，使用save方法保存数据，Model和Entity都有能影响数据库的操作，但Model比Entity更具操作性。所以此项目主要用的Model。 12345678910111213var UserEntity = new UserModel(&#123; name : \"hzzly\", age : 21, email: \"hjingren@aliyun.com\", github: 'https://github.com/hzzly'&#125;);UserEntity.save(function(error,doc)&#123; if(error)&#123; console.log(\"error :\" + error); &#125;else&#123; console.log(doc); &#125;&#125;); 三、封装数据库的CURD 在lib文件下新建api.js 采用Promise封装对数据库的操作，避免回调地狱，使得代码能够更好的被读懂和维护。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879var UserModel = require('../models/users');module.exports = &#123; /** * 添加数据 * @param &#123;[type]&#125; data 需要保存的数据对象 */ save(data) &#123; return new Promise((resolve, reject) =&gt; &#123; //model.create(保存的对象,callback) UserModel.create(data, (error, doc) =&gt; &#123; if(error)&#123; reject(error) &#125;else&#123; resolve(doc) &#125; &#125;) &#125;) &#125;, find(data=&#123;&#125;, fields=null, options=&#123;&#125;) &#123; return new Promise((resolve, reject) =&gt; &#123; //model.find(需要查找的对象(如果为空，则查找到所有数据), 属性过滤对象[可选参数], options[可选参数], callback) UserModel.find(data, fields, options, (error, doc) =&gt; &#123; if(error)&#123; reject(error) &#125;else&#123; resolve(doc) &#125; &#125;) &#125;) &#125;, findOne(data) &#123; return new Promise((resolve, reject) =&gt; &#123; //model.findOne(需要查找的对象,callback) UserModel.findOne(data, (error, doc) =&gt; &#123; if(error)&#123; reject(error) &#125;else&#123; resolve(doc) &#125; &#125;) &#125;) &#125;, findById(data) &#123; return new Promise((resolve, reject) =&gt; &#123; //model.findById(需要查找的id对象 ,callback) UserModel.findById(data, (error, doc) =&gt; &#123; if(error)&#123; reject(error) &#125;else&#123; resolve(doc) &#125; &#125;) &#125;) &#125;, update(conditions, update) &#123; return new Promise((resolve, reject) =&gt; &#123; //model.update(查询条件,更新对象,callback) UserModel.update(conditions, update, (error, doc) =&gt; &#123; if(error)&#123; reject(error) &#125;else&#123; resolve(doc) &#125; &#125;) &#125;) &#125;, remove(conditions) &#123; return new Promise((resolve, reject) =&gt; &#123; //model.update(查询条件,callback) UserModel.remove(conditions, (error, doc) =&gt; &#123; if(error)&#123; reject(error) &#125;else&#123; resolve(doc) &#125; &#125;) &#125;) &#125;&#125; 四、使用 在/routers/index.js中使用 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849var api = require('../lib/api');router.post('/login', function(req, res, next) &#123; var user = &#123; username : req.body.username, password: req.body.password &#125;; api.findOne(user) .then(result =&gt; &#123; console.log(result) &#125;)&#125;)router.post('/sign_up', function(req, res, next) &#123; var user = &#123; username : req.body.username, password: req.body.password, email: req.body.email &#125;; api.save(user) .then(result =&gt; &#123; console.log(result) &#125;)&#125;)router.get('/user_list', function(req, res, next) &#123; //返回所有用户 api.find(&#123;&#125;) .then(result =&gt; &#123; console.log(result) &#125;) //返回只包含一个键值name、age的所有记录 api.find(&#123;&#125;,&#123;name:1, age:1, _id:0&#125;) .then(result =&gt; &#123; console.log(result) &#125;) //返回所有age大于18的数据 api.find(&#123;\"age\":&#123;\"$gt\":18&#125;&#125;) .then(result =&gt; &#123; console.log(result) &#125;) //返回20条数据 api.find(&#123;&#125;,null,&#123;limit:20&#125;) .then(result =&gt; &#123; console.log(result) &#125;) //查询所有数据，并按照age降序顺序返回数据 api.find(&#123;&#125;,null,&#123;sort:&#123;age:-1&#125;&#125;) //1是升序，-1是降序 .then(result =&gt; &#123; console.log(result) &#125;)&#125;) 项目Github地址： https://github.com/hzzly/express-mongodb如果对你有帮助，欢迎star 文章来源hzzly博客技术分享","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"浅谈Promise","date":"2017-03-25T07:29:12.000Z","path":"2017/03/25/浅谈Promise/","text":"说说promise Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。 所谓Promise，简单说就是一个容器(对象)，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。 接触过promise的的都知道它的应用场景和用途，Promise可以用来避免异步操作函数里的嵌套回调（callback hell）问题，因为解决异步最直接的方法是回调嵌套，将后一个的操作放在前一个操作的异步回调里，但如果操作多了，就会有很多层的嵌套(回调地狱)。 12345678910$.ajax(url1, function(data1)&#123; // do something... $.ajax(url2, function(data2)&#123; // do something... $.ajax(url3, function(data3)&#123; // do something... done(data3); // 返回数据 &#125;) &#125;);&#125;); Promise学术点的描述： promise代表一个异步操作的执行返回状态，这个执行返回状态在promise对象创建时未必已知。它允许你为异步操作的成功或失败指定处理方法。 这使得异步方法可以像同步方法那样返回值：异步方法会返回一个包含了原返回状态的 promise 对象来替代原返回状态。 Promise的表现如果使用回调方法处理多个操作的异步场景，判断某个操作成功或失败的控制在于声明的匿名函数里面，使用Promise对象则可以重新定义异步执行的状态和控制逻辑。 promise的最重要的特点就是它把我们处理任何函数调用的成功或者失败的方式规范成了可预测的形式，特别是如果这个调用实际上的异步的。 Promise中有几个状态： pending: 初始状态。 非 fulfilled 或 rejected。 resolved: 成功的操作。也有的成为fulfilled 。 rejected: 失败的操作。 状态转换关系为： pending-&gt;resolved(fulfilled)，pending-&gt;rejected。 Promise对象有以下两个特点: 对象的状态不受外界影响，Promise对象代表一个异步操作，有三种状态：Pending（进行中）、Resolved（已完成，又称 Fulfilled）和Rejected（已失败） 一旦状态改变，就不会再变，任何时候都可以得到这个结果。 用法说了这么多，直接上代码。 123456789101112131415var promise = new Promise((resolve, reject) =&gt; &#123; // do somthing, maybe async if (success)&#123; return resolve(res); &#125; else &#123; return reject(err); &#125;&#125;); promise.then(res =&gt; &#123; // do something... e.g console.log(res);&#125;, err =&gt; &#123; // deal the err.&#125;) 或封装成方法1234567891011121314151617function fetch(data) &#123; return new Promise((resolve, reject) =&gt; &#123; // do somthing, maybe async if (success)&#123; resolve(res); &#125; else &#123; reject(err); &#125; &#125;)&#125; fetch(data) .then(res =&gt; &#123; console.log(res) &#125;, err =&gt; &#123; // deal the err. &#125;) 异步嵌套回调123456789101112131415161718192021222324252627function loadAsync1()&#123; return new Promise((resolve, reject) =&gt; &#123; //异步操作 setTimeout(() =&gt; &#123; console.log('异步任务1'); resolve('异步任务1传过来的值'); &#125;, 2000); &#125;); &#125;function loadAsync2(data1)&#123; return new Promise((resolve, reject) =&gt; &#123; //异步操作 setTimeout(() =&gt; &#123; console.log('异步任务2'); resolve('异步任务2传过来的值'); &#125;, 2000); &#125;); &#125;function loadAsync3(data2)&#123; return new Promise((resolve, reject) =&gt; &#123; //异步操作 setTimeout(() =&gt; &#123; console.log('异步任务3'); resolve('异步任务3传过来的值'); &#125;, 2000); &#125;); &#125; 有返回值12345678loadAsync1() .then(data1 =&gt; &#123; return loadAsync2(data1) &#125;) .then(data2 =&gt; &#123; return loadAsync3(data2) &#125;) .then(okFn, failFn) 没有返回值12345678loadAsync1() .then(data1 =&gt; &#123; loadAsync2(data1) &#125;) .then(data2 =&gt;&#123; loadAsync3(data2) &#125;) .then(res =&gt; console.log(res)) 输出的值为： 异步任务1异步任务1传过来的值异步任务2异步任务2传过来的值异步任务3异步任务3传过来的值 promise.all方法 Promise.all 可以接收一个元素为 Promise 对象的数组作为参数，当这个数组里面所有的 Promise 对象都变为 resolve 时，该方法才会返回。 12345678910111213141516var p1 = new Promise((resolve) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(\"第一个promise\"); &#125;, 3000);&#125;); var p2 = new Promise((resolve) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(\"第二个promise\"); &#125;, 1000);&#125;); Promise.all([p1, p2]) .then((result) =&gt; &#123; console.log(result); // [\"第一个promise\", \"第二个promise\"] &#125;); 上面的代码中，all接收一个数组作为参数，p1,p2是并行执行的，等两个都执行完了，才会进入到then，all会把所有的结果放到一个数组中返回，所以我们打印出我们的结果为一个数组。 值得注意的是，虽然p2的执行顺序比p1快，但是all会按照参数里面的数组顺序来返回结果。all的使用场景类似于，玩游戏的时候，需要提前将游戏需要的资源提前准备好，才进行页面的初始化。 promise.race方法 Promise.race 可以接收一个元素为 Promise 对象的数组作为参数，这个数组里面所有的 Promise 对象进行竞速，完成一个即可。 12345678910111213141516171819202122var p1 = new Promise((resolve) =&gt; &#123; setTimeout(() =&gt; &#123; console.log('异步任务1执行完成'); resolve(\"第一个promise\"); &#125;, 3000);&#125;); var p2 = new Promise((resolve) =&gt; &#123; setTimeout(() =&gt; &#123; console.log('异步任务2执行完成'); resolve(\"第二个promise\"); &#125;, 1000);&#125;); Promise.race([p1, p2]) .then((result) =&gt; &#123; console.log(result); &#125;);//异步任务2执行完成//第二个promise//异步任务1执行完成 在then里面的回调开始执行时，p1 并没有停止，仍旧在执行。于是再过2秒后，输出了他们结束的标志。 这个race有什么用呢？使用场景还是很多的，比如我们可以用race给某个异步请求设置超时时间，并且在超时后执行相应的操作，代码如下： 123456789101112131415161718192021222324252627282930/请求某个图片资源function requestImg()&#123; var p = new Promise(function(resolve, reject)&#123; var img = new Image(); img.onload = function()&#123; resolve(img); &#125; img.src = 'xxxxxx'; &#125;); return p;&#125;//延时函数，用于给请求计时function timeout()&#123; var p = new Promise(function(resolve, reject)&#123; setTimeout(function()&#123; reject('图片请求超时'); &#125;, 5000); &#125;); return p;&#125;Promise .race([requestImg(), timeout()]) .then(function(results)&#123; console.log(results); &#125;) .catch(function(err)&#123; console.log(err); &#125;); requestImg函数会异步请求一张图片，我把地址写为”xxxxxx”，所以肯定是无法成功请求到的。timeout函数是一个延时5秒的异步操作。我们把这两个返回Promise对象的函数放进race，于是他俩就会赛跑，如果5秒之内图片请求成功了，那么遍进入then方法，执行正常的流程。如果5秒钟图片还未成功返回，那么timeout就跑赢了，则进入catch，报出“图片请求超时”的信息。 一道常见面试题1234567891011121314151617setTimeout(function() &#123; console.log(1)&#125;, 0); new Promise(function executor(resolve) &#123; console.log(2); for( var i=0 ; i&lt;10000 ; i++ ) &#123; i == 9999 &amp;&amp; resolve(); &#125; console.log(3);&#125;).then(function() &#123; console.log(4);&#125;); console.log(5);“2 3 5 4 1” 情景传入一个token，根据这个token请求一次网络，然后获取用户ID，将获取的用户ID访问数据库，获取用户信息 12345678910111213141516171819202122232425262728293031323334353637var request = function (token) &#123; return new Promise((resolve, reject)=&gt; &#123; setTimeout(()=&gt; &#123; token ? resolve(2) : reject('token error'); &#125;,1000) &#125;);&#125;; var find = function (id) &#123; return new Promise((resolve, reject)=&gt; &#123; setTimeout(()=&gt; &#123; id ? resolve(id + '-info') : reject('id error'); &#125;,1000) &#125;);&#125;; request('token') .then(function (id) &#123; return find(id); &#125;) .then(function (info) &#123; console.log( info); &#125;); co(function *() &#123; var id = yield request('token'); var info = yield find(id); console.log(id, info);&#125;); (async function () &#123; var id = await request('token'); var info = await find(id); console.log(id, info);&#125;)(); 之后会有express操作mongondb的基于Promise的封装，敬请期待！","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"},{"name":"promise","slug":"promise","permalink":"http://yoursite.com/tags/promise/"}]},{"title":"移动端touch事件","date":"2017-03-22T14:08:21.000Z","path":"2017/03/22/移动端touch事件/","text":"4个touch事件touchstart 事件：当手指触摸屏幕时候触发，即使已经有一个手指放在屏幕上也会触发。touchmove 事件：当手指在屏幕上滑动的时候连续地触发。调用preventDefault()事件可以阻止滚动。touchend 事件：当手指从屏幕上离开的时候触发。touchcancel 事件：触摸结束的时候触发 触摸事件：touches：当前位于屏幕上的所有手指的列表。targetTouches：位于当前DOM元素上手指的列表。changedTouches：涉及当前事件手指的列表。 Touch对象属性每个Touch对象包含的属性如下： clientX：触摸目标在视口中的x坐标。clientY：触摸目标在视口中的y坐标。identifier：标识触摸的唯一ID。pageX：触摸目标在页面中的x坐标。pageY：触摸目标在页面中的y坐标。screenX：触摸目标在屏幕中的x坐标。screenY：触摸目标在屏幕中的y坐标。target：触摸的DOM节点目标。 12345678910111213141516171819document.addEventListener('touchstart',touch,false);document.addEventListener('touchmove',touch,false);document.addEventListener('touchend',touch,false); function touch (event)&#123; var event = event || window.event; var oInp = document.getElementById(\"inp\"); switch(event.type)&#123; case \"touchstart\": oInp.innerHTML =`Touch started ( $&#123;event.touches[0].clientX&#125; , $&#123;event.touches[0].clientY&#125; )`; break; case \"touchend\": oInp.innerHTML =`&lt;br&gt;Touch end ( $&#123;event.changedTouches[0].clientX&#125; , $&#123;event.changedTouches[0].clientY&#125; )`; break; case \"touchmove\": event.preventDefault(); oInp.innerHTML =`&lt;br&gt;Touch moved ( $&#123;event.touches[0].clientX&#125; , $&#123;event.touches[0].clientY&#125; )`; break; &#125;&#125; 事件(包括鼠标事件)发生的顺序如下：(1) touchstart(2) mouseover(3) mousemove(一次)(4) mousedown(5) mouseup(6) click(7) touchend","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"一个Vue+Canvas的酷炫后台管理","date":"2017-03-21T09:10:38.000Z","path":"2017/03/21/一个Vue-Canvas的酷炫后台管理/","text":"又一个Vue+Cnavas酷炫的后台管理，依然前后端分离（用PC打开，还没适配移动端）。 项目地址： https://github.com/hzzly/canvas-vuedemo地址： http://hjingren.cn/curriculum-design/账号：hzzly 密码：123456欢迎大家的star啦~ 技术栈前台: vue-cli vue vue-router webpack canvas ajax 后台: wamp PHP(ThinkPHP) mysql 功能说明 登录 用户登录 管理员登录 注册 用户注册 Canvas 流星滑过 星星闪闪 后台折线 折线跟着鼠标滑动 Vue 弹出框组件 路由切换动画 通过Ajax调用后台接口 留言板(时间轴) 添加房屋信息 出租 求租 出售 求购 个人信息修改 密码修改 …… 1.登录注册模块 2.后台管理页面 3.留言板(时间轴特效) 目录结构12345678910111213141516171819202122232425|——canvas-vue/| |——build/| |——confg/| |——node_modules/| |——src/| | |——assets/ //静态文件| | |——components/ //页面组件| | | |——Menu.vue //登录注册加载页面| | | |——Home.vue //后台首页| | | |——Login.vue //登录页面| | | |——Regist.vue //注册页面| | | |——Navbar.vue //我的发布| | | |——Messageboard.vue //留言板页面| | | |——... //等等| | |——router/ | | | |——index.js //页面路由| | |——App.vue //父组件| | |——main.js //入口文件| |——static/ | |——.babelrc| |——.editorconfig| |——.gitgnore| |——index.html| |——package.json| |——README.md 技术点 登录注册切换动画–vue的transition转换动画 123456789101112131415&lt;template&gt; &lt;transition name=&quot;fade-out&quot;&gt; ... &lt;/transition&gt;&lt;/template&gt;&lt;style&gt;.fade-out-enter-active, .fade-out-leave-active &#123; transition: all .5s&#125;.fade-out-enter, .fade-out-leave-active &#123; opacity: 0; transform: translateX(-400px);&#125;&lt;/style&gt; 登录注册星星与流星–canvas 123456789101112131415161718192021222324252627282930313233343536373839404142let canvas = document.getElementById('canvas'), ctx = canvas.getContext('2d'), width = window.innerWidth, height = window.innerHeight, //实例化月亮和星星。流星是随机时间生成，所以只初始化数组 moon = new Moon(ctx, width, height), stars = new Stars(ctx, width, height, 200), meteors = [], count = 0 canvas.width = width; canvas.height = height; const meteorGenerator = ()=&gt; &#123; //x位置偏移，以免经过月亮 let x = Math.random() * width + 800 meteors.push(new Meteor(ctx, x, height)) //每隔随机时间，生成新流星 setTimeout(()=&gt; &#123; meteorGenerator() &#125;, Math.random() * 2000)&#125; const frame = ()=&gt;&#123; count++ count % 10 == 0 &amp;&amp; stars.blink() moon.draw() stars.draw() meteors.forEach((meteor, index, arr)=&gt; &#123; //如果流星离开视野之内，销毁流星实例，回收内存 if (meteor.flow()) &#123; meteor.draw() &#125; else &#123; arr.splice(index, 1) &#125; &#125;) requestAnimationFrame(frame)&#125;meteorGenerator()frame() 总结这个项目还没有完成，后期将不定期更新，敬请期待。。 如果觉得还行，欢迎star项目地址： https://github.com/hzzly/canvas-vue项目后台(PHP)地址： https://github.com/hzzly/canvas-vue-backstage 好了，溜了溜了。。。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"},{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"移动端屏幕适配的解决","date":"2017-03-15T14:01:18.000Z","path":"2017/03/15/移动端屏幕适配的解决/","text":"随着手机硬件配置的飞速增长、屏幕尺寸的越来越大和网络带宽的逐渐提升，越来越多的PC业务和服务在向移动端转移。然而在这移动端的时代，为了处理各终端屏幕的适配，是否乱了手脚呢？ 虽然移动端的页面与PC的页面相比简单了不少，但让我们头痛的事情还是要想尽办法让页面能适配众多不同的终端设备。在前几个外包项目中，我做的主要都是移动微信端的。期间也遇到了不同屏幕大小的适配问题，所以今天特来分享一下我的解决方法。 项目地址： https://github.com/hzzly/xyy-vuedemo地址： http://hjingren.cn/xyy-vue/欢迎大家的star啦~ 一、meta标签 meta之viewport，其主要用来告诉浏览器如何规范的渲染Web页面，而你则需要告诉它视窗有多大。在开发移动端页面，我们需要在html中设置meta标签如下： 1&lt;meta name=\"viewport\" content=\"width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0\"&gt; 二、手淘的flexible flexible是一个制作H5适配的开源库，需要在html中引入，可以直接使用阿里CDN： 1&lt;script src=\"http://g.tbcdn.cn/mtb/lib-flexible/0.3.4/??flexible_css.js,flexible.js\"&gt;&lt;/script&gt; 执行这个JS后，会在元素上增加一个data-dpr属性，以及一个font-size样式。JS会根据不同的设备添加不同的data-dpr值，比如说1、2或者3，同时会给html加上对应的font-size的值，比如说37.5px。 三、放弃px拥抱rem 用px写的是绝对单位，这种方法肯定不行。让我们来拥抱rem吧！！！ 我们知道 em 的计算是基于父级元素的，在实际使用中给我们的计算带来了很大的不便。所以 rem 的出现解救了我这样不会算术的人，再也不用担心父级元素的 font-size 了，因为它始终是基于根元素（html） 的。比如默认的 html font-size=16px，那么我想设置12px 的文字就是：12÷16=0.75（rem） 如果对rem还有不懂的可以先看看这个CSS3的REM设置字体大小 刚刚我们引入了手淘的flexible，并给html加了font-size，如此一来，页面中的元素，都可以通过rem单位来设置。他们会根据html元素的font-size值做相应的计算，从而实现屏幕的适配效果。 四、CSS处理器(SASS) 使用Sass的同学，可以使用Sass的函数、混合宏这些功能来实现： 123@function px2rem($px, $base-font-size: 75px) &#123; @return ($px / $base-font-size) * 1rem;&#125; 这里的这个参数$base-font-size: 75px，可以通过(psd文件的宽度/10)来计算。假如psd宽750，则$base-font-size为75px。 使用： psd中量多少就写多少 12345//比如量取box宽为190，高为190，则代码：.box &#123; width: px2rem(190px); height: px2rem(190px);&#125; 没用过的可以用sublime的cssrem的插件实现。 五、图示 六、图示代码 因为这是商业代码，所以就只贴了一部分代码，忘见谅，谢谢最下面有我开源项目的代码，可以参考，如果对你有帮助的话，给个star。 123456789101112131415161718192021222324252627//index.html&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0\"&gt; &lt;title&gt;Demo&lt;/title&gt; &lt;script src=\"http://g.tbcdn.cn/mtb/lib-flexible/0.3.4/??flexible_css.js,flexible.js\"&gt;&lt;/script&gt; &lt;link rel=\"stylesheet\" href=\"index.css\"&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"home\"&gt; &lt;div class=\"home-list\"&gt; &lt;div class=\"list-item\"&gt; &lt;a href=\"/\"&gt; &lt;div class=\"item-l\"&gt; &lt;img src=\"../assets/images/check.png\" alt=\"\"&gt; &lt;span&gt;待审核&lt;/span&gt; &lt;/div&gt; &lt;div class=\"item-r isnew\"&gt;6&lt;/div&gt; &lt;/a&gt; &lt;/div&gt; ... &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041//index.scss@function px2rem($px, $base-font-size: 75px) &#123; @return ($px / $base-font-size) * 1rem;&#125;.home-list &#123; padding-bottom: px2rem(45px); .list-item &#123; box-sizing: border-box; width: px2rem(690px); height: px2rem(190px); line-height: px2rem(190px); margin: px2rem(45px) auto 0; padding: 0 px2rem(50px) 0 px2rem(30px); background: #fff; border-radius: px2rem(20px); a &#123; display: flex; justify-content: space-between; font-size: px2rem(40px); img &#123; width: px2rem(90px); height: px2rem(65px); vertical-align: middle; margin-right: px2rem(30px); &#125; span &#123; color: #000; vertical-align: middle; &#125; .item-r &#123; color: #666666; &amp;.isnew &#123; color: #ff5500; &#125; &#125; &amp;:link,&amp;:visited,&amp;:hover,&amp;:active &#123; text-decoration: none; &#125; &#125; &#125;&#125; 七、开源示例如果觉得还行，欢迎star项目地址： https://github.com/hzzly/xyy-vue 好了，溜了溜了。。。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"移动端1px的解决方法","date":"2017-03-13T13:22:43.000Z","path":"2017/03/13/移动端1px的解决方法/","text":"在上个项目中，移动端1px问题被困扰了好久，设置1px边框，实际显示2px。以下是我在项目中的解决方法，才疏学浅，轻喷。 关于什么是移动端1像素边框问题，先上两张图，大家就明白了。 假的1px: 真的1px: 原来Retine屏的分辨率始终是普通屏幕的2倍，1px的边框在devicePixelRatio=2的retina屏下会显示成2px。 解决方案 transform: scaleY() 12345678910111213141516171819202122232425262728293031323334&lt;div class=&quot;border-1px&quot;&gt;&lt;/div&gt; &lt;style type=&quot;text/scss&quot;&gt;.border-1px &#123; position: relative; &amp;:after&#123; display: block; position: absolute; left: 0; bottom: 0; width: 100%; border-top: 1px solid #000; content: &apos;&apos;; &#125;&#125; @media (-webkit-min-device-pixel-ratio: 1.5),(min-device-pixel-ratio: 1.5) &#123; .border-1px&#123; &amp;::after&#123; -webkit-transform: scaleY(0.7); transform: scaleY(0.7); &#125; &#125;&#125; @media (-webkit-min-device-pixel-ratio: 2),(min-device-pixel-ratio: 2) &#123; .border-1px&#123; &amp;::after&#123; -webkit-transform: scaleY(0.5); transform: scaleY(0.5); &#125; &#125;&#125;&lt;/style&gt; 到这已经成功解决了1px问题。 好了，吃饭去喽，溜了溜了。。。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"axios在vue中的简单配置与使用","date":"2017-03-12T13:34:08.000Z","path":"2017/03/12/axios在vue中的简单配置与使用/","text":"尤雨溪之前在微博发布消息，不再继续维护vue-resource，并推荐大家开始使用 axios 。 一、axios 简介axios 是一个基于Promise 用于浏览器和 nodejs 的 HTTP 客户端，它本身具有以下特征： 从浏览器中创建 XMLHttpRequest 从 node.js 发出 http 请求 支持 Promise API 拦截请求和响应 转换请求和响应数据 取消请求 自动转换JSON数据 客户端支持防止 CSRF/XSRF 二、引入方式：npm:123$ npm install axios//淘宝源$ cnpm install axios bower:1$ bower install axios cdn:1&lt;script src=\"https://unpkg.com/axios/dist/axios.min.js\"&gt;&lt;/script&gt; 三、vue中axios的配置 之前那个开源项目一开始就打算用axios，在网上找了好多文章与攻略，发现好多都不太详细，所以打算自己动手配置一个，(不要怂，撸起袖子就是干)。 我的配置：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import axios from 'axios'import qs from 'qs' import * as _ from '../util/tool' axios.defaults.timeout = 5000; //响应时间axios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded;charset=UTF-8'; //配置请求头axios.defaults.baseURL = '你的接口地址'; //配置接口地址 //POST传参序列化(添加请求拦截器)axios.interceptors.request.use((config) =&gt; &#123; //在发送请求之前做某件事 if(config.method === 'post')&#123; config.data = qs.stringify(config.data); &#125; return config;&#125;,(error) =&gt;&#123; _.toast(\"错误的传参\", 'fail'); return Promise.reject(error);&#125;); //返回状态判断(添加响应拦截器)axios.interceptors.response.use((res) =&gt;&#123; //对响应数据做些事 if(!res.data.success)&#123; // _.toast(res.data.msg); return Promise.reject(res); &#125; return res;&#125;, (error) =&gt; &#123; _.toast(\"网络异常\", 'fail'); return Promise.reject(error);&#125;); //返回一个Promise(发送post请求)export function fetchPost(url, params) &#123; return new Promise((resolve, reject) =&gt; &#123; axios.post(url, params) .then(response =&gt; &#123; resolve(response.data); &#125;, err =&gt; &#123; reject(err); &#125;) .catch((error) =&gt; &#123; reject(error) &#125;) &#125;)&#125;////返回一个Promise(发送get请求)export function fetchGet(url, param) &#123; return new Promise((resolve, reject) =&gt; &#123; axios.get(url, &#123;params: param&#125;) .then(response =&gt; &#123; resolve(response.data) &#125;, err =&gt; &#123; reject(err) &#125;) .catch((error) =&gt; &#123; reject(error) &#125;) &#125;)&#125; 四、vue中使用配置好的axios123456789101112131415161718192021export default &#123; /** * 用户登录 */ Login(params) &#123; return fetchPost('/users/api/userLogin', params) &#125;, /** * 用户注册 */ Regist(params) &#123; return fetchPost('/users/api/userRegist', params) &#125;, /** * 发送注册验证码 */ RegistVerifiCode(tellphone) &#123; return fetchPost('/users/api/registVerifiCode', &#123;tellphone: tellphone&#125;) &#125;, ......&#125; 如果觉得还行，欢迎star项目地址： https://github.com/hzzly/xyy-vuedemo地址： http://hjingren.cn/xyy-vue/ 好了，溜了溜了。。。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"},{"name":"axios","slug":"axios","permalink":"http://yoursite.com/tags/axios/"}]},{"title":"开源的收获","date":"2017-03-09T15:57:05.000Z","path":"2017/03/09/开源的收获/","text":"第一次在github上发布了开源《Qu约》后，不到两天，被人star了137次，fork了25次，这个成绩大大出乎了我自己的意料！ Github地址： https://github.com/hzzly/xyy-vuedemo地址： http://hjingren.cn/xyy-vue/欢迎大家的star啦~ 同时也让我收获到了许多： github首次破百 掘金的阅读量与喜欢量同时给他人带来了不一样的价值 segmentfault的阅读量、收藏量与声望值，把其中的价值传给他人 收获了一个offer 给我以后就业增加了一份保证 结交了好多同行开发者 分享与开源，让技术生生不息。借用一本书de名字，Just for fun。开源是一种情怀，happy hacking！ 革命尚未成功，我们还需努力。。。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"进阶vue全家桶","date":"2017-03-08T01:47:54.000Z","path":"2017/03/08/进阶vue全家桶/","text":"有人说只会vue不会vuex还只是个切图仔，所以本项目将带领你进阶vue全家桶。前端结合Vue2.0全家桶(vue+vue-router+vuex+axios+es6+sass)以及后端Node,一个前后端分离的练手项目。本项目可以作为一个前端vue进阶项目，从前端flex布局到前端vue以及组件分离的使用，再到后端Node以及Leancloud的结合，是一个打通前后端流程的一个项目。欢迎大家前来star。如果有任何问题，可以给我留言，我们互相学习讨论，一起进步。注：本项目为开源项目，非本人同意不能用于商业应用。 预览地址： http://hzzly.net/xyy-vue/Github地址： https://github.com/hzzly/xyy-vue欢迎大家的star啦~ 功能说明 首页轮播图 首页热门活动 约跑步活动列表 约出行活动列表 个人中心 查看个人活动 学生认证(待开发) 学生信息修改 消息通知(后台接口待开发) 选择高校(待开发) 登录 注册 活动详情 活动报名 活动发布 时间选择组件 地址选择组件 文件上传 axios的封装 …… 公共组件 弹出文字组件 弹出框组件 loading组件 toast组件 时间选择器组件 地址选择器组件 …… 目录结构 123456789101112131415161718192021222324252627282930313233343536373839|——xyy-vue/| |——build/| |——confg/| |——node_modules/| |——src/| | |——assets/ //静态文件| | |——components/ //公共组件| | |——fetch/| | | |——api.js //axios封装与api| | |——pages/ //存放项目页面| | | |——Detail.vue //活动详情页面| | | |——Home.vue //首页| | | |——Login.vue //登录页面| | | |——Navbar.vue //我的发布| | | |——NotFound.vue //出错页面| | | |——Post.vue //发布活动页面| | | |——Regist.vue //注册页面| | | |——Set.vue //设置页面| | | |——Sport.vue //约跑步活动列表页面| | | |——Travel.vue //约出行活动列表页面| | | |——User.vue //个人中心页面| | | |——UserInfo.vue //个人详情页面| | | |——UserMsg.vue //消息列表页面| | |——router/ | | | |——index.js //页面路由| | |——util //公用方法| | |——vuex / //存放vuex代码| | | |——modules / //数据模块| | | |——store.js //vuex主入口| | | |——types.js //vuex的types文件| | |——App.vue //父组件| | |——main.js //入口文件| |——static/| |——.babelrc| |——.editorconfig| |——.gitgnore| |——index.html| |——package.json| |——README.md 主要难点1.各个组件数据的共享 传参的方法对于多层嵌套的组件将会非常繁琐，并且对于兄弟组件间的状态传递无能为力。而且也会导致代码难以维护 解决方法：采用vuex进行状态管理，把所有事件和状态存储在store对象中，在组件中通过计算属性获得事件，因此就有了实时性。 Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。 每一个 Vuex 应用的核心就是 store（仓库）。”store” 基本上就是一个容器，它包含着应用中大部分的状态(state)。 Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。 你不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交(commit) mutations。这样使得我们可以方便地跟踪每一个状态的变化。 代码如下(以一个user module为例)：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566//vuex/modules/user.jsimport api from '../../fetch/api'import * as types from '../types' const state = &#123; // 用户登录状态 loginStatus: JSON.parse(localStorage.getItem('loginStatus')) || false,&#125; const actions = &#123; /** * 用户登录 */ setUserInfo(&#123; commit &#125;, res) &#123; localStorage.setItem('loginStatus', true) commit(types.SET_LOGIN_STATUS, true) &#125;, /** * 退出登录 */ setSignOut(&#123; commit &#125;) &#123; localStorage.removeItem('loginStatus') commit(types.SET_LOGIN_STATUS, false) &#125;,&#125; const getters = &#123; loginStatus: state =&gt; state.loginStatus&#125; const mutations = &#123; [types.SET_LOGIN_STATUS](state, status) &#123; state.loginStatus = status &#125; &#125; export default &#123; state, actions, getters, mutations&#125; //User.vue&lt;template&gt; &lt;div class=\"user\"&gt; &lt;div v-if=\"!loginStatus\"&gt; ... &lt;/div&gt; &lt;div v-else&gt; ... &lt;/div&gt; &lt;/div&gt;&lt;/template&gt; &lt;script&gt;import &#123; mapGetters &#125; from 'vuex'export default &#123; computed: &#123; ...mapGetters([ 'loginStatus' ]) &#125;&#125;&lt;/script&gt; 2.时间选择组件(要可选择时间段) 规则： 默认值为：开始日期在后天，结束日期在第六天 今天以前不可选择 点击某个日子，则将最近的节点移动过 如果离两个节点一样，则将开始日期移动过去 两个节点也可选到1天里；显示为各一半 一开始打算在github上搜索一个然后直接拿来用，发现都是不符合我的设计，所以打算自己撸一个，(不要怂，撸起袖子就是干)。终于经过几个晚上的奋战写出来了(期间遇到了各种坑)。代码就不贴出来了 代码传送门 总结虽然只是做了个小小的个人开源项目，但是我感觉收获还是很大的，很多知识点掌握得更加的牢固，对 vue全家桶 的理解又更深了一些。这个项目还没有完成，后期将不定期更新，敬请期待。。 如果觉得还行，欢迎star项目地址： https://github.com/hzzly/xyy-vue 好了，溜了溜了。。。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"},{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"},{"name":"vuex","slug":"vuex","permalink":"http://yoursite.com/tags/vuex/"}]},{"title":"webpack工程化","date":"2017-03-07T12:01:48.000Z","path":"2017/03/07/webpack工程化/","text":"一、webpack是什么 webpack is a module bundler. webpack takes modules with dependencies and generates static assets representing those modules webpack 是一个模块打包工具，输入为包含依赖关系的模块集，输出为打包合并的前端静态资源。在上一节的前端工程化中，已经介绍过，webpack 是同时支持 AMD 和 CommonJs 的模块定义方式，不仅如此，webpack 可以将任何前端资源视为模块，如 css，图片，文本。 二、为什么要使用它在 webpack 出现之前，已经有了一些打包工具，如 Browserify、grunt、gulp… 这些打包工具工具功能单一，只能完成特定的任务，然而 web 前端工程是复杂的，一个 webapp 对于业务代码的要求可能有： 代码可以分块，实现按需加载 首屏加载时间要尽量减少 需要集成一些第三方库 webpack 的出现正式为了解决这些问题，在 webpack 中，提供了一下这些功能： 1.代码分块： webpack 有两种类型的模块依赖，一种是同步的，一种是异步的。在打包的过程中可以将代码输出为代码块（chunk），代码块可以实现按需加载。 异步加载的代码块通过分割点（spliting point）来确定。2.Loaders： Webpack 本身只会处理 Javascript，为了实现将其他资源也定义为模块，并转化为 Javascript， Webpack 定义 loaders , 不同的 loader 可以将对应的资源转化为 Javascript 模块。3.智能的模块解析： webpack 可以很容易将第三方库转化为模块集成到项目代码中，模块的依赖可以用表达式的方式（这在其他打包工具中是没有支持的），这种模块依赖叫做动态模块依赖。4.插件系统： webpack 的可定制化在于其插件系统，其本身的很多功能也是通过插件的方式实现，插件系统形成了 webpack 的生态，是的可以使用很多开源的第三方插件。 三、webpack 核心思想1.万物皆模块： 在 webpack 的世界中，除了 Javascript，其他任何资源都可以当做模块的方式引用。2.按需加载： webapp 的优化关键在于代码体积，当应用体积增大，实现代码的按需加载是毕需，这也是 webpack 出现的根本原因。3.可定制化： 任何一个工具都不可能解决所有问题，提供解决方案才是最可行的，webpack 基于可定制化的理念构建，通过插件系统，配置文件，可以实现大型项目的定制需求。 四、安装配置在此之前你应该已经安装了 node.js. 全局安装webapck或webpack-dev-server(开启一个本地服务)12$ npm install webpack -g$ npm install webpack-dev-server -g 在项目中安装webpack和webpack-dev-server12$ npm install webpack --save-dev$ npm install webpack-dev-server --save-dev webpack使用1234567//name.jslet name = 'hzzly'export default name//index.jsimport name from './name'document.getElementById('app').textContent = `hello~$&#123;name&#125;` 1.命令行的使用1$ webpack src/index.js dist/bundle.js 语法：webpack 要打包的文件 打包输出的文件 2.配置文件的使用在项目目录下创建 webpack.config.js如下(简单的配置)：12345678910111213141516171819202122232425262728var webpack = require('webpack')module.exports = &#123; entry: './src/index.js', //入口 output: &#123; path: './dist/', //输出路径 filename: 'bundle.js' //输出文件名 &#125;, module: &#123; loaders: [ &#123; test: /\\.js[x]?$/, exclude: /node_modules/, loader: 'babel-loader', //处理.js或.jsx文件loader query: &#123; presets: ['env'] &#125; &#125;, &#123; test: /\\.css$/, loader: \"style-loader!css-loader\" //处理.css文件loader &#125;, &#123; test: /\\.(png|jpg)$/, loader: 'url-loader?limit=8192' //处理图片loader &#125; ] &#125;&#125; 执行：123$ webpack//或开启本地服务器并实时监听文件变化$ webpack-dev-server --inline --colors --hot Github地址： https://github.com/hzzly/webpack欢迎大家的star啦~ 好了，装了一大波，溜了溜了。。。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"前后端分离的尝试","date":"2017-03-06T02:21:49.000Z","path":"2017/03/06/前后端分离的尝试/","text":"首次尝试前后端分离是在一个外包项目中: 点匠科技 o2o的家装类 移动项目微信平台前端开发主要工作内容是将原有的android、ios 应用 配合后端工程师开发一套 微信产品,个人角色为 前端开发工程师 负责界面 html css vue 前后端数据联调等工作 项目地址(测试账号:15103585135 测试密码:123456) 这次的项目技术栈 vue vue-router vuex weui sass es6 ajax 通过这次项目，让我体会到了这种前后端分离的快感，所以特来分享一波。 如果你没有尝试过前后端分离的工作流程，那么可以先试想一下这样的流程改变： 把流程从 PM：“我要这个功能” 后端：“这个先找前端做个模板” 前端：“模板做完了” 后端：“我来对接一下，这里样式不对” 前端：“我改完了” 后端：“功能交付” PM：“春节要加这个活动” 后端：“这个先找前端改个模板” 前端：“模板做完了” 后端：“我来对接一下，这里样式不对” 前端：“我改完了” 后端：“功能交付” 变成 PM：“我要这个功能” 前端：“我要接口” 后端：“接口完成了” 前端：“我来对接一下，功能交付” PM：“春节要加这个活动” 前端：“需要增加接口” 后端：“接口完成了” 前端：“我来对接一下，功能交付” 由此可见，前后端分离的主要概念就是：后台只需提供API接口，前端调用AJAX实现数据呈现。 前后端分离的实现对技术人员尤其是前端人员的要求会上升一个层次，前端的工作不只是切页面写模板或是处理一些简单的js逻辑，前端需要处理服务器返回的各种数据格式，还需要掌握一系列的数据处理逻辑、MVVM思想和各种主流前端框架(React, Vue..)。 意义对于前后端分离的意义我们也可以看做是前端渲染的意义，我主要总结了下面四点： 1. 彻底解放前端 前端不再需要向后台提供模板或是后台在前端html中嵌入后台代码，前后端解耦，增加可读性。 2. 提高工作效率，分工更加明确 前后端分离的工作流程可以使前端只关注前端的事，后台只关心后台的活，两者开发可以同时进行，在后台还没有时间提供接口的时候，前端可以先将数据写死或者调用本地的json文件即可，页面的增加和路由的修改也不必再去麻烦后台，开发更加灵活。 3. 局部性能提升 通过前端路由的配置，我们可以实现页面的按需加载，无需一开始加载首页便加载网站的所有的资源，服务器也不再需要解析前端页面，在页面交互及用户体验上有所提升。 4. 降低维护成本 通过目前主流的前端MVVM框架，我们可以非常快速的定位及发现问题的所在，客户端的问题不再需要后台人员参与及调试，代码重构及可维护性增强。 面对快速发展的前端，我们应该去适应其带来的工作方式和流程的改变，目前的前后端分离的工作方式必然是今后的趋势所在，作为一个前端开发人员，我们应当承担这个普及前端新知识和改变现状的职责。 我的Github 好了，装了一大波，溜了溜了。。。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"前端入坑笔记–JavaScript类型检测","date":"2017-03-05T12:29:59.000Z","path":"2017/03/05/前端入坑笔记–JavaScript类型检测/","text":"JavaScript变量可以用来保存两种类型的值：基本类型值和引用类型值 5种基本数据类型：String Number Boolean Undefined Null 引用类型：Object Array Data RegExp Function Error Map … ES6引入了一种新的原始数据类型Symbol，表示独一无二的值 一、typeof typeof 用来判断各种数据类型,有两种写法：typeof xxx, typeof(xxx) 123456789101112131415161718var a = 'hzzly';var b = true;var c = 22;var d;var e = null;var o = new Object();var f = function () &#123;&#125; console.log( typeof a ); //stringconsole.log( typeof b ); //booleanconsole.log( typeof c ); //numberconsole.log( typeof d ); //undefinedconsole.log( typeof e ); //objectconsole.log( typeof o ); //objectconsole.log( typeof f ); //function console.log( typeof &#123;&#125; ); //objectconsole.log( typeof [] ); //object 这里面包含了js里面的五种数据类型 number string boolean undefined object和函数类型 function 看到这里你肯定会问了：我怎么去区分对象，数组和null呢? 接下来我们就用到另外两个利器：Object.prototype.toString.call instanceof/constructor 二、Object.prototype.toString.call1234567891011121314151617var gettype=Object.prototype.toString gettype.call('hzzly') 输出 [object String] gettype.call(22) 输出 [object Number] gettype.call(true) 输出 [object Boolean] gettype.call(undefined) 输出 [object Undefined] gettype.call(null) 输出 [object Null] gettype.call(&#123;&#125;) 输出 [object Object] gettype.call([]) 输出 [object Array] gettype.call(function()&#123;&#125;) 输出 [object Function] 三、instanceof/constructor根据规定，所有引用类型的值都是Object的实例。因此，在检测一个引用类型值和Object 构造函数时，instanceof 操作符始终会返回true。当然，如果使用instanceof 操作符检测基本类型的值，则该操作符始终会返回false，因为基本类型不是对象。 123456789console.log([] instanceof Array); //trueconsole.log(/^$/ instanceof RegExp); //trueconsole.log([] instanceof Object); //true console.log([].constructor === Array); //trueconsole.log([].constructor === Object); //false 我们的constructor可以避免instanceof检测的时候,用Object也是true的问题console.log(&#123;&#125;.constructor === Object); //true console.log(1 instanceof Number); //false 看到这里，刚才的问题我们解决了 检测数组，ECMAScript5新增了Array.isArray() 方法。这个方法的目的是最终确定某个值到底是不是数组，而不管它是在哪个全局执行环境中创建。这个方法的用法如下： 123if( Array.isArray(value) )&#123; //对数组执行某些操作&#125; 四、题外话基本类型值与引用类型值具有如下特点： 基本类型值在内存中占据固定大小的空间，因此被保存在栈内存中 从一个变量向另一个变量复制基本类型的值，会创建这个值得一个副本 引用类型的值是对象，保存在堆内存中 包含引用类型值得变量实际上包含的并不是对象本身，而是一个指向该对象的指针 从一个变量向另一个变量复制引用类型的值，复制的其实是指针，因此两个变量最终都指向同一个对象 好了，遛了遛了。。。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"手把手用Node的socket.io撸一个简单聊天室","date":"2017-03-04T14:51:43.000Z","path":"2017/03/04/手把手用Node的socket.io撸一个简单聊天室/","text":"点击查看效果 Socket.IO用于浏览器与Node.js之间实现实时通信。 Socket.IO设计的目标是支持任何的浏览器，任何Mobile设备。 支持主流的PC浏览器 (IE,Safari,Chrome,Firefox,Opera等)， Mobile浏览器(iphone Safari/ipad Safari/Android WebKit/WebOS WebKit等)。 Socket.IO解决了实时的通信问题，并统一了服务端与客户端的编程方式。 启动了socket以后，就像建立了一条客户端与服务端的管道，两边可以互通有无。 一、初始化一个Express项目通过应用生成器工具 express 可以快速创建一个应用的骨架。 123456789101112// 全局安装express 脚手架$ npm install express-generator -g //在当前工作目录创建一个命名为 chat-node 的应用$ express -e chat-node //安装所有依赖$ cd chat-node $ npm install //启动这个应用（MacOS 或 Linux 平台）：$ npm start 然后在浏览器中打开 http://localhost:3000/ 网址就可以看到这个应用了 二、安装Socket.IO这里使用 npm 安装到项目依赖中 1$ npm install socket.io --save 三、整合Socket.IO到项目中找到服务开启的www文件 根目录 &gt; bin &gt; www 1234567891011121314151617181920212223//在创建服务器(var server = http.createServer(app))之后添加如下代码 var io = require('socket.io')(server); // 在线用户var onlineUser = &#123;&#125;;// 在线人数var onlineCount = 0; io.on('connection', (socket) =&gt; &#123; // 监听新用户加入 console.log('a user connected'); socket.on('disconnect', () =&gt; &#123; console.log('user disconnected'); &#125;); //监听post数据加入 socket.on('post', function(say) &#123; io.emit('post', say) //通过io的emit把数据发送到前台 &#125;);&#125;); 通过传递server(HTTP服务器)来初始化socket.io的一个新实例，然后监听连接sockets的connection事件，并将其记录到控制台。 三、修改前台代码在 views 目录下新建一个index.html 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0\"&gt; &lt;title&gt;聊天室&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"chat\" id=\"chatApp\" v-cloak&gt; &lt;ul class=\"room-list\"&gt; &lt;li v-for=\"item in msgList\"&gt; &lt;div class=\"msg-detail\"&gt;&#123;&#123;item&#125;&#125;&lt;/div&gt; &lt;/li&gt; &lt;/ul&gt; &lt;div class=\"send-box\"&gt; &lt;input type=\"text\" placeholder=\"写点什么喃...\" v-model=\"sendMsg\"&gt; &lt;button type=\"button\" @click=\"doSendMsg\"&gt;发送&lt;/button&gt; &lt;/div&gt;&lt;/div&gt; &lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/socket.io/1.7.3/socket.io.min.js\"&gt;&lt;/script&gt;&lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.1.3/vue.js\"&gt;&lt;/script&gt;&lt;script src=\"/javascripts/index.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 我在里面引入了socket.io以及vue(更好的渲染数据) 四、编写业务代码 在 public &gt; javascripts 下新建一个index.js 12345678910111213141516171819202122const socket = io(); //加载socket.io-client会暴露一个全局io并连接。 const vue = new Vue(&#123; //实例化一个Vue实例 el: \"#chatApp\", data() &#123; return &#123; //数据驱动 sendMsg: '', msgList: [] &#125; &#125;, mounted() &#123; socket.on('post', (say) =&gt; &#123; //接收服务端的 post 命令 this.msgList.push(say) //添加到msgList中给前台渲染出来 &#125;) &#125;, methods: &#123; doSendMsg() &#123; //监听按钮发送的事件 socket.emit('post', this.sendMsg) //把要发送的数据emit到服务端 this.sendMsg = '' &#125; &#125;&#125;) 五、在对应路由中打开index.html 在 routes &gt; index.js 修改如下代码 1234/* GET home page. */router.get('/', function(req, res, next) &#123; res.sendFile(path.join(__dirname, '../views', 'index.html'));&#125;); 然后在浏览器中打开 http://localhost:3000/ 网址就可以看到这个应用de效果了 Github Demo欢迎star 好了，遛了遛了。。。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"},{"name":"node","slug":"node","permalink":"http://yoursite.com/tags/node/"}]},{"title":"Web的Flex弹性盒模型","date":"2017-03-03T01:24:26.000Z","path":"2017/03/03/Web的Flex弹性盒模型/","text":"一、Flex布局是什么？Flex是Flexible Box的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。任何一个容器都可以指定为Flex布局。 123.box&#123; display: flex;&#125; 行内元素也可以使用Flex布局。 123.box&#123; display: inline-flex;&#125; 二、容器的属性 [ flex-direction ] [ flex-wrap ] [ flex-flow ] [ justify-content ] [ align-self ] [ align-items ] [ align-content ] [ order ] 点击查看实例 下方为简略图 好了，遛了遛了。。。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"博客正式上线","date":"2017-03-02T00:49:45.000Z","path":"2017/03/02/博客正式上线/","text":"折腾了一个晚上，终于把Github Page上的博客搭起来了，有点小激动。哈哈哈，蛋定蛋定。之前一直想弄一个博客来着，偶然间发现了这个基于Node的Hexo博客，还可以放到Github上，很方便。你也可以试一试 (:好了，不扯这么多了，此博客将记录我学习的笔记、知识，并将其中承载的价值传给他人。 整理知识，学习笔记 发布日报，杂文，所见所想 撰写发布技术博客（代码支持） 撰写发布学术论文 1234567891011class Refuel &#123; constructor (refuel) &#123; this.refuel = refuel &#125; refuel () &#123; alert(this.refuel) &#125;&#125;new Refuel('加油！！！'); 好了，遛了遛了。。。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]}]