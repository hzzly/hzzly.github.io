[{"title":"webpack工程化","date":"2017-03-07T12:01:48.000Z","path":"2017/03/07/webpack工程化/","text":"一、webpack是什么 webpack is a module bundler. webpack takes modules with dependencies and generates static assets representing those modules webpack 是一个模块打包工具，输入为包含依赖关系的模块集，输出为打包合并的前端静态资源。在上一节的前端工程化中，已经介绍过，webpack 是同时支持 AMD 和 CommonJs 的模块定义方式，不仅如此，webpack 可以将任何前端资源视为模块，如 css，图片，文本。 二、为什么要使用它在 webpack 出现之前，已经有了一些打包工具，如 Browserify、grunt、gulp… 这些打包工具工具功能单一，只能完成特定的任务，然而 web 前端工程是复杂的，一个 webapp 对于业务代码的要求可能有： 代码可以分块，实现按需加载 首屏加载时间要尽量减少 需要集成一些第三方库 webpack 的出现正式为了解决这些问题，在 webpack 中，提供了一下这些功能： 1.代码分块： webpack 有两种类型的模块依赖，一种是同步的，一种是异步的。在打包的过程中可以将代码输出为代码块（chunk），代码块可以实现按需加载。 异步加载的代码块通过分割点（spliting point）来确定。2.Loaders： Webpack 本身只会处理 Javascript，为了实现将其他资源也定义为模块，并转化为 Javascript， Webpack 定义 loaders , 不同的 loader 可以将对应的资源转化为 Javascript 模块。3.智能的模块解析： webpack 可以很容易将第三方库转化为模块集成到项目代码中，模块的依赖可以用表达式的方式（这在其他打包工具中是没有支持的），这种模块依赖叫做动态模块依赖。4.插件系统： webpack 的可定制化在于其插件系统，其本身的很多功能也是通过插件的方式实现，插件系统形成了 webpack 的生态，是的可以使用很多开源的第三方插件。 三、webpack 核心思想1.万物皆模块： 在 webpack 的世界中，除了 Javascript，其他任何资源都可以当做模块的方式引用。2.按需加载： webapp 的优化关键在于代码体积，当应用体积增大，实现代码的按需加载是毕需，这也是 webpack 出现的根本原因。3.可定制化： 任何一个工具都不可能解决所有问题，提供解决方案才是最可行的，webpack 基于可定制化的理念构建，通过插件系统，配置文件，可以实现大型项目的定制需求。 四、安装配置在此之前你应该已经安装了 node.js. 全局安装webapck或webpack-dev-server(开启一个本地服务)12$ npm install webpack -g$ npm install webpack-dev-server -g 在项目中安装webpack和webpack-dev-server12$ npm install webpack --save-dev$ npm install webpack-dev-server --save-dev webpack使用1234567//name.jslet name = 'hzzly'export default name//index.jsimport name from './name'document.getElementById('app').textContent = `hello~$&#123;name&#125;` 1.命令行的使用1$ webpack src/index.js dist/bundle.js 语法：webpack 要打包的文件 打包输出的文件 2.配置文件的使用在项目目录下创建 webpack.config.js如下(简单的配置)：12345678910111213141516171819202122232425262728var webpack = require('webpack')module.exports = &#123; entry: './src/index.js', //入口 output: &#123; path: './dist/', //输出路径 filename: 'bundle.js' //输出文件名 &#125;, module: &#123; loaders: [ &#123; test: /\\.js[x]?$/, exclude: /node_modules/, loader: 'babel-loader', //处理.js或.jsx文件loader query: &#123; presets: ['env'] &#125; &#125;, &#123; test: /\\.css$/, loader: \"style-loader!css-loader\" //处理.css文件loader &#125;, &#123; test: /\\.(png|jpg)$/, loader: 'url-loader?limit=8192' //处理图片loader &#125; ] &#125;&#125; 执行：123$ webpack//或开启本地服务器并实时监听文件变化$ webpack-dev-server --inline --colors --hot Github地址： https://github.com/hzzly/webpack欢迎大家的star啦~ 好了，装了一大波，溜了溜了。。。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"前后端分离的尝试","date":"2017-03-06T02:21:49.000Z","path":"2017/03/06/前后端分离的尝试/","text":"首次尝试前后端分离是在一个外包项目中: 点匠科技 o2o的家装类 移动项目微信平台前端开发主要工作内容是将原有的android、ios 应用 配合后端工程师开发一套 微信产品,个人角色为 前端开发工程师 负责界面 html css vue 前后端数据联调等工作 项目地址(测试账号:15103585135 测试密码:123456) 这次的项目技术栈 vue vue-router vuex weui sass es6 ajax 通过这次项目，让我体会到了这种前后端分离的快感，所以特来分享一波。 如果你没有尝试过前后端分离的工作流程，那么可以先试想一下这样的流程改变： 把流程从 PM：“我要这个功能” 后端：“这个先找前端做个模板” 前端：“模板做完了” 后端：“我来对接一下，这里样式不对” 前端：“我改完了” 后端：“功能交付” PM：“春节要加这个活动” 后端：“这个先找前端改个模板” 前端：“模板做完了” 后端：“我来对接一下，这里样式不对” 前端：“我改完了” 后端：“功能交付” 变成 PM：“我要这个功能” 前端：“我要接口” 后端：“接口完成了” 前端：“我来对接一下，功能交付” PM：“春节要加这个活动” 前端：“需要增加接口” 后端：“接口完成了” 前端：“我来对接一下，功能交付” 由此可见，前后端分离的主要概念就是：后台只需提供API接口，前端调用AJAX实现数据呈现。 前后端分离的实现对技术人员尤其是前端人员的要求会上升一个层次，前端的工作不只是切页面写模板或是处理一些简单的js逻辑，前端需要处理服务器返回的各种数据格式，还需要掌握一系列的数据处理逻辑、MVVM思想和各种主流前端框架(React, Vue..)。 意义对于前后端分离的意义我们也可以看做是前端渲染的意义，我主要总结了下面四点： 1. 彻底解放前端 前端不再需要向后台提供模板或是后台在前端html中嵌入后台代码，前后端解耦，增加可读性。 2. 提高工作效率，分工更加明确 前后端分离的工作流程可以使前端只关注前端的事，后台只关心后台的活，两者开发可以同时进行，在后台还没有时间提供接口的时候，前端可以先将数据写死或者调用本地的json文件即可，页面的增加和路由的修改也不必再去麻烦后台，开发更加灵活。 3. 局部性能提升 通过前端路由的配置，我们可以实现页面的按需加载，无需一开始加载首页便加载网站的所有的资源，服务器也不再需要解析前端页面，在页面交互及用户体验上有所提升。 4. 降低维护成本 通过目前主流的前端MVVM框架，我们可以非常快速的定位及发现问题的所在，客户端的问题不再需要后台人员参与及调试，代码重构及可维护性增强。 面对快速发展的前端，我们应该去适应其带来的工作方式和流程的改变，目前的前后端分离的工作方式必然是今后的趋势所在，作为一个前端开发人员，我们应当承担这个普及前端新知识和改变现状的职责。 我的Github 好了，装了一大波，溜了溜了。。。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"前端入坑笔记–JavaScript类型检测","date":"2017-03-05T12:29:59.000Z","path":"2017/03/05/前端入坑笔记–JavaScript类型检测/","text":"JavaScript变量可以用来保存两种类型的值：基本类型值和引用类型值 5种基本数据类型：String Number Boolean Undefined Null 引用类型：Object Array Data RegExp Function Error Map … ES6引入了一种新的原始数据类型Symbol，表示独一无二的值 一、typeof typeof 用来判断各种数据类型,有两种写法：typeof xxx, typeof(xxx) 123456789101112131415161718var a = 'hzzly';var b = true;var c = 22;var d;var e = null;var o = new Object();var f = function () &#123;&#125;console.log( typeof a ); //stringconsole.log( typeof b ); //booleanconsole.log( typeof c ); //numberconsole.log( typeof d ); //undefinedconsole.log( typeof e ); //objectconsole.log( typeof o ); //objectconsole.log( typeof f ); //functionconsole.log( typeof &#123;&#125; ); //objectconsole.log( typeof [] ); //object 这里面包含了js里面的五种数据类型 number string boolean undefined object和函数类型 function 看到这里你肯定会问了：我怎么去区分对象，数组和null呢? 接下来我们就用到另外两个利器：Object.prototype.toString.call instanceof/constructor 二、Object.prototype.toString.call1234567891011121314151617var gettype=Object.prototype.toStringgettype.call('hzzly') 输出 [object String]gettype.call(22) 输出 [object Number]gettype.call(true) 输出 [object Boolean]gettype.call(undefined) 输出 [object Undefined]gettype.call(null) 输出 [object Null]gettype.call(&#123;&#125;) 输出 [object Object]gettype.call([]) 输出 [object Array]gettype.call(function()&#123;&#125;) 输出 [object Function] 三、instanceof/constructor根据规定，所有引用类型的值都是Object的实例。因此，在检测一个引用类型值和Object 构造函数时，instanceof 操作符始终会返回true。当然，如果使用instanceof 操作符检测基本类型的值，则该操作符始终会返回false，因为基本类型不是对象。 123456789console.log([] instanceof Array); //trueconsole.log(/^$/ instanceof RegExp); //trueconsole.log([] instanceof Object); //trueconsole.log([].constructor === Array); //trueconsole.log([].constructor === Object); //false 我们的constructor可以避免instanceof检测的时候,用Object也是true的问题console.log(&#123;&#125;.constructor === Object); //trueconsole.log(1 instanceof Number); //false 看到这里，刚才的问题我们解决了 检测数组，ECMAScript5新增了Array.isArray() 方法。这个方法的目的是最终确定某个值到底是不是数组，而不管它是在哪个全局执行环境中创建。这个方法的用法如下： 123if( Array.isArray(value) )&#123; //对数组执行某些操作&#125; 四、题外话基本类型值与引用类型值具有如下特点： 基本类型值在内存中占据固定大小的空间，因此被保存在栈内存中 从一个变量向另一个变量复制基本类型的值，会创建这个值得一个副本 引用类型的值是对象，保存在堆内存中 包含引用类型值得变量实际上包含的并不是对象本身，而是一个指向该对象的指针 从一个变量向另一个变量复制引用类型的值，复制的其实是指针，因此两个变量最终都指向同一个对象 好了，遛了遛了。。。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"手把手用Node的socket.io撸一个简单聊天室","date":"2017-03-04T14:51:43.000Z","path":"2017/03/04/手把手用Node的socket.io撸一个简单聊天室/","text":"点击查看效果 Socket.IO用于浏览器与Node.js之间实现实时通信。 Socket.IO设计的目标是支持任何的浏览器，任何Mobile设备。 支持主流的PC浏览器 (IE,Safari,Chrome,Firefox,Opera等)， Mobile浏览器(iphone Safari/ipad Safari/Android WebKit/WebOS WebKit等)。 Socket.IO解决了实时的通信问题，并统一了服务端与客户端的编程方式。 启动了socket以后，就像建立了一条客户端与服务端的管道，两边可以互通有无。 一、初始化一个Express项目通过应用生成器工具 express 可以快速创建一个应用的骨架。 123456789101112// 全局安装express 脚手架$ npm install express-generator -g//在当前工作目录创建一个命名为 chat-node 的应用$ express -e chat-node//安装所有依赖$ cd chat-node $ npm install//启动这个应用（MacOS 或 Linux 平台）：$ npm start 然后在浏览器中打开 http://localhost:3000/ 网址就可以看到这个应用了 二、安装Socket.IO这里使用 npm 安装到项目依赖中 1$ npm install socket.io --save 三、整合Socket.IO到项目中找到服务开启的www文件 根目录 &gt; bin &gt; www 1234567891011121314151617181920212223//在创建服务器(var server = http.createServer(app))之后添加如下代码var io = require('socket.io')(server);// 在线用户var onlineUser = &#123;&#125;;// 在线人数var onlineCount = 0;io.on('connection', (socket) =&gt; &#123; // 监听新用户加入 console.log('a user connected'); socket.on('disconnect', () =&gt; &#123; console.log('user disconnected'); &#125;); //监听post数据加入 socket.on('post', function(say) &#123; io.emit('post', say) //通过io的emit把数据发送到前台 &#125;);&#125;); 通过传递server(HTTP服务器)来初始化socket.io的一个新实例，然后监听连接sockets的connection事件，并将其记录到控制台。 三、修改前台代码在 views 目录下新建一个index.html 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0\"&gt; &lt;title&gt;聊天室&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"chat\" id=\"chatApp\" v-cloak&gt; &lt;ul class=\"room-list\"&gt; &lt;li v-for=\"item in msgList\"&gt; &lt;div class=\"msg-detail\"&gt;&#123;&#123;item&#125;&#125;&lt;/div&gt; &lt;/li&gt; &lt;/ul&gt; &lt;div class=\"send-box\"&gt; &lt;input type=\"text\" placeholder=\"写点什么喃...\" v-model=\"sendMsg\"&gt; &lt;button type=\"button\" @click=\"doSendMsg\"&gt;发送&lt;/button&gt; &lt;/div&gt;&lt;/div&gt;&lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/socket.io/1.7.3/socket.io.min.js\"&gt;&lt;/script&gt;&lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.1.3/vue.js\"&gt;&lt;/script&gt;&lt;script src=\"/javascripts/index.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 我在里面引入了socket.io以及vue(更好的渲染数据) 四、编写业务代码 在 public &gt; javascripts 下新建一个index.js 12345678910111213141516171819202122const socket = io(); //加载socket.io-client会暴露一个全局io并连接。const vue = new Vue(&#123; //实例化一个Vue实例 el: \"#chatApp\", data() &#123; return &#123; //数据驱动 sendMsg: '', msgList: [] &#125; &#125;, mounted() &#123; socket.on('post', (say) =&gt; &#123; //接收服务端的 post 命令 this.msgList.push(say) //添加到msgList中给前台渲染出来 &#125;) &#125;, methods: &#123; doSendMsg() &#123; //监听按钮发送的事件 socket.emit('post', this.sendMsg) //把要发送的数据emit到服务端 this.sendMsg = '' &#125; &#125;&#125;) 五、在对应路由中打开index.html 在 routes &gt; index.js 修改如下代码 1234/* GET home page. */router.get('/', function(req, res, next) &#123; res.sendFile(path.join(__dirname, '../views', 'index.html'));&#125;); 然后在浏览器中打开 http://localhost:3000/ 网址就可以看到这个应用de效果了 Github Demo欢迎star 好了，遛了遛了。。。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"Web的Flex弹性盒模型","date":"2017-03-03T01:24:26.000Z","path":"2017/03/03/Web的Flex弹性盒模型/","text":"一、Flex布局是什么？Flex是Flexible Box的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。任何一个容器都可以指定为Flex布局。 123.box&#123; display: flex;&#125; 行内元素也可以使用Flex布局。 123.box&#123; display: inline-flex;&#125; 二、容器的属性 [ flex-direction ] [ flex-wrap ] [ flex-flow ] [ justify-content ] [ align-self ] [ align-items ] [ align-content ] [ order ] 点击查看实例 下方为简略图 好了，遛了遛了。。。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"博客正式上线","date":"2017-03-02T00:49:45.000Z","path":"2017/03/02/博客正式上线/","text":"折腾了一个晚上，终于把Github Page上的博客搭起来了，有点小激动。哈哈哈，蛋定蛋定。之前一直想弄一个博客来着，偶然间发现了这个基于Node的Hexo博客，还可以放到Github上，很方便。你也可以试一试 (:好了，不扯这么多了，此博客将记录我学习的笔记、知识，并将其中承载的价值传给他人。 整理知识，学习笔记 发布日报，杂文，所见所想 撰写发布技术博客（代码支持） 撰写发布学术论文 1234567891011class Refuel &#123; constructor (refuel) &#123; this.refuel = refuel &#125; refuel () &#123; alert(this.refuel) &#125;&#125;new Refuel('加油！！！'); 好了，遛了遛了。。。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"Hello Hexo","date":"2017-03-01T09:33:06.116Z","path":"2017/03/01/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]